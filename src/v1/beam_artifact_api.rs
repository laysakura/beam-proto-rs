// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.21.5
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `org/apache/beam/model/job_management/v1/beam_artifact_api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ResolveArtifactsRequest)
pub struct ResolveArtifactsRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ResolveArtifactsRequest.artifacts)
    pub artifacts: ::std::vec::Vec<super::beam_runner_api::ArtifactInformation>,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ResolveArtifactsRequest.preferred_urns)
    pub preferred_urns: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ResolveArtifactsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveArtifactsRequest {
    fn default() -> &'a ResolveArtifactsRequest {
        <ResolveArtifactsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResolveArtifactsRequest {
    pub fn new() -> ResolveArtifactsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artifacts",
            |m: &ResolveArtifactsRequest| { &m.artifacts },
            |m: &mut ResolveArtifactsRequest| { &mut m.artifacts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preferred_urns",
            |m: &ResolveArtifactsRequest| { &m.preferred_urns },
            |m: &mut ResolveArtifactsRequest| { &mut m.preferred_urns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveArtifactsRequest>(
            "ResolveArtifactsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveArtifactsRequest {
    const NAME: &'static str = "ResolveArtifactsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artifacts.push(is.read_message()?);
                },
                18 => {
                    self.preferred_urns.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.artifacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.preferred_urns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.artifacts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.preferred_urns {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveArtifactsRequest {
        ResolveArtifactsRequest::new()
    }

    fn clear(&mut self) {
        self.artifacts.clear();
        self.preferred_urns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveArtifactsRequest {
        static instance: ResolveArtifactsRequest = ResolveArtifactsRequest {
            artifacts: ::std::vec::Vec::new(),
            preferred_urns: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveArtifactsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveArtifactsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveArtifactsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveArtifactsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ResolveArtifactsResponse)
pub struct ResolveArtifactsResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ResolveArtifactsResponse.replacements)
    pub replacements: ::std::vec::Vec<super::beam_runner_api::ArtifactInformation>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ResolveArtifactsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveArtifactsResponse {
    fn default() -> &'a ResolveArtifactsResponse {
        <ResolveArtifactsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResolveArtifactsResponse {
    pub fn new() -> ResolveArtifactsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "replacements",
            |m: &ResolveArtifactsResponse| { &m.replacements },
            |m: &mut ResolveArtifactsResponse| { &mut m.replacements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveArtifactsResponse>(
            "ResolveArtifactsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveArtifactsResponse {
    const NAME: &'static str = "ResolveArtifactsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replacements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.replacements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.replacements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveArtifactsResponse {
        ResolveArtifactsResponse::new()
    }

    fn clear(&mut self) {
        self.replacements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveArtifactsResponse {
        static instance: ResolveArtifactsResponse = ResolveArtifactsResponse {
            replacements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveArtifactsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveArtifactsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveArtifactsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveArtifactsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.GetArtifactRequest)
pub struct GetArtifactRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.GetArtifactRequest.artifact)
    pub artifact: ::protobuf::MessageField<super::beam_runner_api::ArtifactInformation>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.GetArtifactRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetArtifactRequest {
    fn default() -> &'a GetArtifactRequest {
        <GetArtifactRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetArtifactRequest {
    pub fn new() -> GetArtifactRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::beam_runner_api::ArtifactInformation>(
            "artifact",
            |m: &GetArtifactRequest| { &m.artifact },
            |m: &mut GetArtifactRequest| { &mut m.artifact },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetArtifactRequest>(
            "GetArtifactRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetArtifactRequest {
    const NAME: &'static str = "GetArtifactRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.artifact)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.artifact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.artifact.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetArtifactRequest {
        GetArtifactRequest::new()
    }

    fn clear(&mut self) {
        self.artifact.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetArtifactRequest {
        static instance: GetArtifactRequest = GetArtifactRequest {
            artifact: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetArtifactRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetArtifactRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetArtifactRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetArtifactRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.GetArtifactResponse)
pub struct GetArtifactResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.GetArtifactResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.GetArtifactResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetArtifactResponse {
    fn default() -> &'a GetArtifactResponse {
        <GetArtifactResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetArtifactResponse {
    pub fn new() -> GetArtifactResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &GetArtifactResponse| { &m.data },
            |m: &mut GetArtifactResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetArtifactResponse>(
            "GetArtifactResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetArtifactResponse {
    const NAME: &'static str = "GetArtifactResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetArtifactResponse {
        GetArtifactResponse::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetArtifactResponse {
        static instance: GetArtifactResponse = GetArtifactResponse {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetArtifactResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetArtifactResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetArtifactResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetArtifactResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ArtifactRequestWrapper)
pub struct ArtifactRequestWrapper {
    // message oneof groups
    pub request: ::std::option::Option<artifact_request_wrapper::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ArtifactRequestWrapper.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactRequestWrapper {
    fn default() -> &'a ArtifactRequestWrapper {
        <ArtifactRequestWrapper as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactRequestWrapper {
    pub fn new() -> ArtifactRequestWrapper {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.job_management.v1.ResolveArtifactsRequest resolve_artifact = 1000;

    pub fn resolve_artifact(&self) -> &ResolveArtifactsRequest {
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(ref v)) => v,
            _ => <ResolveArtifactsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_resolve_artifact(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_resolve_artifact(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resolve_artifact(&mut self, v: ResolveArtifactsRequest) {
        self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resolve_artifact(&mut self) -> &mut ResolveArtifactsRequest {
        if let ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(ResolveArtifactsRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resolve_artifact(&mut self) -> ResolveArtifactsRequest {
        if self.has_resolve_artifact() {
            match self.request.take() {
                ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(v)) => v,
                _ => panic!(),
            }
        } else {
            ResolveArtifactsRequest::new()
        }
    }

    // .org.apache.beam.model.job_management.v1.GetArtifactRequest get_artifact = 1001;

    pub fn get_artifact(&self) -> &GetArtifactRequest {
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(ref v)) => v,
            _ => <GetArtifactRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_artifact(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_artifact(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_artifact(&mut self, v: GetArtifactRequest) {
        self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_artifact(&mut self) -> &mut GetArtifactRequest {
        if let ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(GetArtifactRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_artifact(&mut self) -> GetArtifactRequest {
        if self.has_get_artifact() {
            match self.request.take() {
                ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(v)) => v,
                _ => panic!(),
            }
        } else {
            GetArtifactRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResolveArtifactsRequest>(
            "resolve_artifact",
            ArtifactRequestWrapper::has_resolve_artifact,
            ArtifactRequestWrapper::resolve_artifact,
            ArtifactRequestWrapper::mut_resolve_artifact,
            ArtifactRequestWrapper::set_resolve_artifact,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetArtifactRequest>(
            "get_artifact",
            ArtifactRequestWrapper::has_get_artifact,
            ArtifactRequestWrapper::get_artifact,
            ArtifactRequestWrapper::mut_get_artifact,
            ArtifactRequestWrapper::set_get_artifact,
        ));
        oneofs.push(artifact_request_wrapper::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactRequestWrapper>(
            "ArtifactRequestWrapper",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactRequestWrapper {
    const NAME: &'static str = "ArtifactRequestWrapper";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8002 => {
                    self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::ResolveArtifact(is.read_message()?));
                },
                8010 => {
                    self.request = ::std::option::Option::Some(artifact_request_wrapper::Request::GetArtifact(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &artifact_request_wrapper::Request::ResolveArtifact(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &artifact_request_wrapper::Request::GetArtifact(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &artifact_request_wrapper::Request::ResolveArtifact(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
                &artifact_request_wrapper::Request::GetArtifact(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactRequestWrapper {
        ArtifactRequestWrapper::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactRequestWrapper {
        static instance: ArtifactRequestWrapper = ArtifactRequestWrapper {
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactRequestWrapper {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactRequestWrapper").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactRequestWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactRequestWrapper {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ArtifactRequestWrapper`
pub mod artifact_request_wrapper {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.job_management.v1.ArtifactRequestWrapper.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.ArtifactRequestWrapper.resolve_artifact)
        ResolveArtifact(super::ResolveArtifactsRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.ArtifactRequestWrapper.get_artifact)
        GetArtifact(super::GetArtifactRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ArtifactRequestWrapper as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper)
pub struct ArtifactResponseWrapper {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.staging_token)
    pub staging_token: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.is_last)
    pub is_last: bool,
    // message oneof groups
    pub response: ::std::option::Option<artifact_response_wrapper::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactResponseWrapper {
    fn default() -> &'a ArtifactResponseWrapper {
        <ArtifactResponseWrapper as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactResponseWrapper {
    pub fn new() -> ArtifactResponseWrapper {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.job_management.v1.ResolveArtifactsResponse resolve_artifact_response = 1000;

    pub fn resolve_artifact_response(&self) -> &ResolveArtifactsResponse {
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(ref v)) => v,
            _ => <ResolveArtifactsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_resolve_artifact_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_resolve_artifact_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resolve_artifact_response(&mut self, v: ResolveArtifactsResponse) {
        self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resolve_artifact_response(&mut self) -> &mut ResolveArtifactsResponse {
        if let ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(ResolveArtifactsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resolve_artifact_response(&mut self) -> ResolveArtifactsResponse {
        if self.has_resolve_artifact_response() {
            match self.response.take() {
                ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ResolveArtifactsResponse::new()
        }
    }

    // .org.apache.beam.model.job_management.v1.GetArtifactResponse get_artifact_response = 1001;

    pub fn get_artifact_response(&self) -> &GetArtifactResponse {
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(ref v)) => v,
            _ => <GetArtifactResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_artifact_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_artifact_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_artifact_response(&mut self, v: GetArtifactResponse) {
        self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_artifact_response(&mut self) -> &mut GetArtifactResponse {
        if let ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(GetArtifactResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_artifact_response(&mut self) -> GetArtifactResponse {
        if self.has_get_artifact_response() {
            match self.response.take() {
                ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetArtifactResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "staging_token",
            |m: &ArtifactResponseWrapper| { &m.staging_token },
            |m: &mut ArtifactResponseWrapper| { &mut m.staging_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_last",
            |m: &ArtifactResponseWrapper| { &m.is_last },
            |m: &mut ArtifactResponseWrapper| { &mut m.is_last },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResolveArtifactsResponse>(
            "resolve_artifact_response",
            ArtifactResponseWrapper::has_resolve_artifact_response,
            ArtifactResponseWrapper::resolve_artifact_response,
            ArtifactResponseWrapper::mut_resolve_artifact_response,
            ArtifactResponseWrapper::set_resolve_artifact_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetArtifactResponse>(
            "get_artifact_response",
            ArtifactResponseWrapper::has_get_artifact_response,
            ArtifactResponseWrapper::get_artifact_response,
            ArtifactResponseWrapper::mut_get_artifact_response,
            ArtifactResponseWrapper::set_get_artifact_response,
        ));
        oneofs.push(artifact_response_wrapper::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactResponseWrapper>(
            "ArtifactResponseWrapper",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactResponseWrapper {
    const NAME: &'static str = "ArtifactResponseWrapper";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.staging_token = is.read_string()?;
                },
                16 => {
                    self.is_last = is.read_bool()?;
                },
                8002 => {
                    self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::ResolveArtifactResponse(is.read_message()?));
                },
                8010 => {
                    self.response = ::std::option::Option::Some(artifact_response_wrapper::Response::GetArtifactResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.staging_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.staging_token);
        }
        if self.is_last != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &artifact_response_wrapper::Response::ResolveArtifactResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &artifact_response_wrapper::Response::GetArtifactResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.staging_token.is_empty() {
            os.write_string(1, &self.staging_token)?;
        }
        if self.is_last != false {
            os.write_bool(2, self.is_last)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &artifact_response_wrapper::Response::ResolveArtifactResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
                &artifact_response_wrapper::Response::GetArtifactResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactResponseWrapper {
        ArtifactResponseWrapper::new()
    }

    fn clear(&mut self) {
        self.staging_token.clear();
        self.is_last = false;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactResponseWrapper {
        static instance: ArtifactResponseWrapper = ArtifactResponseWrapper {
            staging_token: ::std::string::String::new(),
            is_last: false,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactResponseWrapper {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactResponseWrapper").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactResponseWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactResponseWrapper {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ArtifactResponseWrapper`
pub mod artifact_response_wrapper {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.resolve_artifact_response)
        ResolveArtifactResponse(super::ResolveArtifactsResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.ArtifactResponseWrapper.get_artifact_response)
        GetArtifactResponse(super::GetArtifactResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ArtifactResponseWrapper as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ArtifactMetadata)
pub struct ArtifactMetadata {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactMetadata.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactMetadata.permissions)
    pub permissions: u32,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactMetadata.sha256)
    pub sha256: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ArtifactMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactMetadata {
    fn default() -> &'a ArtifactMetadata {
        <ArtifactMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactMetadata {
    pub fn new() -> ArtifactMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ArtifactMetadata| { &m.name },
            |m: &mut ArtifactMetadata| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permissions",
            |m: &ArtifactMetadata| { &m.permissions },
            |m: &mut ArtifactMetadata| { &mut m.permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sha256",
            |m: &ArtifactMetadata| { &m.sha256 },
            |m: &mut ArtifactMetadata| { &mut m.sha256 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactMetadata>(
            "ArtifactMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactMetadata {
    const NAME: &'static str = "ArtifactMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.permissions = is.read_uint32()?;
                },
                34 => {
                    self.sha256 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.permissions != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.permissions);
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sha256);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.permissions != 0 {
            os.write_uint32(2, self.permissions)?;
        }
        if !self.sha256.is_empty() {
            os.write_string(4, &self.sha256)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactMetadata {
        ArtifactMetadata::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.permissions = 0;
        self.sha256.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactMetadata {
        static instance: ArtifactMetadata = ArtifactMetadata {
            name: ::std::string::String::new(),
            permissions: 0,
            sha256: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.Manifest)
pub struct Manifest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.Manifest.artifact)
    pub artifact: ::std::vec::Vec<ArtifactMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.Manifest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Manifest {
    fn default() -> &'a Manifest {
        <Manifest as ::protobuf::Message>::default_instance()
    }
}

impl Manifest {
    pub fn new() -> Manifest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artifact",
            |m: &Manifest| { &m.artifact },
            |m: &mut Manifest| { &mut m.artifact },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Manifest>(
            "Manifest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Manifest {
    const NAME: &'static str = "Manifest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artifact.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.artifact {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.artifact {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Manifest {
        Manifest::new()
    }

    fn clear(&mut self) {
        self.artifact.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Manifest {
        static instance: Manifest = Manifest {
            artifact: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Manifest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Manifest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Manifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Manifest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ProxyManifest)
pub struct ProxyManifest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ProxyManifest.manifest)
    pub manifest: ::protobuf::MessageField<Manifest>,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ProxyManifest.location)
    pub location: ::std::vec::Vec<proxy_manifest::Location>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ProxyManifest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProxyManifest {
    fn default() -> &'a ProxyManifest {
        <ProxyManifest as ::protobuf::Message>::default_instance()
    }
}

impl ProxyManifest {
    pub fn new() -> ProxyManifest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Manifest>(
            "manifest",
            |m: &ProxyManifest| { &m.manifest },
            |m: &mut ProxyManifest| { &mut m.manifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "location",
            |m: &ProxyManifest| { &m.location },
            |m: &mut ProxyManifest| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProxyManifest>(
            "ProxyManifest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProxyManifest {
    const NAME: &'static str = "ProxyManifest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.manifest)?;
                },
                18 => {
                    self.location.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.manifest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.location {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.manifest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.location {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProxyManifest {
        ProxyManifest::new()
    }

    fn clear(&mut self) {
        self.manifest.clear();
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProxyManifest {
        static instance: ProxyManifest = ProxyManifest {
            manifest: ::protobuf::MessageField::none(),
            location: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProxyManifest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProxyManifest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProxyManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProxyManifest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProxyManifest`
pub mod proxy_manifest {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ProxyManifest.Location)
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ProxyManifest.Location.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ProxyManifest.Location.uri)
        pub uri: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ProxyManifest.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Location| { &m.name },
                |m: &mut Location| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "uri",
                |m: &Location| { &m.uri },
                |m: &mut Location| { &mut m.uri },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "ProxyManifest.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.uri = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.uri.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.uri);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.uri.is_empty() {
                os.write_string(2, &self.uri)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.uri.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                name: ::std::string::String::new(),
                uri: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProxyManifest.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.GetManifestRequest)
pub struct GetManifestRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.GetManifestRequest.retrieval_token)
    pub retrieval_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.GetManifestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetManifestRequest {
    fn default() -> &'a GetManifestRequest {
        <GetManifestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetManifestRequest {
    pub fn new() -> GetManifestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retrieval_token",
            |m: &GetManifestRequest| { &m.retrieval_token },
            |m: &mut GetManifestRequest| { &mut m.retrieval_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetManifestRequest>(
            "GetManifestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetManifestRequest {
    const NAME: &'static str = "GetManifestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.retrieval_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.retrieval_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.retrieval_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.retrieval_token.is_empty() {
            os.write_string(1, &self.retrieval_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetManifestRequest {
        GetManifestRequest::new()
    }

    fn clear(&mut self) {
        self.retrieval_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetManifestRequest {
        static instance: GetManifestRequest = GetManifestRequest {
            retrieval_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetManifestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetManifestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetManifestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetManifestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.GetManifestResponse)
pub struct GetManifestResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.GetManifestResponse.manifest)
    pub manifest: ::protobuf::MessageField<Manifest>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.GetManifestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetManifestResponse {
    fn default() -> &'a GetManifestResponse {
        <GetManifestResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetManifestResponse {
    pub fn new() -> GetManifestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Manifest>(
            "manifest",
            |m: &GetManifestResponse| { &m.manifest },
            |m: &mut GetManifestResponse| { &mut m.manifest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetManifestResponse>(
            "GetManifestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetManifestResponse {
    const NAME: &'static str = "GetManifestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.manifest)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.manifest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.manifest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetManifestResponse {
        GetManifestResponse::new()
    }

    fn clear(&mut self) {
        self.manifest.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetManifestResponse {
        static instance: GetManifestResponse = GetManifestResponse {
            manifest: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetManifestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetManifestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetManifestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetManifestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.LegacyGetArtifactRequest)
pub struct LegacyGetArtifactRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.LegacyGetArtifactRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.LegacyGetArtifactRequest.retrieval_token)
    pub retrieval_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.LegacyGetArtifactRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LegacyGetArtifactRequest {
    fn default() -> &'a LegacyGetArtifactRequest {
        <LegacyGetArtifactRequest as ::protobuf::Message>::default_instance()
    }
}

impl LegacyGetArtifactRequest {
    pub fn new() -> LegacyGetArtifactRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LegacyGetArtifactRequest| { &m.name },
            |m: &mut LegacyGetArtifactRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retrieval_token",
            |m: &LegacyGetArtifactRequest| { &m.retrieval_token },
            |m: &mut LegacyGetArtifactRequest| { &mut m.retrieval_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LegacyGetArtifactRequest>(
            "LegacyGetArtifactRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LegacyGetArtifactRequest {
    const NAME: &'static str = "LegacyGetArtifactRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.retrieval_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.retrieval_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.retrieval_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.retrieval_token.is_empty() {
            os.write_string(2, &self.retrieval_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LegacyGetArtifactRequest {
        LegacyGetArtifactRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.retrieval_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LegacyGetArtifactRequest {
        static instance: LegacyGetArtifactRequest = LegacyGetArtifactRequest {
            name: ::std::string::String::new(),
            retrieval_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LegacyGetArtifactRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LegacyGetArtifactRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LegacyGetArtifactRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyGetArtifactRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.ArtifactChunk)
pub struct ArtifactChunk {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.ArtifactChunk.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.ArtifactChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactChunk {
    fn default() -> &'a ArtifactChunk {
        <ArtifactChunk as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactChunk {
    pub fn new() -> ArtifactChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ArtifactChunk| { &m.data },
            |m: &mut ArtifactChunk| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactChunk>(
            "ArtifactChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactChunk {
    const NAME: &'static str = "ArtifactChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactChunk {
        ArtifactChunk::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactChunk {
        static instance: ArtifactChunk = ArtifactChunk {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.PutArtifactMetadata)
pub struct PutArtifactMetadata {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.PutArtifactMetadata.staging_session_token)
    pub staging_session_token: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.PutArtifactMetadata.metadata)
    pub metadata: ::protobuf::MessageField<ArtifactMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.PutArtifactMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutArtifactMetadata {
    fn default() -> &'a PutArtifactMetadata {
        <PutArtifactMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PutArtifactMetadata {
    pub fn new() -> PutArtifactMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "staging_session_token",
            |m: &PutArtifactMetadata| { &m.staging_session_token },
            |m: &mut PutArtifactMetadata| { &mut m.staging_session_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArtifactMetadata>(
            "metadata",
            |m: &PutArtifactMetadata| { &m.metadata },
            |m: &mut PutArtifactMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutArtifactMetadata>(
            "PutArtifactMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutArtifactMetadata {
    const NAME: &'static str = "PutArtifactMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.staging_session_token = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.staging_session_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.staging_session_token);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.staging_session_token.is_empty() {
            os.write_string(1, &self.staging_session_token)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutArtifactMetadata {
        PutArtifactMetadata::new()
    }

    fn clear(&mut self) {
        self.staging_session_token.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutArtifactMetadata {
        static instance: PutArtifactMetadata = PutArtifactMetadata {
            staging_session_token: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutArtifactMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutArtifactMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutArtifactMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutArtifactMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.PutArtifactRequest)
pub struct PutArtifactRequest {
    // message oneof groups
    pub content: ::std::option::Option<put_artifact_request::Content>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.PutArtifactRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutArtifactRequest {
    fn default() -> &'a PutArtifactRequest {
        <PutArtifactRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutArtifactRequest {
    pub fn new() -> PutArtifactRequest {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.job_management.v1.PutArtifactMetadata metadata = 1;

    pub fn metadata(&self) -> &PutArtifactMetadata {
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Metadata(ref v)) => v,
            _ => <PutArtifactMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_metadata(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: PutArtifactMetadata) {
        self.content = ::std::option::Option::Some(put_artifact_request::Content::Metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut PutArtifactMetadata {
        if let ::std::option::Option::Some(put_artifact_request::Content::Metadata(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(put_artifact_request::Content::Metadata(PutArtifactMetadata::new()));
        }
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> PutArtifactMetadata {
        if self.has_metadata() {
            match self.content.take() {
                ::std::option::Option::Some(put_artifact_request::Content::Metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            PutArtifactMetadata::new()
        }
    }

    // .org.apache.beam.model.job_management.v1.ArtifactChunk data = 2;

    pub fn data(&self) -> &ArtifactChunk {
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Data(ref v)) => v,
            _ => <ArtifactChunk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_data(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ArtifactChunk) {
        self.content = ::std::option::Option::Some(put_artifact_request::Content::Data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ArtifactChunk {
        if let ::std::option::Option::Some(put_artifact_request::Content::Data(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(put_artifact_request::Content::Data(ArtifactChunk::new()));
        }
        match self.content {
            ::std::option::Option::Some(put_artifact_request::Content::Data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> ArtifactChunk {
        if self.has_data() {
            match self.content.take() {
                ::std::option::Option::Some(put_artifact_request::Content::Data(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtifactChunk::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PutArtifactMetadata>(
            "metadata",
            PutArtifactRequest::has_metadata,
            PutArtifactRequest::metadata,
            PutArtifactRequest::mut_metadata,
            PutArtifactRequest::set_metadata,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ArtifactChunk>(
            "data",
            PutArtifactRequest::has_data,
            PutArtifactRequest::data,
            PutArtifactRequest::mut_data,
            PutArtifactRequest::set_data,
        ));
        oneofs.push(put_artifact_request::Content::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutArtifactRequest>(
            "PutArtifactRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutArtifactRequest {
    const NAME: &'static str = "PutArtifactRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.content = ::std::option::Option::Some(put_artifact_request::Content::Metadata(is.read_message()?));
                },
                18 => {
                    self.content = ::std::option::Option::Some(put_artifact_request::Content::Data(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &put_artifact_request::Content::Metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &put_artifact_request::Content::Data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &put_artifact_request::Content::Metadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &put_artifact_request::Content::Data(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutArtifactRequest {
        PutArtifactRequest::new()
    }

    fn clear(&mut self) {
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutArtifactRequest {
        static instance: PutArtifactRequest = PutArtifactRequest {
            content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutArtifactRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutArtifactRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutArtifactRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutArtifactRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PutArtifactRequest`
pub mod put_artifact_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.job_management.v1.PutArtifactRequest.content)
    pub enum Content {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.PutArtifactRequest.metadata)
        Metadata(super::PutArtifactMetadata),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.job_management.v1.PutArtifactRequest.data)
        Data(super::ArtifactChunk),
    }

    impl ::protobuf::Oneof for Content {
    }

    impl ::protobuf::OneofFull for Content {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PutArtifactRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("content").unwrap()).clone()
        }
    }

    impl Content {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Content>("content")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.PutArtifactResponse)
pub struct PutArtifactResponse {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.PutArtifactResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutArtifactResponse {
    fn default() -> &'a PutArtifactResponse {
        <PutArtifactResponse as ::protobuf::Message>::default_instance()
    }
}

impl PutArtifactResponse {
    pub fn new() -> PutArtifactResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutArtifactResponse>(
            "PutArtifactResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutArtifactResponse {
    const NAME: &'static str = "PutArtifactResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutArtifactResponse {
        PutArtifactResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutArtifactResponse {
        static instance: PutArtifactResponse = PutArtifactResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutArtifactResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutArtifactResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutArtifactResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutArtifactResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.CommitManifestRequest)
pub struct CommitManifestRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.CommitManifestRequest.manifest)
    pub manifest: ::protobuf::MessageField<Manifest>,
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.CommitManifestRequest.staging_session_token)
    pub staging_session_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.CommitManifestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitManifestRequest {
    fn default() -> &'a CommitManifestRequest {
        <CommitManifestRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommitManifestRequest {
    pub fn new() -> CommitManifestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Manifest>(
            "manifest",
            |m: &CommitManifestRequest| { &m.manifest },
            |m: &mut CommitManifestRequest| { &mut m.manifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "staging_session_token",
            |m: &CommitManifestRequest| { &m.staging_session_token },
            |m: &mut CommitManifestRequest| { &mut m.staging_session_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitManifestRequest>(
            "CommitManifestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitManifestRequest {
    const NAME: &'static str = "CommitManifestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.manifest)?;
                },
                18 => {
                    self.staging_session_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.manifest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.staging_session_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.staging_session_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.manifest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.staging_session_token.is_empty() {
            os.write_string(2, &self.staging_session_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitManifestRequest {
        CommitManifestRequest::new()
    }

    fn clear(&mut self) {
        self.manifest.clear();
        self.staging_session_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitManifestRequest {
        static instance: CommitManifestRequest = CommitManifestRequest {
            manifest: ::protobuf::MessageField::none(),
            staging_session_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitManifestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitManifestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitManifestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitManifestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.job_management.v1.CommitManifestResponse)
pub struct CommitManifestResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.job_management.v1.CommitManifestResponse.retrieval_token)
    pub retrieval_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.job_management.v1.CommitManifestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitManifestResponse {
    fn default() -> &'a CommitManifestResponse {
        <CommitManifestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitManifestResponse {
    pub fn new() -> CommitManifestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retrieval_token",
            |m: &CommitManifestResponse| { &m.retrieval_token },
            |m: &mut CommitManifestResponse| { &mut m.retrieval_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitManifestResponse>(
            "CommitManifestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitManifestResponse {
    const NAME: &'static str = "CommitManifestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.retrieval_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.retrieval_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.retrieval_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.retrieval_token.is_empty() {
            os.write_string(1, &self.retrieval_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitManifestResponse {
        CommitManifestResponse::new()
    }

    fn clear(&mut self) {
        self.retrieval_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitManifestResponse {
        static instance: CommitManifestResponse = CommitManifestResponse {
            retrieval_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitManifestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitManifestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitManifestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitManifestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CommitManifestResponse`
pub mod commit_manifest_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.job_management.v1.CommitManifestResponse.Constants)
    pub enum Constants {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.job_management.v1.CommitManifestResponse.Constants.NO_ARTIFACTS_STAGED_TOKEN)
        NO_ARTIFACTS_STAGED_TOKEN = 0,
    }

    impl ::protobuf::Enum for Constants {
        const NAME: &'static str = "Constants";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Constants> {
            match value {
                0 => ::std::option::Option::Some(Constants::NO_ARTIFACTS_STAGED_TOKEN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Constants] = &[
            Constants::NO_ARTIFACTS_STAGED_TOKEN,
        ];
    }

    impl ::protobuf::EnumFull for Constants {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CommitManifestResponse.Constants").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Constants {
        fn default() -> Self {
            Constants::NO_ARTIFACTS_STAGED_TOKEN
        }
    }

    impl Constants {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Constants>("CommitManifestResponse.Constants")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n?org/apache/beam/model/job_management/v1/beam_artifact_api.proto\x12'o\
    rg.apache.beam.model.job_management.v1\x1a7org/apache/beam/model/pipelin\
    e/v1/beam_runner_api.proto\"\x96\x01\n\x17ResolveArtifactsRequest\x12T\n\
    \tartifacts\x18\x01\x20\x03(\x0b26.org.apache.beam.model.pipeline.v1.Art\
    ifactInformationR\tartifacts\x12%\n\x0epreferred_urns\x18\x02\x20\x03(\t\
    R\rpreferredUrns\"v\n\x18ResolveArtifactsResponse\x12Z\n\x0creplacements\
    \x18\x01\x20\x03(\x0b26.org.apache.beam.model.pipeline.v1.ArtifactInform\
    ationR\x0creplacements\"h\n\x12GetArtifactRequest\x12R\n\x08artifact\x18\
    \x01\x20\x01(\x0b26.org.apache.beam.model.pipeline.v1.ArtifactInformatio\
    nR\x08artifact\")\n\x13GetArtifactResponse\x12\x12\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04data\"\xf6\x01\n\x16ArtifactRequestWrapper\x12n\n\x10resol\
    ve_artifact\x18\xe8\x07\x20\x01(\x0b2@.org.apache.beam.model.job_managem\
    ent.v1.ResolveArtifactsRequestH\0R\x0fresolveArtifact\x12a\n\x0cget_arti\
    fact\x18\xe9\x07\x20\x01(\x0b2;.org.apache.beam.model.job_management.v1.\
    GetArtifactRequestH\0R\x0bgetArtifactB\t\n\x07request\"\xdb\x02\n\x17Art\
    ifactResponseWrapper\x12#\n\rstaging_token\x18\x01\x20\x01(\tR\x0cstagin\
    gToken\x12\x17\n\x07is_last\x18\x02\x20\x01(\x08R\x06isLast\x12\x80\x01\
    \n\x19resolve_artifact_response\x18\xe8\x07\x20\x01(\x0b2A.org.apache.be\
    am.model.job_management.v1.ResolveArtifactsResponseH\0R\x17resolveArtifa\
    ctResponse\x12s\n\x15get_artifact_response\x18\xe9\x07\x20\x01(\x0b2<.or\
    g.apache.beam.model.job_management.v1.GetArtifactResponseH\0R\x13getArti\
    factResponseB\n\n\x08response\"`\n\x10ArtifactMetadata\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bpermissions\x18\x02\x20\x01(\r\
    R\x0bpermissions\x12\x16\n\x06sha256\x18\x04\x20\x01(\tR\x06sha256\"a\n\
    \x08Manifest\x12U\n\x08artifact\x18\x01\x20\x03(\x0b29.org.apache.beam.m\
    odel.job_management.v1.ArtifactMetadataR\x08artifact\"\xed\x01\n\rProxyM\
    anifest\x12M\n\x08manifest\x18\x01\x20\x01(\x0b21.org.apache.beam.model.\
    job_management.v1.ManifestR\x08manifest\x12[\n\x08location\x18\x02\x20\
    \x03(\x0b2?.org.apache.beam.model.job_management.v1.ProxyManifest.Locati\
    onR\x08location\x1a0\n\x08Location\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x10\n\x03uri\x18\x02\x20\x01(\tR\x03uri\"=\n\x12GetManifest\
    Request\x12'\n\x0fretrieval_token\x18\x01\x20\x01(\tR\x0eretrievalToken\
    \"d\n\x13GetManifestResponse\x12M\n\x08manifest\x18\x01\x20\x01(\x0b21.o\
    rg.apache.beam.model.job_management.v1.ManifestR\x08manifest\"W\n\x18Leg\
    acyGetArtifactRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12'\
    \n\x0fretrieval_token\x18\x02\x20\x01(\tR\x0eretrievalToken\"#\n\rArtifa\
    ctChunk\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"\xa0\x01\n\x13P\
    utArtifactMetadata\x122\n\x15staging_session_token\x18\x01\x20\x01(\tR\
    \x13stagingSessionToken\x12U\n\x08metadata\x18\x02\x20\x01(\x0b29.org.ap\
    ache.beam.model.job_management.v1.ArtifactMetadataR\x08metadata\"\xc9\
    \x01\n\x12PutArtifactRequest\x12Z\n\x08metadata\x18\x01\x20\x01(\x0b2<.o\
    rg.apache.beam.model.job_management.v1.PutArtifactMetadataH\0R\x08metada\
    ta\x12L\n\x04data\x18\x02\x20\x01(\x0b26.org.apache.beam.model.job_manag\
    ement.v1.ArtifactChunkH\0R\x04dataB\t\n\x07content\"\x15\n\x13PutArtifac\
    tResponse\"\x9a\x01\n\x15CommitManifestRequest\x12M\n\x08manifest\x18\
    \x01\x20\x01(\x0b21.org.apache.beam.model.job_management.v1.ManifestR\
    \x08manifest\x122\n\x15staging_session_token\x18\x02\x20\x01(\tR\x13stag\
    ingSessionToken\"\x8c\x01\n\x16CommitManifestResponse\x12'\n\x0fretrieva\
    l_token\x18\x01\x20\x01(\tR\x0eretrievalToken\"I\n\tConstants\x12<\n\x19\
    NO_ARTIFACTS_STAGED_TOKEN\x10\0\x1a\x1d\xaa\xb4\xfa\xc2\x05\x17__no_arti\
    facts_staged__2\xc1\x02\n\x18ArtifactRetrievalService\x12\x97\x01\n\x10R\
    esolveArtifacts\x12@.org.apache.beam.model.job_management.v1.ResolveArti\
    factsRequest\x1aA.org.apache.beam.model.job_management.v1.ResolveArtifac\
    tsResponse\x12\x8a\x01\n\x0bGetArtifact\x12;.org.apache.beam.model.job_m\
    anagement.v1.GetArtifactRequest\x1a<.org.apache.beam.model.job_managemen\
    t.v1.GetArtifactResponse0\x012\xc3\x01\n\x16ArtifactStagingService\x12\
    \xa8\x01\n\x1fReverseArtifactRetrievalService\x12@.org.apache.beam.model\
    .job_management.v1.ArtifactResponseWrapper\x1a?.org.apache.beam.model.jo\
    b_management.v1.ArtifactRequestWrapper(\x010\x012\xbf\x02\n\x1cLegacyArt\
    ifactStagingService\x12\x8a\x01\n\x0bPutArtifact\x12;.org.apache.beam.mo\
    del.job_management.v1.PutArtifactRequest\x1a<.org.apache.beam.model.job_\
    management.v1.PutArtifactResponse(\x01\x12\x91\x01\n\x0eCommitManifest\
    \x12>.org.apache.beam.model.job_management.v1.CommitManifestRequest\x1a?\
    .org.apache.beam.model.job_management.v1.CommitManifestResponse2\xb8\x02\
    \n\x1eLegacyArtifactRetrievalService\x12\x88\x01\n\x0bGetManifest\x12;.o\
    rg.apache.beam.model.job_management.v1.GetManifestRequest\x1a<.org.apach\
    e.beam.model.job_management.v1.GetManifestResponse\x12\x8a\x01\n\x0bGetA\
    rtifact\x12A.org.apache.beam.model.job_management.v1.LegacyGetArtifactRe\
    quest\x1a6.org.apache.beam.model.job_management.v1.ArtifactChunk0\x01B\
    \x89\x01\n&org.apache.beam.model.jobmanagement.v1B\x0bArtifactApiZRgithu\
    b.com/apache/beam/sdks/v2/go/pkg/beam/model/jobmanagement_v1;jobmanageme\
    nt_v1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::beam_runner_api::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(ResolveArtifactsRequest::generated_message_descriptor_data());
            messages.push(ResolveArtifactsResponse::generated_message_descriptor_data());
            messages.push(GetArtifactRequest::generated_message_descriptor_data());
            messages.push(GetArtifactResponse::generated_message_descriptor_data());
            messages.push(ArtifactRequestWrapper::generated_message_descriptor_data());
            messages.push(ArtifactResponseWrapper::generated_message_descriptor_data());
            messages.push(ArtifactMetadata::generated_message_descriptor_data());
            messages.push(Manifest::generated_message_descriptor_data());
            messages.push(ProxyManifest::generated_message_descriptor_data());
            messages.push(GetManifestRequest::generated_message_descriptor_data());
            messages.push(GetManifestResponse::generated_message_descriptor_data());
            messages.push(LegacyGetArtifactRequest::generated_message_descriptor_data());
            messages.push(ArtifactChunk::generated_message_descriptor_data());
            messages.push(PutArtifactMetadata::generated_message_descriptor_data());
            messages.push(PutArtifactRequest::generated_message_descriptor_data());
            messages.push(PutArtifactResponse::generated_message_descriptor_data());
            messages.push(CommitManifestRequest::generated_message_descriptor_data());
            messages.push(CommitManifestResponse::generated_message_descriptor_data());
            messages.push(proxy_manifest::Location::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(commit_manifest_response::Constants::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
