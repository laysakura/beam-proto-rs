// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.21.5
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `org/apache/beam/model/pipeline/v1/metrics.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec)
pub struct MonitoringInfoSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec.urn)
    pub urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec.required_labels)
    pub required_labels: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec.annotations)
    pub annotations: ::std::vec::Vec<Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfoSpec {
    fn default() -> &'a MonitoringInfoSpec {
        <MonitoringInfoSpec as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfoSpec {
    pub fn new() -> MonitoringInfoSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "urn",
            |m: &MonitoringInfoSpec| { &m.urn },
            |m: &mut MonitoringInfoSpec| { &mut m.urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MonitoringInfoSpec| { &m.type_ },
            |m: &mut MonitoringInfoSpec| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_labels",
            |m: &MonitoringInfoSpec| { &m.required_labels },
            |m: &mut MonitoringInfoSpec| { &mut m.required_labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &MonitoringInfoSpec| { &m.annotations },
            |m: &mut MonitoringInfoSpec| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfoSpec>(
            "MonitoringInfoSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfoSpec {
    const NAME: &'static str = "MonitoringInfoSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.urn = is.read_string()?;
                },
                18 => {
                    self.type_ = is.read_string()?;
                },
                26 => {
                    self.required_labels.push(is.read_string()?);
                },
                34 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.urn.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.urn);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_);
        }
        for value in &self.required_labels {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.urn.is_empty() {
            os.write_string(1, &self.urn)?;
        }
        if !self.type_.is_empty() {
            os.write_string(2, &self.type_)?;
        }
        for v in &self.required_labels {
            os.write_string(3, &v)?;
        };
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfoSpec {
        MonitoringInfoSpec::new()
    }

    fn clear(&mut self) {
        self.urn.clear();
        self.type_.clear();
        self.required_labels.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfoSpec {
        static instance: MonitoringInfoSpec = MonitoringInfoSpec {
            urn: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            required_labels: ::std::vec::Vec::new(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitoringInfoSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfoSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfoSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfoSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Annotation)
pub struct Annotation {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Annotation.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Annotation.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Annotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Annotation {
    fn default() -> &'a Annotation {
        <Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Annotation| { &m.key },
            |m: &mut Annotation| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Annotation| { &m.value },
            |m: &mut Annotation| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Annotation>(
            "Annotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Annotation {
    const NAME: &'static str = "Annotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Annotation {
        static instance: Annotation = Annotation {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Annotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Annotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs)
pub struct MonitoringInfoSpecs {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfoSpecs {
    fn default() -> &'a MonitoringInfoSpecs {
        <MonitoringInfoSpecs as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfoSpecs {
    pub fn new() -> MonitoringInfoSpecs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfoSpecs>(
            "MonitoringInfoSpecs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfoSpecs {
    const NAME: &'static str = "MonitoringInfoSpecs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfoSpecs {
        MonitoringInfoSpecs::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfoSpecs {
        static instance: MonitoringInfoSpecs = MonitoringInfoSpecs {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitoringInfoSpecs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfoSpecs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfoSpecs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfoSpecs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MonitoringInfoSpecs`
pub mod monitoring_info_specs {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_SUM_INT64)
        USER_SUM_INT64 = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_SUM_DOUBLE)
        USER_SUM_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_DISTRIBUTION_INT64)
        USER_DISTRIBUTION_INT64 = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_DISTRIBUTION_DOUBLE)
        USER_DISTRIBUTION_DOUBLE = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_LATEST_INT64)
        USER_LATEST_INT64 = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_LATEST_DOUBLE)
        USER_LATEST_DOUBLE = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_TOP_N_INT64)
        USER_TOP_N_INT64 = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_TOP_N_DOUBLE)
        USER_TOP_N_DOUBLE = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_BOTTOM_N_INT64)
        USER_BOTTOM_N_INT64 = 8,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.USER_BOTTOM_N_DOUBLE)
        USER_BOTTOM_N_DOUBLE = 9,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.ELEMENT_COUNT)
        ELEMENT_COUNT = 10,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.SAMPLED_BYTE_SIZE)
        SAMPLED_BYTE_SIZE = 11,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.START_BUNDLE_MSECS)
        START_BUNDLE_MSECS = 12,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.PROCESS_BUNDLE_MSECS)
        PROCESS_BUNDLE_MSECS = 13,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.FINISH_BUNDLE_MSECS)
        FINISH_BUNDLE_MSECS = 14,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.TOTAL_MSECS)
        TOTAL_MSECS = 15,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.WORK_REMAINING)
        WORK_REMAINING = 16,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.WORK_COMPLETED)
        WORK_COMPLETED = 17,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.DATA_CHANNEL_READ_INDEX)
        DATA_CHANNEL_READ_INDEX = 18,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.API_REQUEST_COUNT)
        API_REQUEST_COUNT = 19,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoSpecs.Enum.API_REQUEST_LATENCIES)
        API_REQUEST_LATENCIES = 20,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::USER_SUM_INT64),
                1 => ::std::option::Option::Some(Enum::USER_SUM_DOUBLE),
                2 => ::std::option::Option::Some(Enum::USER_DISTRIBUTION_INT64),
                3 => ::std::option::Option::Some(Enum::USER_DISTRIBUTION_DOUBLE),
                4 => ::std::option::Option::Some(Enum::USER_LATEST_INT64),
                5 => ::std::option::Option::Some(Enum::USER_LATEST_DOUBLE),
                6 => ::std::option::Option::Some(Enum::USER_TOP_N_INT64),
                7 => ::std::option::Option::Some(Enum::USER_TOP_N_DOUBLE),
                8 => ::std::option::Option::Some(Enum::USER_BOTTOM_N_INT64),
                9 => ::std::option::Option::Some(Enum::USER_BOTTOM_N_DOUBLE),
                10 => ::std::option::Option::Some(Enum::ELEMENT_COUNT),
                11 => ::std::option::Option::Some(Enum::SAMPLED_BYTE_SIZE),
                12 => ::std::option::Option::Some(Enum::START_BUNDLE_MSECS),
                13 => ::std::option::Option::Some(Enum::PROCESS_BUNDLE_MSECS),
                14 => ::std::option::Option::Some(Enum::FINISH_BUNDLE_MSECS),
                15 => ::std::option::Option::Some(Enum::TOTAL_MSECS),
                16 => ::std::option::Option::Some(Enum::WORK_REMAINING),
                17 => ::std::option::Option::Some(Enum::WORK_COMPLETED),
                18 => ::std::option::Option::Some(Enum::DATA_CHANNEL_READ_INDEX),
                19 => ::std::option::Option::Some(Enum::API_REQUEST_COUNT),
                20 => ::std::option::Option::Some(Enum::API_REQUEST_LATENCIES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::USER_SUM_INT64,
            Enum::USER_SUM_DOUBLE,
            Enum::USER_DISTRIBUTION_INT64,
            Enum::USER_DISTRIBUTION_DOUBLE,
            Enum::USER_LATEST_INT64,
            Enum::USER_LATEST_DOUBLE,
            Enum::USER_TOP_N_INT64,
            Enum::USER_TOP_N_DOUBLE,
            Enum::USER_BOTTOM_N_INT64,
            Enum::USER_BOTTOM_N_DOUBLE,
            Enum::ELEMENT_COUNT,
            Enum::SAMPLED_BYTE_SIZE,
            Enum::START_BUNDLE_MSECS,
            Enum::PROCESS_BUNDLE_MSECS,
            Enum::FINISH_BUNDLE_MSECS,
            Enum::TOTAL_MSECS,
            Enum::WORK_REMAINING,
            Enum::WORK_COMPLETED,
            Enum::DATA_CHANNEL_READ_INDEX,
            Enum::API_REQUEST_COUNT,
            Enum::API_REQUEST_LATENCIES,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MonitoringInfoSpecs.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::USER_SUM_INT64
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("MonitoringInfoSpecs.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MonitoringInfoLabelProps)
pub struct MonitoringInfoLabelProps {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfoLabelProps.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MonitoringInfoLabelProps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfoLabelProps {
    fn default() -> &'a MonitoringInfoLabelProps {
        <MonitoringInfoLabelProps as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfoLabelProps {
    pub fn new() -> MonitoringInfoLabelProps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MonitoringInfoLabelProps| { &m.name },
            |m: &mut MonitoringInfoLabelProps| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfoLabelProps>(
            "MonitoringInfoLabelProps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfoLabelProps {
    const NAME: &'static str = "MonitoringInfoLabelProps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfoLabelProps {
        MonitoringInfoLabelProps::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfoLabelProps {
        static instance: MonitoringInfoLabelProps = MonitoringInfoLabelProps {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitoringInfoLabelProps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfoLabelProps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfoLabelProps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfoLabelProps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MonitoringInfo)
pub struct MonitoringInfo {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfo.urn)
    pub urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfo.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfo.payload)
    pub payload: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfo.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MonitoringInfo.start_time)
    pub start_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MonitoringInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfo {
    fn default() -> &'a MonitoringInfo {
        <MonitoringInfo as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfo {
    pub fn new() -> MonitoringInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "urn",
            |m: &MonitoringInfo| { &m.urn },
            |m: &mut MonitoringInfo| { &mut m.urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MonitoringInfo| { &m.type_ },
            |m: &mut MonitoringInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &MonitoringInfo| { &m.payload },
            |m: &mut MonitoringInfo| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &MonitoringInfo| { &m.labels },
            |m: &mut MonitoringInfo| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "start_time",
            |m: &MonitoringInfo| { &m.start_time },
            |m: &mut MonitoringInfo| { &mut m.start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfo>(
            "MonitoringInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfo {
    const NAME: &'static str = "MonitoringInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.urn = is.read_string()?;
                },
                18 => {
                    self.type_ = is.read_string()?;
                },
                26 => {
                    self.payload = is.read_bytes()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.urn.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.urn);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.urn.is_empty() {
            os.write_string(1, &self.urn)?;
        }
        if !self.type_.is_empty() {
            os.write_string(2, &self.type_)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfo {
        MonitoringInfo::new()
    }

    fn clear(&mut self) {
        self.urn.clear();
        self.type_.clear();
        self.payload.clear();
        self.labels.clear();
        self.start_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfo {
        static instance: ::protobuf::rt::Lazy<MonitoringInfo> = ::protobuf::rt::Lazy::new();
        instance.get(MonitoringInfo::new)
    }
}

impl ::protobuf::MessageFull for MonitoringInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MonitoringInfo`
pub mod monitoring_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels)
    pub enum MonitoringInfoLabels {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.TRANSFORM)
        TRANSFORM = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.PCOLLECTION)
        PCOLLECTION = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.WINDOWING_STRATEGY)
        WINDOWING_STRATEGY = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.CODER)
        CODER = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.ENVIRONMENT)
        ENVIRONMENT = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.NAMESPACE)
        NAMESPACE = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.NAME)
        NAME = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SERVICE)
        SERVICE = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.METHOD)
        METHOD = 8,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.RESOURCE)
        RESOURCE = 9,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.STATUS)
        STATUS = 10,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGQUERY_PROJECT_ID)
        BIGQUERY_PROJECT_ID = 11,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGQUERY_DATASET)
        BIGQUERY_DATASET = 12,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGQUERY_TABLE)
        BIGQUERY_TABLE = 13,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGQUERY_VIEW)
        BIGQUERY_VIEW = 14,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGQUERY_QUERY_NAME)
        BIGQUERY_QUERY_NAME = 15,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.GCS_BUCKET)
        GCS_BUCKET = 16,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.GCS_PROJECT_ID)
        GCS_PROJECT_ID = 17,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.DATASTORE_PROJECT)
        DATASTORE_PROJECT = 18,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.DATASTORE_NAMESPACE)
        DATASTORE_NAMESPACE = 19,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.BIGTABLE_PROJECT_ID)
        BIGTABLE_PROJECT_ID = 20,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.INSTANCE_ID)
        INSTANCE_ID = 21,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.TABLE_ID)
        TABLE_ID = 22,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SPANNER_PROJECT_ID)
        SPANNER_PROJECT_ID = 23,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SPANNER_DATABASE_ID)
        SPANNER_DATABASE_ID = 24,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SPANNER_TABLE_ID)
        SPANNER_TABLE_ID = 25,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SPANNER_INSTANCE_ID)
        SPANNER_INSTANCE_ID = 26,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfo.MonitoringInfoLabels.SPANNER_QUERY_NAME)
        SPANNER_QUERY_NAME = 27,
    }

    impl ::protobuf::Enum for MonitoringInfoLabels {
        const NAME: &'static str = "MonitoringInfoLabels";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MonitoringInfoLabels> {
            match value {
                0 => ::std::option::Option::Some(MonitoringInfoLabels::TRANSFORM),
                1 => ::std::option::Option::Some(MonitoringInfoLabels::PCOLLECTION),
                2 => ::std::option::Option::Some(MonitoringInfoLabels::WINDOWING_STRATEGY),
                3 => ::std::option::Option::Some(MonitoringInfoLabels::CODER),
                4 => ::std::option::Option::Some(MonitoringInfoLabels::ENVIRONMENT),
                5 => ::std::option::Option::Some(MonitoringInfoLabels::NAMESPACE),
                6 => ::std::option::Option::Some(MonitoringInfoLabels::NAME),
                7 => ::std::option::Option::Some(MonitoringInfoLabels::SERVICE),
                8 => ::std::option::Option::Some(MonitoringInfoLabels::METHOD),
                9 => ::std::option::Option::Some(MonitoringInfoLabels::RESOURCE),
                10 => ::std::option::Option::Some(MonitoringInfoLabels::STATUS),
                11 => ::std::option::Option::Some(MonitoringInfoLabels::BIGQUERY_PROJECT_ID),
                12 => ::std::option::Option::Some(MonitoringInfoLabels::BIGQUERY_DATASET),
                13 => ::std::option::Option::Some(MonitoringInfoLabels::BIGQUERY_TABLE),
                14 => ::std::option::Option::Some(MonitoringInfoLabels::BIGQUERY_VIEW),
                15 => ::std::option::Option::Some(MonitoringInfoLabels::BIGQUERY_QUERY_NAME),
                16 => ::std::option::Option::Some(MonitoringInfoLabels::GCS_BUCKET),
                17 => ::std::option::Option::Some(MonitoringInfoLabels::GCS_PROJECT_ID),
                18 => ::std::option::Option::Some(MonitoringInfoLabels::DATASTORE_PROJECT),
                19 => ::std::option::Option::Some(MonitoringInfoLabels::DATASTORE_NAMESPACE),
                20 => ::std::option::Option::Some(MonitoringInfoLabels::BIGTABLE_PROJECT_ID),
                21 => ::std::option::Option::Some(MonitoringInfoLabels::INSTANCE_ID),
                22 => ::std::option::Option::Some(MonitoringInfoLabels::TABLE_ID),
                23 => ::std::option::Option::Some(MonitoringInfoLabels::SPANNER_PROJECT_ID),
                24 => ::std::option::Option::Some(MonitoringInfoLabels::SPANNER_DATABASE_ID),
                25 => ::std::option::Option::Some(MonitoringInfoLabels::SPANNER_TABLE_ID),
                26 => ::std::option::Option::Some(MonitoringInfoLabels::SPANNER_INSTANCE_ID),
                27 => ::std::option::Option::Some(MonitoringInfoLabels::SPANNER_QUERY_NAME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MonitoringInfoLabels] = &[
            MonitoringInfoLabels::TRANSFORM,
            MonitoringInfoLabels::PCOLLECTION,
            MonitoringInfoLabels::WINDOWING_STRATEGY,
            MonitoringInfoLabels::CODER,
            MonitoringInfoLabels::ENVIRONMENT,
            MonitoringInfoLabels::NAMESPACE,
            MonitoringInfoLabels::NAME,
            MonitoringInfoLabels::SERVICE,
            MonitoringInfoLabels::METHOD,
            MonitoringInfoLabels::RESOURCE,
            MonitoringInfoLabels::STATUS,
            MonitoringInfoLabels::BIGQUERY_PROJECT_ID,
            MonitoringInfoLabels::BIGQUERY_DATASET,
            MonitoringInfoLabels::BIGQUERY_TABLE,
            MonitoringInfoLabels::BIGQUERY_VIEW,
            MonitoringInfoLabels::BIGQUERY_QUERY_NAME,
            MonitoringInfoLabels::GCS_BUCKET,
            MonitoringInfoLabels::GCS_PROJECT_ID,
            MonitoringInfoLabels::DATASTORE_PROJECT,
            MonitoringInfoLabels::DATASTORE_NAMESPACE,
            MonitoringInfoLabels::BIGTABLE_PROJECT_ID,
            MonitoringInfoLabels::INSTANCE_ID,
            MonitoringInfoLabels::TABLE_ID,
            MonitoringInfoLabels::SPANNER_PROJECT_ID,
            MonitoringInfoLabels::SPANNER_DATABASE_ID,
            MonitoringInfoLabels::SPANNER_TABLE_ID,
            MonitoringInfoLabels::SPANNER_INSTANCE_ID,
            MonitoringInfoLabels::SPANNER_QUERY_NAME,
        ];
    }

    impl ::protobuf::EnumFull for MonitoringInfoLabels {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MonitoringInfo.MonitoringInfoLabels").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MonitoringInfoLabels {
        fn default() -> Self {
            MonitoringInfoLabels::TRANSFORM
        }
    }

    impl MonitoringInfoLabels {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MonitoringInfoLabels>("MonitoringInfo.MonitoringInfoLabels")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns)
pub struct MonitoringInfoTypeUrns {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfoTypeUrns {
    fn default() -> &'a MonitoringInfoTypeUrns {
        <MonitoringInfoTypeUrns as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfoTypeUrns {
    pub fn new() -> MonitoringInfoTypeUrns {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfoTypeUrns>(
            "MonitoringInfoTypeUrns",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfoTypeUrns {
    const NAME: &'static str = "MonitoringInfoTypeUrns";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfoTypeUrns {
        MonitoringInfoTypeUrns::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfoTypeUrns {
        static instance: MonitoringInfoTypeUrns = MonitoringInfoTypeUrns {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitoringInfoTypeUrns {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfoTypeUrns").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfoTypeUrns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfoTypeUrns {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MonitoringInfoTypeUrns`
pub mod monitoring_info_type_urns {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.SUM_INT64_TYPE)
        SUM_INT64_TYPE = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.SUM_DOUBLE_TYPE)
        SUM_DOUBLE_TYPE = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.DISTRIBUTION_INT64_TYPE)
        DISTRIBUTION_INT64_TYPE = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.DISTRIBUTION_DOUBLE_TYPE)
        DISTRIBUTION_DOUBLE_TYPE = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.LATEST_INT64_TYPE)
        LATEST_INT64_TYPE = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.LATEST_DOUBLE_TYPE)
        LATEST_DOUBLE_TYPE = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.TOP_N_INT64_TYPE)
        TOP_N_INT64_TYPE = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.TOP_N_DOUBLE_TYPE)
        TOP_N_DOUBLE_TYPE = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.BOTTOM_N_INT64_TYPE)
        BOTTOM_N_INT64_TYPE = 8,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.BOTTOM_N_DOUBLE_TYPE)
        BOTTOM_N_DOUBLE_TYPE = 9,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MonitoringInfoTypeUrns.Enum.PROGRESS_TYPE)
        PROGRESS_TYPE = 10,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::SUM_INT64_TYPE),
                1 => ::std::option::Option::Some(Enum::SUM_DOUBLE_TYPE),
                2 => ::std::option::Option::Some(Enum::DISTRIBUTION_INT64_TYPE),
                3 => ::std::option::Option::Some(Enum::DISTRIBUTION_DOUBLE_TYPE),
                4 => ::std::option::Option::Some(Enum::LATEST_INT64_TYPE),
                5 => ::std::option::Option::Some(Enum::LATEST_DOUBLE_TYPE),
                6 => ::std::option::Option::Some(Enum::TOP_N_INT64_TYPE),
                7 => ::std::option::Option::Some(Enum::TOP_N_DOUBLE_TYPE),
                8 => ::std::option::Option::Some(Enum::BOTTOM_N_INT64_TYPE),
                9 => ::std::option::Option::Some(Enum::BOTTOM_N_DOUBLE_TYPE),
                10 => ::std::option::Option::Some(Enum::PROGRESS_TYPE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::SUM_INT64_TYPE,
            Enum::SUM_DOUBLE_TYPE,
            Enum::DISTRIBUTION_INT64_TYPE,
            Enum::DISTRIBUTION_DOUBLE_TYPE,
            Enum::LATEST_INT64_TYPE,
            Enum::LATEST_DOUBLE_TYPE,
            Enum::TOP_N_INT64_TYPE,
            Enum::TOP_N_DOUBLE_TYPE,
            Enum::BOTTOM_N_INT64_TYPE,
            Enum::BOTTOM_N_DOUBLE_TYPE,
            Enum::PROGRESS_TYPE,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MonitoringInfoTypeUrns.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::SUM_INT64_TYPE
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("MonitoringInfoTypeUrns.Enum")
        }
    }
}

/// Extension fields
pub mod exts {

    pub const label_props: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, super::MonitoringInfoLabelProps> = ::protobuf::ext::ExtFieldOptional::new(127337796, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const monitoring_info_spec: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, super::MonitoringInfoSpec> = ::protobuf::ext::ExtFieldOptional::new(207174266, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/org/apache/beam/model/pipeline/v1/metrics.proto\x12!org.apache.beam.m\
    odel.pipeline.v1\x1a7org/apache/beam/model/pipeline/v1/beam_runner_api.p\
    roto\x1a\x20google/protobuf/descriptor.proto\x1a\x1fgoogle/protobuf/time\
    stamp.proto\"\xb4\x01\n\x12MonitoringInfoSpec\x12\x10\n\x03urn\x18\x01\
    \x20\x01(\tR\x03urn\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12'\n\
    \x0frequired_labels\x18\x03\x20\x03(\tR\x0erequiredLabels\x12O\n\x0banno\
    tations\x18\x04\x20\x03(\x0b2-.org.apache.beam.model.pipeline.v1.Annotat\
    ionR\x0bannotations\"4\n\nAnnotation\x12\x10\n\x03key\x18\x01\x20\x01(\t\
    R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xd1#\n\x13Mon\
    itoringInfoSpecs\"\xb9#\n\x04Enum\x12\xa7\x01\n\x0eUSER_SUM_INT64\x10\0\
    \x1a\x92\x01\xd2\xa7\xa7\x96\x06\x8b\x01\n\x1dbeam:metric:user:sum_int64\
    :v1\x12\x19beam:metrics:sum_int64:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\
    \x04NAME\"2\n\x0bdescription\x12#URN\x20utilized\x20to\x20report\x20user\
    \x20metric.\x12\xaa\x01\n\x0fUSER_SUM_DOUBLE\x10\x01\x1a\x94\x01\xd2\xa7\
    \xa7\x96\x06\x8d\x01\n\x1ebeam:metric:user:sum_double:v1\x12\x1abeam:met\
    rics:sum_double:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\x04NAME\"2\n\x0bde\
    scription\x12#URN\x20utilized\x20to\x20report\x20user\x20metric.\x12\xc2\
    \x01\n\x17USER_DISTRIBUTION_INT64\x10\x02\x1a\xa4\x01\xd2\xa7\xa7\x96\
    \x06\x9d\x01\n&beam:metric:user:distribution_int64:v1\x12\"beam:metrics:\
    distribution_int64:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\x04NAME\"2\n\
    \x0bdescription\x12#URN\x20utilized\x20to\x20report\x20user\x20metric.\
    \x12\xc5\x01\n\x18USER_DISTRIBUTION_DOUBLE\x10\x03\x1a\xa6\x01\xd2\xa7\
    \xa7\x96\x06\x9f\x01\n'beam:metric:user:distribution_double:v1\x12#beam:\
    metrics:distribution_double:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\x04NAM\
    E\"2\n\x0bdescription\x12#URN\x20utilized\x20to\x20report\x20user\x20met\
    ric.\x12\xb0\x01\n\x11USER_LATEST_INT64\x10\x04\x1a\x98\x01\xd2\xa7\xa7\
    \x96\x06\x91\x01\n\x20beam:metric:user:latest_int64:v1\x12\x1cbeam:metri\
    cs:latest_int64:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\x04NAME\"2\n\x0bde\
    scription\x12#URN\x20utilized\x20to\x20report\x20user\x20metric.\x12\xb3\
    \x01\n\x12USER_LATEST_DOUBLE\x10\x05\x1a\x9a\x01\xd2\xa7\xa7\x96\x06\x93\
    \x01\n!beam:metric:user:latest_double:v1\x12\x1dbeam:metrics:latest_doub\
    le:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\x1a\x04NAME\"2\n\x0bdescription\x12\
    #URN\x20utilized\x20to\x20report\x20user\x20metric.\x12\xad\x01\n\x10USE\
    R_TOP_N_INT64\x10\x06\x1a\x96\x01\xd2\xa7\xa7\x96\x06\x8f\x01\n\x1fbeam:\
    metric:user:top_n_int64:v1\x12\x1bbeam:metrics:top_n_int64:v1\x1a\nPTRAN\
    SFORM\x1a\tNAMESPACE\x1a\x04NAME\"2\n\x0bdescription\x12#URN\x20utilized\
    \x20to\x20report\x20user\x20metric.\x12\xb0\x01\n\x11USER_TOP_N_DOUBLE\
    \x10\x07\x1a\x98\x01\xd2\xa7\xa7\x96\x06\x91\x01\n\x20beam:metric:user:t\
    op_n_double:v1\x12\x1cbeam:metrics:top_n_double:v1\x1a\nPTRANSFORM\x1a\t\
    NAMESPACE\x1a\x04NAME\"2\n\x0bdescription\x12#URN\x20utilized\x20to\x20r\
    eport\x20user\x20metric.\x12\xb6\x01\n\x13USER_BOTTOM_N_INT64\x10\x08\
    \x1a\x9c\x01\xd2\xa7\xa7\x96\x06\x95\x01\n\"beam:metric:user:bottom_n_in\
    t64:v1\x12\x1ebeam:metrics:bottom_n_int64:v1\x1a\nPTRANSFORM\x1a\tNAMESP\
    ACE\x1a\x04NAME\"2\n\x0bdescription\x12#URN\x20utilized\x20to\x20report\
    \x20user\x20metric.\x12\xb9\x01\n\x14USER_BOTTOM_N_DOUBLE\x10\t\x1a\x9e\
    \x01\xd2\xa7\xa7\x96\x06\x97\x01\n#beam:metric:user:bottom_n_double:v1\
    \x12\x1fbeam:metrics:bottom_n_double:v1\x1a\nPTRANSFORM\x1a\tNAMESPACE\
    \x1a\x04NAME\"2\n\x0bdescription\x12#URN\x20utilized\x20to\x20report\x20\
    user\x20metric.\x12\xad\x01\n\rELEMENT_COUNT\x10\n\x1a\x99\x01\xd2\xa7\
    \xa7\x96\x06\x92\x01\n\x1cbeam:metric:element_count:v1\x12\x19beam:metri\
    cs:sum_int64:v1\x1a\x0bPCOLLECTION\"J\n\x0bdescription\x12;The\x20total\
    \x20elements\x20output\x20to\x20a\x20Pcollection\x20by\x20a\x20PTransfor\
    m.\x12\xcd\x02\n\x11SAMPLED_BYTE_SIZE\x10\x0b\x1a\xb5\x02\xd2\xa7\xa7\
    \x96\x06\xae\x02\n\x20beam:metric:sampled_byte_size:v1\x12\"beam:metrics\
    :distribution_int64:v1\x1a\x0bPCOLLECTION\"\xd8\x01\n\x0bdescription\x12\
    \xc8\x01The\x20total\x20byte\x20size\x20and\x20count\x20of\x20a\x20sampl\
    ed\x20\x20set\x20(or\x20all)\x20of\x20elements\x20in\x20the\x20pcollecti\
    on.\x20Sampling\x20is\x20used\x20\x20because\x20calculating\x20the\x20by\
    te\x20count\x20involves\x20serializing\x20the\x20\x20elements\x20which\
    \x20is\x20CPU\x20intensive.\x12\xd9\x01\n\x12START_BUNDLE_MSECS\x10\x0c\
    \x1a\xc0\x01\xd2\xa7\xa7\x96\x06\xb9\x01\n6beam:metric:pardo_execution_t\
    ime:start_bundle_msecs:v1\x12\x19beam:metrics:sum_int64:v1\x1a\nPTRANSFO\
    RM\"X\n\x0bdescription\x12IThe\x20total\x20estimated\x20execution\x20tim\
    e\x20of\x20the\x20start\x20bundlefunction\x20in\x20a\x20pardo\x12\xdf\
    \x01\n\x14PROCESS_BUNDLE_MSECS\x10\r\x1a\xc4\x01\xd2\xa7\xa7\x96\x06\xbd\
    \x01\n8beam:metric:pardo_execution_time:process_bundle_msecs:v1\x12\x19b\
    eam:metrics:sum_int64:v1\x1a\nPTRANSFORM\"Z\n\x0bdescription\x12KThe\x20\
    total\x20estimated\x20execution\x20time\x20of\x20the\x20process\x20bundl\
    efunction\x20in\x20a\x20pardo\x12\xdd\x01\n\x13FINISH_BUNDLE_MSECS\x10\
    \x0e\x1a\xc3\x01\xd2\xa7\xa7\x96\x06\xbc\x01\n7beam:metric:pardo_executi\
    on_time:finish_bundle_msecs:v1\x12\x19beam:metrics:sum_int64:v1\x1a\nPTR\
    ANSFORM\"Z\n\x0bdescription\x12KThe\x20total\x20estimated\x20execution\
    \x20time\x20of\x20the\x20finish\x20bundle\x20function\x20in\x20a\x20pard\
    o\x12\xbb\x01\n\x0bTOTAL_MSECS\x10\x0f\x1a\xa9\x01\xd2\xa7\xa7\x96\x06\
    \xa2\x01\n4beam:metric:ptransform_execution_time:total_msecs:v1\x12\x19b\
    eam:metrics:sum_int64:v1\x1a\nPTRANSFORM\"C\n\x0bdescription\x124The\x20\
    total\x20estimated\x20execution\x20time\x20of\x20the\x20ptransform\x12\
    \x9f\x02\n\x0eWORK_REMAINING\x10\x10\x1a\x8a\x02\xd2\xa7\xa7\x96\x06\x83\
    \x02\n,beam:metric:ptransform_progress:remaining:v1\x12\x18beam:metrics:\
    progress:v1\x1a\nPTRANSFORM\"\xac\x01\n\x0bdescription\x12\x9c\x01The\
    \x20remaining\x20amount\x20of\x20work\x20for\x20each\x20active\x20elemen\
    t.\x20Each\x20active\x20element\x20represents\x20an\x20independent\x20am\
    ount\x20of\x20work\x20not\x20shared\x20with\x20any\x20other\x20active\
    \x20element.\x12\x9f\x02\n\x0eWORK_COMPLETED\x10\x11\x1a\x8a\x02\xd2\xa7\
    \xa7\x96\x06\x83\x02\n,beam:metric:ptransform_progress:completed:v1\x12\
    \x18beam:metrics:progress:v1\x1a\nPTRANSFORM\"\xac\x01\n\x0bdescription\
    \x12\x9c\x01The\x20remaining\x20amount\x20of\x20work\x20for\x20each\x20a\
    ctive\x20element.\x20Each\x20active\x20element\x20represents\x20an\x20in\
    dependent\x20amount\x20of\x20work\x20not\x20shared\x20with\x20any\x20oth\
    er\x20active\x20element.\x12\xa8\x01\n\x17DATA_CHANNEL_READ_INDEX\x10\
    \x12\x1a\x8a\x01\xd2\xa7\xa7\x96\x06\x83\x01\n&beam:metric:data_channel:\
    read_index:v1\x12\x19beam:metrics:sum_int64:v1\x1a\nPTRANSFORM\"2\n\x0bd\
    escription\x12#The\x20read\x20index\x20of\x20the\x20data\x20channel.\x12\
    \x8a\x02\n\x11API_REQUEST_COUNT\x10\x13\x1a\xf2\x01\xd2\xa7\xa7\x96\x06\
    \xeb\x01\n#beam:metric:io:api_request_count:v1\x12\x19beam:metrics:sum_i\
    nt64:v1\x1a\x07SERVICE\x1a\x06METHOD\x1a\x08RESOURCE\x1a\nPTRANSFORM\x1a\
    \x06STATUS\"b\n\x0bdescription\x12SRequest\x20counts\x20with\x20status\
    \x20made\x20to\x20IO\x20service\x20APIs\x20to\x20batch\x20read\x20or\x20\
    write\x20elements.\"\x16\n\x0eprocess_metric\x12\x04true\x12\xb3\x02\n\
    \x15API_REQUEST_LATENCIES\x10\x14\x1a\x97\x02\xd2\xa7\xa7\x96\x06\x90\
    \x02\n'beam:metric:io:api_request_latencies:v1\x12\x1fbeam:metrics:histo\
    gram_int64:v1\x1a\x07SERVICE\x1a\x06METHOD\x1a\x08RESOURCE\x1a\nPTRANSFO\
    RM\"n\n\x0bdescription\x12_Histogram\x20counts\x20for\x20request\x20late\
    ncies\x20made\x20to\x20IO\x20service\x20APIs\x20to\x20batch\x20read\x20o\
    r\x20write\x20elements.\"\x15\n\x05units\x12\x0cMilliseconds\"\x16\n\x0e\
    process_metric\x12\x04true\".\n\x18MonitoringInfoLabelProps\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\"\xcd\x0b\n\x0eMonitoringInfo\x12\
    \x10\n\x03urn\x18\x01\x20\x01(\tR\x03urn\x12\x12\n\x04type\x18\x02\x20\
    \x01(\tR\x04type\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\
    \x12U\n\x06labels\x18\x04\x20\x03(\x0b2=.org.apache.beam.model.pipeline.\
    v1.MonitoringInfo.LabelsEntryR\x06labels\x129\n\nstart_time\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x1a9\n\x0bLabelsEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\xad\t\n\x14MonitoringInfoLabels\
    \x12!\n\tTRANSFORM\x10\0\x1a\x12\xa2\xd4\xe0\xe5\x03\x0c\n\nPTRANSFORM\
    \x12$\n\x0bPCOLLECTION\x10\x01\x1a\x13\xa2\xd4\xe0\xe5\x03\r\n\x0bPCOLLE\
    CTION\x122\n\x12WINDOWING_STRATEGY\x10\x02\x1a\x1a\xa2\xd4\xe0\xe5\x03\
    \x14\n\x12WINDOWING_STRATEGY\x12\x18\n\x05CODER\x10\x03\x1a\r\xa2\xd4\
    \xe0\xe5\x03\x07\n\x05CODER\x12$\n\x0bENVIRONMENT\x10\x04\x1a\x13\xa2\
    \xd4\xe0\xe5\x03\r\n\x0bENVIRONMENT\x12\x20\n\tNAMESPACE\x10\x05\x1a\x11\
    \xa2\xd4\xe0\xe5\x03\x0b\n\tNAMESPACE\x12\x16\n\x04NAME\x10\x06\x1a\x0c\
    \xa2\xd4\xe0\xe5\x03\x06\n\x04NAME\x12\x1c\n\x07SERVICE\x10\x07\x1a\x0f\
    \xa2\xd4\xe0\xe5\x03\t\n\x07SERVICE\x12\x1a\n\x06METHOD\x10\x08\x1a\x0e\
    \xa2\xd4\xe0\xe5\x03\x08\n\x06METHOD\x12\x1e\n\x08RESOURCE\x10\t\x1a\x10\
    \xa2\xd4\xe0\xe5\x03\n\n\x08RESOURCE\x12\x1a\n\x06STATUS\x10\n\x1a\x0e\
    \xa2\xd4\xe0\xe5\x03\x08\n\x06STATUS\x124\n\x13BIGQUERY_PROJECT_ID\x10\
    \x0b\x1a\x1b\xa2\xd4\xe0\xe5\x03\x15\n\x13BIGQUERY_PROJECT_ID\x12.\n\x10\
    BIGQUERY_DATASET\x10\x0c\x1a\x18\xa2\xd4\xe0\xe5\x03\x12\n\x10BIGQUERY_D\
    ATASET\x12*\n\x0eBIGQUERY_TABLE\x10\r\x1a\x16\xa2\xd4\xe0\xe5\x03\x10\n\
    \x0eBIGQUERY_TABLE\x12(\n\rBIGQUERY_VIEW\x10\x0e\x1a\x15\xa2\xd4\xe0\xe5\
    \x03\x0f\n\rBIGQUERY_VIEW\x124\n\x13BIGQUERY_QUERY_NAME\x10\x0f\x1a\x1b\
    \xa2\xd4\xe0\xe5\x03\x15\n\x13BIGQUERY_QUERY_NAME\x12\"\n\nGCS_BUCKET\
    \x10\x10\x1a\x12\xa2\xd4\xe0\xe5\x03\x0c\n\nGCS_BUCKET\x12*\n\x0eGCS_PRO\
    JECT_ID\x10\x11\x1a\x16\xa2\xd4\xe0\xe5\x03\x10\n\x0eGCS_PROJECT_ID\x120\
    \n\x11DATASTORE_PROJECT\x10\x12\x1a\x19\xa2\xd4\xe0\xe5\x03\x13\n\x11DAT\
    ASTORE_PROJECT\x124\n\x13DATASTORE_NAMESPACE\x10\x13\x1a\x1b\xa2\xd4\xe0\
    \xe5\x03\x15\n\x13DATASTORE_NAMESPACE\x124\n\x13BIGTABLE_PROJECT_ID\x10\
    \x14\x1a\x1b\xa2\xd4\xe0\xe5\x03\x15\n\x13BIGTABLE_PROJECT_ID\x12$\n\x0b\
    INSTANCE_ID\x10\x15\x1a\x13\xa2\xd4\xe0\xe5\x03\r\n\x0bINSTANCE_ID\x12\
    \x1e\n\x08TABLE_ID\x10\x16\x1a\x10\xa2\xd4\xe0\xe5\x03\n\n\x08TABLE_ID\
    \x122\n\x12SPANNER_PROJECT_ID\x10\x17\x1a\x1a\xa2\xd4\xe0\xe5\x03\x14\n\
    \x12SPANNER_PROJECT_ID\x124\n\x13SPANNER_DATABASE_ID\x10\x18\x1a\x1b\xa2\
    \xd4\xe0\xe5\x03\x15\n\x13SPANNER_DATABASE_ID\x12.\n\x10SPANNER_TABLE_ID\
    \x10\x19\x1a\x18\xa2\xd4\xe0\xe5\x03\x12\n\x10SPANNER_TABLE_ID\x124\n\
    \x13SPANNER_INSTANCE_ID\x10\x1a\x1a\x1b\xa2\xd4\xe0\xe5\x03\x15\n\x13SPA\
    NNER_INSTANCE_ID\x122\n\x12SPANNER_QUERY_NAME\x10\x1b\x1a\x1a\xa2\xd4\
    \xe0\xe5\x03\x14\n\x12SPANNER_QUERY_NAME\"\xbc\x05\n\x16MonitoringInfoTy\
    peUrns\"\xa1\x05\n\x04Enum\x123\n\x0eSUM_INT64_TYPE\x10\0\x1a\x1f\xa2\
    \xb4\xfa\xc2\x05\x19beam:metrics:sum_int64:v1\x125\n\x0fSUM_DOUBLE_TYPE\
    \x10\x01\x1a\x20\xa2\xb4\xfa\xc2\x05\x1abeam:metrics:sum_double:v1\x12E\
    \n\x17DISTRIBUTION_INT64_TYPE\x10\x02\x1a(\xa2\xb4\xfa\xc2\x05\"beam:met\
    rics:distribution_int64:v1\x12G\n\x18DISTRIBUTION_DOUBLE_TYPE\x10\x03\
    \x1a)\xa2\xb4\xfa\xc2\x05#beam:metrics:distribution_double:v1\x129\n\x11\
    LATEST_INT64_TYPE\x10\x04\x1a\"\xa2\xb4\xfa\xc2\x05\x1cbeam:metrics:late\
    st_int64:v1\x12;\n\x12LATEST_DOUBLE_TYPE\x10\x05\x1a#\xa2\xb4\xfa\xc2\
    \x05\x1dbeam:metrics:latest_double:v1\x127\n\x10TOP_N_INT64_TYPE\x10\x06\
    \x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:metrics:top_n_int64:v1\x129\n\x11TOP_N\
    _DOUBLE_TYPE\x10\x07\x1a\"\xa2\xb4\xfa\xc2\x05\x1cbeam:metrics:top_n_dou\
    ble:v1\x12=\n\x13BOTTOM_N_INT64_TYPE\x10\x08\x1a$\xa2\xb4\xfa\xc2\x05\
    \x1ebeam:metrics:bottom_n_int64:v1\x12?\n\x14BOTTOM_N_DOUBLE_TYPE\x10\t\
    \x1a%\xa2\xb4\xfa\xc2\x05\x1fbeam:metrics:bottom_n_double:v1\x121\n\rPRO\
    GRESS_TYPE\x10\n\x1a\x1e\xa2\xb4\xfa\xc2\x05\x18beam:metrics:progress:v1\
    :\x82\x01\n\x0blabel_props\x18\xc4\x8a\xdc<\x20\x01(\x0b2;.org.apache.be\
    am.model.pipeline.v1.MonitoringInfoLabelProps\x12!.google.protobuf.EnumV\
    alueOptionsR\nlabelProps:\x8d\x01\n\x14monitoring_info_spec\x18\xfa\xf4\
    \xe4b\x20\x01(\x0b25.org.apache.beam.model.pipeline.v1.MonitoringInfoSpe\
    c\x12!.google.protobuf.EnumValueOptionsR\x12monitoringInfoSpecBy\n!org.a\
    pache.beam.model.pipeline.v1B\nMetricsApiZHgithub.com/apache/beam/sdks/v\
    2/go/pkg/beam/model/pipeline_v1;pipeline_v1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::beam_runner_api::file_descriptor().clone());
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(MonitoringInfoSpec::generated_message_descriptor_data());
            messages.push(Annotation::generated_message_descriptor_data());
            messages.push(MonitoringInfoSpecs::generated_message_descriptor_data());
            messages.push(MonitoringInfoLabelProps::generated_message_descriptor_data());
            messages.push(MonitoringInfo::generated_message_descriptor_data());
            messages.push(MonitoringInfoTypeUrns::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(monitoring_info_specs::Enum::generated_enum_descriptor_data());
            enums.push(monitoring_info::MonitoringInfoLabels::generated_enum_descriptor_data());
            enums.push(monitoring_info_type_urns::Enum::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
