// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.21.5
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `org/apache/beam/model/pipeline/v1/beam_runner_api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.BeamConstants)
pub struct BeamConstants {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.BeamConstants.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BeamConstants {
    fn default() -> &'a BeamConstants {
        <BeamConstants as ::protobuf::Message>::default_instance()
    }
}

impl BeamConstants {
    pub fn new() -> BeamConstants {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BeamConstants>(
            "BeamConstants",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BeamConstants {
    const NAME: &'static str = "BeamConstants";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BeamConstants {
        BeamConstants::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BeamConstants {
        static instance: BeamConstants = BeamConstants {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BeamConstants {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BeamConstants").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BeamConstants {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BeamConstants {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BeamConstants`
pub mod beam_constants {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.BeamConstants.Constants)
    pub enum Constants {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.BeamConstants.Constants.MIN_TIMESTAMP_MILLIS)
        MIN_TIMESTAMP_MILLIS = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.BeamConstants.Constants.MAX_TIMESTAMP_MILLIS)
        MAX_TIMESTAMP_MILLIS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.BeamConstants.Constants.GLOBAL_WINDOW_MAX_TIMESTAMP_MILLIS)
        GLOBAL_WINDOW_MAX_TIMESTAMP_MILLIS = 2,
    }

    impl ::protobuf::Enum for Constants {
        const NAME: &'static str = "Constants";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Constants> {
            match value {
                0 => ::std::option::Option::Some(Constants::MIN_TIMESTAMP_MILLIS),
                1 => ::std::option::Option::Some(Constants::MAX_TIMESTAMP_MILLIS),
                2 => ::std::option::Option::Some(Constants::GLOBAL_WINDOW_MAX_TIMESTAMP_MILLIS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Constants] = &[
            Constants::MIN_TIMESTAMP_MILLIS,
            Constants::MAX_TIMESTAMP_MILLIS,
            Constants::GLOBAL_WINDOW_MAX_TIMESTAMP_MILLIS,
        ];
    }

    impl ::protobuf::EnumFull for Constants {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BeamConstants.Constants").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Constants {
        fn default() -> Self {
            Constants::MIN_TIMESTAMP_MILLIS
        }
    }

    impl Constants {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Constants>("BeamConstants.Constants")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Components)
pub struct Components {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Components.transforms)
    pub transforms: ::std::collections::HashMap<::std::string::String, PTransform>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Components.pcollections)
    pub pcollections: ::std::collections::HashMap<::std::string::String, PCollection>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Components.windowing_strategies)
    pub windowing_strategies: ::std::collections::HashMap<::std::string::String, WindowingStrategy>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Components.coders)
    pub coders: ::std::collections::HashMap<::std::string::String, Coder>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Components.environments)
    pub environments: ::std::collections::HashMap<::std::string::String, Environment>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Components.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Components {
    fn default() -> &'a Components {
        <Components as ::protobuf::Message>::default_instance()
    }
}

impl Components {
    pub fn new() -> Components {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "transforms",
            |m: &Components| { &m.transforms },
            |m: &mut Components| { &mut m.transforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "pcollections",
            |m: &Components| { &m.pcollections },
            |m: &mut Components| { &mut m.pcollections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "windowing_strategies",
            |m: &Components| { &m.windowing_strategies },
            |m: &mut Components| { &mut m.windowing_strategies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "coders",
            |m: &Components| { &m.coders },
            |m: &mut Components| { &mut m.coders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "environments",
            |m: &Components| { &m.environments },
            |m: &mut Components| { &mut m.environments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Components>(
            "Components",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Components {
    const NAME: &'static str = "Components";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.transforms.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.pcollections.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.windowing_strategies.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.coders.insert(key, value);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.environments.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.transforms {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.pcollections {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.windowing_strategies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.coders {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.environments {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.transforms {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.pcollections {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.windowing_strategies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.coders {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.environments {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Components {
        Components::new()
    }

    fn clear(&mut self) {
        self.transforms.clear();
        self.pcollections.clear();
        self.windowing_strategies.clear();
        self.coders.clear();
        self.environments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Components {
        static instance: ::protobuf::rt::Lazy<Components> = ::protobuf::rt::Lazy::new();
        instance.get(Components::new)
    }
}

impl ::protobuf::MessageFull for Components {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Components").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Components {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Components {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Pipeline)
pub struct Pipeline {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Pipeline.components)
    pub components: ::protobuf::MessageField<Components>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Pipeline.root_transform_ids)
    pub root_transform_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Pipeline.display_data)
    pub display_data: ::std::vec::Vec<DisplayData>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Pipeline.requirements)
    pub requirements: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Pipeline.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pipeline {
    fn default() -> &'a Pipeline {
        <Pipeline as ::protobuf::Message>::default_instance()
    }
}

impl Pipeline {
    pub fn new() -> Pipeline {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Components>(
            "components",
            |m: &Pipeline| { &m.components },
            |m: &mut Pipeline| { &mut m.components },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "root_transform_ids",
            |m: &Pipeline| { &m.root_transform_ids },
            |m: &mut Pipeline| { &mut m.root_transform_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_data",
            |m: &Pipeline| { &m.display_data },
            |m: &mut Pipeline| { &mut m.display_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requirements",
            |m: &Pipeline| { &m.requirements },
            |m: &mut Pipeline| { &mut m.requirements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pipeline>(
            "Pipeline",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pipeline {
    const NAME: &'static str = "Pipeline";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.components)?;
                },
                18 => {
                    self.root_transform_ids.push(is.read_string()?);
                },
                26 => {
                    self.display_data.push(is.read_message()?);
                },
                34 => {
                    self.requirements.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.components.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.root_transform_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.display_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.requirements {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.components.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.root_transform_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.display_data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.requirements {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pipeline {
        Pipeline::new()
    }

    fn clear(&mut self) {
        self.components.clear();
        self.root_transform_ids.clear();
        self.display_data.clear();
        self.requirements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pipeline {
        static instance: Pipeline = Pipeline {
            components: ::protobuf::MessageField::none(),
            root_transform_ids: ::std::vec::Vec::new(),
            display_data: ::std::vec::Vec::new(),
            requirements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pipeline {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pipeline").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pipeline {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.PTransform)
pub struct PTransform {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.unique_name)
    pub unique_name: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.spec)
    pub spec: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.subtransforms)
    pub subtransforms: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.inputs)
    pub inputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.outputs)
    pub outputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.display_data)
    pub display_data: ::std::vec::Vec<DisplayData>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.environment_id)
    pub environment_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PTransform.annotations)
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.PTransform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PTransform {
    fn default() -> &'a PTransform {
        <PTransform as ::protobuf::Message>::default_instance()
    }
}

impl PTransform {
    pub fn new() -> PTransform {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_name",
            |m: &PTransform| { &m.unique_name },
            |m: &mut PTransform| { &mut m.unique_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "spec",
            |m: &PTransform| { &m.spec },
            |m: &mut PTransform| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subtransforms",
            |m: &PTransform| { &m.subtransforms },
            |m: &mut PTransform| { &mut m.subtransforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "inputs",
            |m: &PTransform| { &m.inputs },
            |m: &mut PTransform| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "outputs",
            |m: &PTransform| { &m.outputs },
            |m: &mut PTransform| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_data",
            |m: &PTransform| { &m.display_data },
            |m: &mut PTransform| { &mut m.display_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "environment_id",
            |m: &PTransform| { &m.environment_id },
            |m: &mut PTransform| { &mut m.environment_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "annotations",
            |m: &PTransform| { &m.annotations },
            |m: &mut PTransform| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PTransform>(
            "PTransform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PTransform {
    const NAME: &'static str = "PTransform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.unique_name = is.read_string()?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                18 => {
                    self.subtransforms.push(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.inputs.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.outputs.insert(key, value);
                },
                50 => {
                    self.display_data.push(is.read_message()?);
                },
                58 => {
                    self.environment_id = is.read_string()?;
                },
                66 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.annotations.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.unique_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.unique_name);
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subtransforms {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for (k, v) in &self.inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.outputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.display_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.environment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.environment_id);
        }
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.unique_name.is_empty() {
            os.write_string(5, &self.unique_name)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subtransforms {
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.outputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.display_data {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if !self.environment_id.is_empty() {
            os.write_string(7, &self.environment_id)?;
        }
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(66)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PTransform {
        PTransform::new()
    }

    fn clear(&mut self) {
        self.unique_name.clear();
        self.spec.clear();
        self.subtransforms.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.display_data.clear();
        self.environment_id.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PTransform {
        static instance: ::protobuf::rt::Lazy<PTransform> = ::protobuf::rt::Lazy::new();
        instance.get(PTransform::new)
    }
}

impl ::protobuf::MessageFull for PTransform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PTransform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PTransform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardPTransforms)
pub struct StandardPTransforms {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardPTransforms.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardPTransforms {
    fn default() -> &'a StandardPTransforms {
        <StandardPTransforms as ::protobuf::Message>::default_instance()
    }
}

impl StandardPTransforms {
    pub fn new() -> StandardPTransforms {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardPTransforms>(
            "StandardPTransforms",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardPTransforms {
    const NAME: &'static str = "StandardPTransforms";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardPTransforms {
        StandardPTransforms::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardPTransforms {
        static instance: StandardPTransforms = StandardPTransforms {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardPTransforms {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardPTransforms").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardPTransforms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardPTransforms {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardPTransforms`
pub mod standard_ptransforms {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives)
    pub enum Primitives {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.PAR_DO)
        PAR_DO = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.FLATTEN)
        FLATTEN = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.GROUP_BY_KEY)
        GROUP_BY_KEY = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.IMPULSE)
        IMPULSE = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.ASSIGN_WINDOWS)
        ASSIGN_WINDOWS = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.TEST_STREAM)
        TEST_STREAM = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.MAP_WINDOWS)
        MAP_WINDOWS = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.MERGE_WINDOWS)
        MERGE_WINDOWS = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Primitives.TO_STRING)
        TO_STRING = 8,
    }

    impl ::protobuf::Enum for Primitives {
        const NAME: &'static str = "Primitives";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Primitives> {
            match value {
                0 => ::std::option::Option::Some(Primitives::PAR_DO),
                1 => ::std::option::Option::Some(Primitives::FLATTEN),
                2 => ::std::option::Option::Some(Primitives::GROUP_BY_KEY),
                3 => ::std::option::Option::Some(Primitives::IMPULSE),
                4 => ::std::option::Option::Some(Primitives::ASSIGN_WINDOWS),
                5 => ::std::option::Option::Some(Primitives::TEST_STREAM),
                6 => ::std::option::Option::Some(Primitives::MAP_WINDOWS),
                7 => ::std::option::Option::Some(Primitives::MERGE_WINDOWS),
                8 => ::std::option::Option::Some(Primitives::TO_STRING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Primitives] = &[
            Primitives::PAR_DO,
            Primitives::FLATTEN,
            Primitives::GROUP_BY_KEY,
            Primitives::IMPULSE,
            Primitives::ASSIGN_WINDOWS,
            Primitives::TEST_STREAM,
            Primitives::MAP_WINDOWS,
            Primitives::MERGE_WINDOWS,
            Primitives::TO_STRING,
        ];
    }

    impl ::protobuf::EnumFull for Primitives {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.Primitives").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Primitives {
        fn default() -> Self {
            Primitives::PAR_DO
        }
    }

    impl Primitives {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Primitives>("StandardPTransforms.Primitives")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.DeprecatedPrimitives)
    pub enum DeprecatedPrimitives {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.DeprecatedPrimitives.READ)
        READ = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.DeprecatedPrimitives.CREATE_VIEW)
        CREATE_VIEW = 1,
    }

    impl ::protobuf::Enum for DeprecatedPrimitives {
        const NAME: &'static str = "DeprecatedPrimitives";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DeprecatedPrimitives> {
            match value {
                0 => ::std::option::Option::Some(DeprecatedPrimitives::READ),
                1 => ::std::option::Option::Some(DeprecatedPrimitives::CREATE_VIEW),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DeprecatedPrimitives] = &[
            DeprecatedPrimitives::READ,
            DeprecatedPrimitives::CREATE_VIEW,
        ];
    }

    impl ::protobuf::EnumFull for DeprecatedPrimitives {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.DeprecatedPrimitives").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DeprecatedPrimitives {
        fn default() -> Self {
            DeprecatedPrimitives::READ
        }
    }

    impl DeprecatedPrimitives {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DeprecatedPrimitives>("StandardPTransforms.DeprecatedPrimitives")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites)
    pub enum Composites {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.COMBINE_PER_KEY)
        COMBINE_PER_KEY = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.COMBINE_GLOBALLY)
        COMBINE_GLOBALLY = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.RESHUFFLE)
        RESHUFFLE = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.WRITE_FILES)
        WRITE_FILES = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.PUBSUB_READ)
        PUBSUB_READ = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.PUBSUB_WRITE)
        PUBSUB_WRITE = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.PUBSUB_WRITE_V2)
        PUBSUB_WRITE_V2 = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.Composites.GROUP_INTO_BATCHES_WITH_SHARDED_KEY)
        GROUP_INTO_BATCHES_WITH_SHARDED_KEY = 6,
    }

    impl ::protobuf::Enum for Composites {
        const NAME: &'static str = "Composites";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Composites> {
            match value {
                0 => ::std::option::Option::Some(Composites::COMBINE_PER_KEY),
                1 => ::std::option::Option::Some(Composites::COMBINE_GLOBALLY),
                2 => ::std::option::Option::Some(Composites::RESHUFFLE),
                3 => ::std::option::Option::Some(Composites::WRITE_FILES),
                4 => ::std::option::Option::Some(Composites::PUBSUB_READ),
                5 => ::std::option::Option::Some(Composites::PUBSUB_WRITE),
                7 => ::std::option::Option::Some(Composites::PUBSUB_WRITE_V2),
                6 => ::std::option::Option::Some(Composites::GROUP_INTO_BATCHES_WITH_SHARDED_KEY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Composites] = &[
            Composites::COMBINE_PER_KEY,
            Composites::COMBINE_GLOBALLY,
            Composites::RESHUFFLE,
            Composites::WRITE_FILES,
            Composites::PUBSUB_READ,
            Composites::PUBSUB_WRITE,
            Composites::PUBSUB_WRITE_V2,
            Composites::GROUP_INTO_BATCHES_WITH_SHARDED_KEY,
        ];
    }

    impl ::protobuf::EnumFull for Composites {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.Composites").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Composites::COMBINE_PER_KEY => 0,
                Composites::COMBINE_GLOBALLY => 1,
                Composites::RESHUFFLE => 2,
                Composites::WRITE_FILES => 3,
                Composites::PUBSUB_READ => 4,
                Composites::PUBSUB_WRITE => 5,
                Composites::PUBSUB_WRITE_V2 => 6,
                Composites::GROUP_INTO_BATCHES_WITH_SHARDED_KEY => 7,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Composites {
        fn default() -> Self {
            Composites::COMBINE_PER_KEY
        }
    }

    impl Composites {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Composites>("StandardPTransforms.Composites")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents)
    pub enum CombineComponents {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents.COMBINE_PER_KEY_PRECOMBINE)
        COMBINE_PER_KEY_PRECOMBINE = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents.COMBINE_PER_KEY_MERGE_ACCUMULATORS)
        COMBINE_PER_KEY_MERGE_ACCUMULATORS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents.COMBINE_PER_KEY_EXTRACT_OUTPUTS)
        COMBINE_PER_KEY_EXTRACT_OUTPUTS = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents.COMBINE_GROUPED_VALUES)
        COMBINE_GROUPED_VALUES = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.CombineComponents.COMBINE_PER_KEY_CONVERT_TO_ACCUMULATORS)
        COMBINE_PER_KEY_CONVERT_TO_ACCUMULATORS = 4,
    }

    impl ::protobuf::Enum for CombineComponents {
        const NAME: &'static str = "CombineComponents";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CombineComponents> {
            match value {
                0 => ::std::option::Option::Some(CombineComponents::COMBINE_PER_KEY_PRECOMBINE),
                1 => ::std::option::Option::Some(CombineComponents::COMBINE_PER_KEY_MERGE_ACCUMULATORS),
                2 => ::std::option::Option::Some(CombineComponents::COMBINE_PER_KEY_EXTRACT_OUTPUTS),
                3 => ::std::option::Option::Some(CombineComponents::COMBINE_GROUPED_VALUES),
                4 => ::std::option::Option::Some(CombineComponents::COMBINE_PER_KEY_CONVERT_TO_ACCUMULATORS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CombineComponents] = &[
            CombineComponents::COMBINE_PER_KEY_PRECOMBINE,
            CombineComponents::COMBINE_PER_KEY_MERGE_ACCUMULATORS,
            CombineComponents::COMBINE_PER_KEY_EXTRACT_OUTPUTS,
            CombineComponents::COMBINE_GROUPED_VALUES,
            CombineComponents::COMBINE_PER_KEY_CONVERT_TO_ACCUMULATORS,
        ];
    }

    impl ::protobuf::EnumFull for CombineComponents {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.CombineComponents").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CombineComponents {
        fn default() -> Self {
            CombineComponents::COMBINE_PER_KEY_PRECOMBINE
        }
    }

    impl CombineComponents {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CombineComponents>("StandardPTransforms.CombineComponents")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.SplittableParDoComponents)
    pub enum SplittableParDoComponents {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.SplittableParDoComponents.PAIR_WITH_RESTRICTION)
        PAIR_WITH_RESTRICTION = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.SplittableParDoComponents.SPLIT_AND_SIZE_RESTRICTIONS)
        SPLIT_AND_SIZE_RESTRICTIONS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.SplittableParDoComponents.PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS)
        PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.SplittableParDoComponents.TRUNCATE_SIZED_RESTRICTION)
        TRUNCATE_SIZED_RESTRICTION = 3,
    }

    impl ::protobuf::Enum for SplittableParDoComponents {
        const NAME: &'static str = "SplittableParDoComponents";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SplittableParDoComponents> {
            match value {
                0 => ::std::option::Option::Some(SplittableParDoComponents::PAIR_WITH_RESTRICTION),
                1 => ::std::option::Option::Some(SplittableParDoComponents::SPLIT_AND_SIZE_RESTRICTIONS),
                2 => ::std::option::Option::Some(SplittableParDoComponents::PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS),
                3 => ::std::option::Option::Some(SplittableParDoComponents::TRUNCATE_SIZED_RESTRICTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SplittableParDoComponents] = &[
            SplittableParDoComponents::PAIR_WITH_RESTRICTION,
            SplittableParDoComponents::SPLIT_AND_SIZE_RESTRICTIONS,
            SplittableParDoComponents::PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS,
            SplittableParDoComponents::TRUNCATE_SIZED_RESTRICTION,
        ];
    }

    impl ::protobuf::EnumFull for SplittableParDoComponents {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.SplittableParDoComponents").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SplittableParDoComponents {
        fn default() -> Self {
            SplittableParDoComponents::PAIR_WITH_RESTRICTION
        }
    }

    impl SplittableParDoComponents {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SplittableParDoComponents>("StandardPTransforms.SplittableParDoComponents")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardPTransforms.GroupIntoBatchesComponents)
    pub enum GroupIntoBatchesComponents {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardPTransforms.GroupIntoBatchesComponents.GROUP_INTO_BATCHES)
        GROUP_INTO_BATCHES = 0,
    }

    impl ::protobuf::Enum for GroupIntoBatchesComponents {
        const NAME: &'static str = "GroupIntoBatchesComponents";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GroupIntoBatchesComponents> {
            match value {
                0 => ::std::option::Option::Some(GroupIntoBatchesComponents::GROUP_INTO_BATCHES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GroupIntoBatchesComponents] = &[
            GroupIntoBatchesComponents::GROUP_INTO_BATCHES,
        ];
    }

    impl ::protobuf::EnumFull for GroupIntoBatchesComponents {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardPTransforms.GroupIntoBatchesComponents").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for GroupIntoBatchesComponents {
        fn default() -> Self {
            GroupIntoBatchesComponents::GROUP_INTO_BATCHES
        }
    }

    impl GroupIntoBatchesComponents {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupIntoBatchesComponents>("StandardPTransforms.GroupIntoBatchesComponents")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardSideInputTypes)
pub struct StandardSideInputTypes {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardSideInputTypes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardSideInputTypes {
    fn default() -> &'a StandardSideInputTypes {
        <StandardSideInputTypes as ::protobuf::Message>::default_instance()
    }
}

impl StandardSideInputTypes {
    pub fn new() -> StandardSideInputTypes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardSideInputTypes>(
            "StandardSideInputTypes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardSideInputTypes {
    const NAME: &'static str = "StandardSideInputTypes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardSideInputTypes {
        StandardSideInputTypes::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardSideInputTypes {
        static instance: StandardSideInputTypes = StandardSideInputTypes {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardSideInputTypes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardSideInputTypes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardSideInputTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardSideInputTypes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardSideInputTypes`
pub mod standard_side_input_types {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardSideInputTypes.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardSideInputTypes.Enum.ITERABLE)
        ITERABLE = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardSideInputTypes.Enum.MULTIMAP)
        MULTIMAP = 1,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::ITERABLE),
                1 => ::std::option::Option::Some(Enum::MULTIMAP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::ITERABLE,
            Enum::MULTIMAP,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardSideInputTypes.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::ITERABLE
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardSideInputTypes.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardUserStateTypes)
pub struct StandardUserStateTypes {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardUserStateTypes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardUserStateTypes {
    fn default() -> &'a StandardUserStateTypes {
        <StandardUserStateTypes as ::protobuf::Message>::default_instance()
    }
}

impl StandardUserStateTypes {
    pub fn new() -> StandardUserStateTypes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardUserStateTypes>(
            "StandardUserStateTypes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardUserStateTypes {
    const NAME: &'static str = "StandardUserStateTypes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardUserStateTypes {
        StandardUserStateTypes::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardUserStateTypes {
        static instance: StandardUserStateTypes = StandardUserStateTypes {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardUserStateTypes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardUserStateTypes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardUserStateTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardUserStateTypes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardUserStateTypes`
pub mod standard_user_state_types {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardUserStateTypes.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardUserStateTypes.Enum.BAG)
        BAG = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardUserStateTypes.Enum.MULTIMAP)
        MULTIMAP = 1,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::BAG),
                1 => ::std::option::Option::Some(Enum::MULTIMAP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::BAG,
            Enum::MULTIMAP,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardUserStateTypes.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::BAG
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardUserStateTypes.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.PCollection)
pub struct PCollection {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PCollection.unique_name)
    pub unique_name: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PCollection.coder_id)
    pub coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PCollection.is_bounded)
    pub is_bounded: ::protobuf::EnumOrUnknown<is_bounded::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PCollection.windowing_strategy_id)
    pub windowing_strategy_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PCollection.display_data)
    pub display_data: ::std::vec::Vec<DisplayData>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.PCollection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PCollection {
    fn default() -> &'a PCollection {
        <PCollection as ::protobuf::Message>::default_instance()
    }
}

impl PCollection {
    pub fn new() -> PCollection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_name",
            |m: &PCollection| { &m.unique_name },
            |m: &mut PCollection| { &mut m.unique_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coder_id",
            |m: &PCollection| { &m.coder_id },
            |m: &mut PCollection| { &mut m.coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bounded",
            |m: &PCollection| { &m.is_bounded },
            |m: &mut PCollection| { &mut m.is_bounded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "windowing_strategy_id",
            |m: &PCollection| { &m.windowing_strategy_id },
            |m: &mut PCollection| { &mut m.windowing_strategy_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_data",
            |m: &PCollection| { &m.display_data },
            |m: &mut PCollection| { &mut m.display_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PCollection>(
            "PCollection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PCollection {
    const NAME: &'static str = "PCollection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = is.read_string()?;
                },
                18 => {
                    self.coder_id = is.read_string()?;
                },
                24 => {
                    self.is_bounded = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.windowing_strategy_id = is.read_string()?;
                },
                42 => {
                    self.display_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.unique_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.unique_name);
        }
        if !self.coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.coder_id);
        }
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(3, self.is_bounded.value());
        }
        if !self.windowing_strategy_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.windowing_strategy_id);
        }
        for value in &self.display_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.unique_name.is_empty() {
            os.write_string(1, &self.unique_name)?;
        }
        if !self.coder_id.is_empty() {
            os.write_string(2, &self.coder_id)?;
        }
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.is_bounded))?;
        }
        if !self.windowing_strategy_id.is_empty() {
            os.write_string(4, &self.windowing_strategy_id)?;
        }
        for v in &self.display_data {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PCollection {
        PCollection::new()
    }

    fn clear(&mut self) {
        self.unique_name.clear();
        self.coder_id.clear();
        self.is_bounded = ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED);
        self.windowing_strategy_id.clear();
        self.display_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PCollection {
        static instance: PCollection = PCollection {
            unique_name: ::std::string::String::new(),
            coder_id: ::std::string::String::new(),
            is_bounded: ::protobuf::EnumOrUnknown::from_i32(0),
            windowing_strategy_id: ::std::string::String::new(),
            display_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PCollection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PCollection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PCollection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ParDoPayload)
pub struct ParDoPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.do_fn)
    pub do_fn: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.side_inputs)
    pub side_inputs: ::std::collections::HashMap<::std::string::String, SideInput>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.state_specs)
    pub state_specs: ::std::collections::HashMap<::std::string::String, StateSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.timer_family_specs)
    pub timer_family_specs: ::std::collections::HashMap<::std::string::String, TimerFamilySpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.restriction_coder_id)
    pub restriction_coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.requests_finalization)
    pub requests_finalization: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.requires_time_sorted_input)
    pub requires_time_sorted_input: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.requires_stable_input)
    pub requires_stable_input: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ParDoPayload.on_window_expiration_timer_family_spec)
    pub on_window_expiration_timer_family_spec: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ParDoPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParDoPayload {
    fn default() -> &'a ParDoPayload {
        <ParDoPayload as ::protobuf::Message>::default_instance()
    }
}

impl ParDoPayload {
    pub fn new() -> ParDoPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "do_fn",
            |m: &ParDoPayload| { &m.do_fn },
            |m: &mut ParDoPayload| { &mut m.do_fn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "side_inputs",
            |m: &ParDoPayload| { &m.side_inputs },
            |m: &mut ParDoPayload| { &mut m.side_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "state_specs",
            |m: &ParDoPayload| { &m.state_specs },
            |m: &mut ParDoPayload| { &mut m.state_specs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "timer_family_specs",
            |m: &ParDoPayload| { &m.timer_family_specs },
            |m: &mut ParDoPayload| { &mut m.timer_family_specs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "restriction_coder_id",
            |m: &ParDoPayload| { &m.restriction_coder_id },
            |m: &mut ParDoPayload| { &mut m.restriction_coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requests_finalization",
            |m: &ParDoPayload| { &m.requests_finalization },
            |m: &mut ParDoPayload| { &mut m.requests_finalization },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_time_sorted_input",
            |m: &ParDoPayload| { &m.requires_time_sorted_input },
            |m: &mut ParDoPayload| { &mut m.requires_time_sorted_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_stable_input",
            |m: &ParDoPayload| { &m.requires_stable_input },
            |m: &mut ParDoPayload| { &mut m.requires_stable_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "on_window_expiration_timer_family_spec",
            |m: &ParDoPayload| { &m.on_window_expiration_timer_family_spec },
            |m: &mut ParDoPayload| { &mut m.on_window_expiration_timer_family_spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParDoPayload>(
            "ParDoPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParDoPayload {
    const NAME: &'static str = "ParDoPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.do_fn)?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.side_inputs.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.state_specs.insert(key, value);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.timer_family_specs.insert(key, value);
                },
                58 => {
                    self.restriction_coder_id = is.read_string()?;
                },
                64 => {
                    self.requests_finalization = is.read_bool()?;
                },
                80 => {
                    self.requires_time_sorted_input = is.read_bool()?;
                },
                88 => {
                    self.requires_stable_input = is.read_bool()?;
                },
                98 => {
                    self.on_window_expiration_timer_family_spec = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.do_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.side_inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.state_specs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.timer_family_specs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.restriction_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.restriction_coder_id);
        }
        if self.requests_finalization != false {
            my_size += 1 + 1;
        }
        if self.requires_time_sorted_input != false {
            my_size += 1 + 1;
        }
        if self.requires_stable_input != false {
            my_size += 1 + 1;
        }
        if !self.on_window_expiration_timer_family_spec.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.on_window_expiration_timer_family_spec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.do_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.side_inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.state_specs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.timer_family_specs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.restriction_coder_id.is_empty() {
            os.write_string(7, &self.restriction_coder_id)?;
        }
        if self.requests_finalization != false {
            os.write_bool(8, self.requests_finalization)?;
        }
        if self.requires_time_sorted_input != false {
            os.write_bool(10, self.requires_time_sorted_input)?;
        }
        if self.requires_stable_input != false {
            os.write_bool(11, self.requires_stable_input)?;
        }
        if !self.on_window_expiration_timer_family_spec.is_empty() {
            os.write_string(12, &self.on_window_expiration_timer_family_spec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParDoPayload {
        ParDoPayload::new()
    }

    fn clear(&mut self) {
        self.do_fn.clear();
        self.side_inputs.clear();
        self.state_specs.clear();
        self.timer_family_specs.clear();
        self.restriction_coder_id.clear();
        self.requests_finalization = false;
        self.requires_time_sorted_input = false;
        self.requires_stable_input = false;
        self.on_window_expiration_timer_family_spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParDoPayload {
        static instance: ::protobuf::rt::Lazy<ParDoPayload> = ::protobuf::rt::Lazy::new();
        instance.get(ParDoPayload::new)
    }
}

impl ::protobuf::MessageFull for ParDoPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParDoPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParDoPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParDoPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StateSpec)
pub struct StateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.StateSpec.protocol)
    pub protocol: ::protobuf::MessageField<FunctionSpec>,
    // message oneof groups
    pub spec: ::std::option::Option<state_spec::Spec>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateSpec {
    fn default() -> &'a StateSpec {
        <StateSpec as ::protobuf::Message>::default_instance()
    }
}

impl StateSpec {
    pub fn new() -> StateSpec {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.pipeline.v1.ReadModifyWriteStateSpec read_modify_write_spec = 1;

    pub fn read_modify_write_spec(&self) -> &ReadModifyWriteStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(ref v)) => v,
            _ => <ReadModifyWriteStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_modify_write_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_read_modify_write_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_modify_write_spec(&mut self, v: ReadModifyWriteStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_modify_write_spec(&mut self) -> &mut ReadModifyWriteStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(ReadModifyWriteStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_modify_write_spec(&mut self) -> ReadModifyWriteStateSpec {
        if self.has_read_modify_write_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadModifyWriteStateSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.BagStateSpec bag_spec = 2;

    pub fn bag_spec(&self) -> &BagStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::BagSpec(ref v)) => v,
            _ => <BagStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bag_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_bag_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::BagSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bag_spec(&mut self, v: BagStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::BagSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bag_spec(&mut self) -> &mut BagStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::BagSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::BagSpec(BagStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::BagSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bag_spec(&mut self) -> BagStateSpec {
        if self.has_bag_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::BagSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            BagStateSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.CombiningStateSpec combining_spec = 3;

    pub fn combining_spec(&self) -> &CombiningStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::CombiningSpec(ref v)) => v,
            _ => <CombiningStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combining_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_combining_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::CombiningSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combining_spec(&mut self, v: CombiningStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::CombiningSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combining_spec(&mut self) -> &mut CombiningStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::CombiningSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::CombiningSpec(CombiningStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::CombiningSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combining_spec(&mut self) -> CombiningStateSpec {
        if self.has_combining_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::CombiningSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            CombiningStateSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.MapStateSpec map_spec = 4;

    pub fn map_spec(&self) -> &MapStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::MapSpec(ref v)) => v,
            _ => <MapStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_map_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_map_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::MapSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_spec(&mut self, v: MapStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::MapSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_spec(&mut self) -> &mut MapStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::MapSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::MapSpec(MapStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::MapSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_spec(&mut self) -> MapStateSpec {
        if self.has_map_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::MapSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            MapStateSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.SetStateSpec set_spec = 5;

    pub fn set_spec(&self) -> &SetStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::SetSpec(ref v)) => v,
            _ => <SetStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_set_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::SetSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_spec(&mut self, v: SetStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::SetSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_spec(&mut self) -> &mut SetStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::SetSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::SetSpec(SetStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::SetSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_spec(&mut self) -> SetStateSpec {
        if self.has_set_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::SetSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            SetStateSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.OrderedListStateSpec ordered_list_spec = 6;

    pub fn ordered_list_spec(&self) -> &OrderedListStateSpec {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(ref v)) => v,
            _ => <OrderedListStateSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ordered_list_spec(&mut self) {
        self.spec = ::std::option::Option::None;
    }

    pub fn has_ordered_list_spec(&self) -> bool {
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ordered_list_spec(&mut self, v: OrderedListStateSpec) {
        self.spec = ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ordered_list_spec(&mut self) -> &mut OrderedListStateSpec {
        if let ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(_)) = self.spec {
        } else {
            self.spec = ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(OrderedListStateSpec::new()));
        }
        match self.spec {
            ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ordered_list_spec(&mut self) -> OrderedListStateSpec {
        if self.has_ordered_list_spec() {
            match self.spec.take() {
                ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            OrderedListStateSpec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadModifyWriteStateSpec>(
            "read_modify_write_spec",
            StateSpec::has_read_modify_write_spec,
            StateSpec::read_modify_write_spec,
            StateSpec::mut_read_modify_write_spec,
            StateSpec::set_read_modify_write_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BagStateSpec>(
            "bag_spec",
            StateSpec::has_bag_spec,
            StateSpec::bag_spec,
            StateSpec::mut_bag_spec,
            StateSpec::set_bag_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CombiningStateSpec>(
            "combining_spec",
            StateSpec::has_combining_spec,
            StateSpec::combining_spec,
            StateSpec::mut_combining_spec,
            StateSpec::set_combining_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MapStateSpec>(
            "map_spec",
            StateSpec::has_map_spec,
            StateSpec::map_spec,
            StateSpec::mut_map_spec,
            StateSpec::set_map_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetStateSpec>(
            "set_spec",
            StateSpec::has_set_spec,
            StateSpec::set_spec,
            StateSpec::mut_set_spec,
            StateSpec::set_set_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OrderedListStateSpec>(
            "ordered_list_spec",
            StateSpec::has_ordered_list_spec,
            StateSpec::ordered_list_spec,
            StateSpec::mut_ordered_list_spec,
            StateSpec::set_ordered_list_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "protocol",
            |m: &StateSpec| { &m.protocol },
            |m: &mut StateSpec| { &mut m.protocol },
        ));
        oneofs.push(state_spec::Spec::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateSpec>(
            "StateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateSpec {
    const NAME: &'static str = "StateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::ReadModifyWriteSpec(is.read_message()?));
                },
                18 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::BagSpec(is.read_message()?));
                },
                26 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::CombiningSpec(is.read_message()?));
                },
                34 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::MapSpec(is.read_message()?));
                },
                42 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::SetSpec(is.read_message()?));
                },
                50 => {
                    self.spec = ::std::option::Option::Some(state_spec::Spec::OrderedListSpec(is.read_message()?));
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.protocol)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.spec {
            match v {
                &state_spec::Spec::ReadModifyWriteSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_spec::Spec::BagSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_spec::Spec::CombiningSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_spec::Spec::MapSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_spec::Spec::SetSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_spec::Spec::OrderedListSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.spec {
            match v {
                &state_spec::Spec::ReadModifyWriteSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &state_spec::Spec::BagSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &state_spec::Spec::CombiningSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &state_spec::Spec::MapSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &state_spec::Spec::SetSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &state_spec::Spec::OrderedListSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateSpec {
        StateSpec::new()
    }

    fn clear(&mut self) {
        self.spec = ::std::option::Option::None;
        self.spec = ::std::option::Option::None;
        self.spec = ::std::option::Option::None;
        self.spec = ::std::option::Option::None;
        self.spec = ::std::option::Option::None;
        self.spec = ::std::option::Option::None;
        self.protocol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateSpec {
        static instance: StateSpec = StateSpec {
            protocol: ::protobuf::MessageField::none(),
            spec: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StateSpec`
pub mod state_spec {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.StateSpec.spec)
    pub enum Spec {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.read_modify_write_spec)
        ReadModifyWriteSpec(super::ReadModifyWriteStateSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.bag_spec)
        BagSpec(super::BagStateSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.combining_spec)
        CombiningSpec(super::CombiningStateSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.map_spec)
        MapSpec(super::MapStateSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.set_spec)
        SetSpec(super::SetStateSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.StateSpec.ordered_list_spec)
        OrderedListSpec(super::OrderedListStateSpec),
    }

    impl ::protobuf::Oneof for Spec {
    }

    impl ::protobuf::OneofFull for Spec {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StateSpec as ::protobuf::MessageFull>::descriptor().oneof_by_name("spec").unwrap()).clone()
        }
    }

    impl Spec {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Spec>("spec")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ReadModifyWriteStateSpec)
pub struct ReadModifyWriteStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ReadModifyWriteStateSpec.coder_id)
    pub coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ReadModifyWriteStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadModifyWriteStateSpec {
    fn default() -> &'a ReadModifyWriteStateSpec {
        <ReadModifyWriteStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReadModifyWriteStateSpec {
    pub fn new() -> ReadModifyWriteStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coder_id",
            |m: &ReadModifyWriteStateSpec| { &m.coder_id },
            |m: &mut ReadModifyWriteStateSpec| { &mut m.coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadModifyWriteStateSpec>(
            "ReadModifyWriteStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadModifyWriteStateSpec {
    const NAME: &'static str = "ReadModifyWriteStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.coder_id.is_empty() {
            os.write_string(1, &self.coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadModifyWriteStateSpec {
        ReadModifyWriteStateSpec::new()
    }

    fn clear(&mut self) {
        self.coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadModifyWriteStateSpec {
        static instance: ReadModifyWriteStateSpec = ReadModifyWriteStateSpec {
            coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadModifyWriteStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadModifyWriteStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadModifyWriteStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadModifyWriteStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.BagStateSpec)
pub struct BagStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.BagStateSpec.element_coder_id)
    pub element_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.BagStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BagStateSpec {
    fn default() -> &'a BagStateSpec {
        <BagStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl BagStateSpec {
    pub fn new() -> BagStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "element_coder_id",
            |m: &BagStateSpec| { &m.element_coder_id },
            |m: &mut BagStateSpec| { &mut m.element_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BagStateSpec>(
            "BagStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BagStateSpec {
    const NAME: &'static str = "BagStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.element_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.element_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.element_coder_id.is_empty() {
            os.write_string(1, &self.element_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BagStateSpec {
        BagStateSpec::new()
    }

    fn clear(&mut self) {
        self.element_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BagStateSpec {
        static instance: BagStateSpec = BagStateSpec {
            element_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BagStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BagStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BagStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BagStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.OrderedListStateSpec)
pub struct OrderedListStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.OrderedListStateSpec.element_coder_id)
    pub element_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.OrderedListStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderedListStateSpec {
    fn default() -> &'a OrderedListStateSpec {
        <OrderedListStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl OrderedListStateSpec {
    pub fn new() -> OrderedListStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "element_coder_id",
            |m: &OrderedListStateSpec| { &m.element_coder_id },
            |m: &mut OrderedListStateSpec| { &mut m.element_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderedListStateSpec>(
            "OrderedListStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderedListStateSpec {
    const NAME: &'static str = "OrderedListStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.element_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.element_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.element_coder_id.is_empty() {
            os.write_string(1, &self.element_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderedListStateSpec {
        OrderedListStateSpec::new()
    }

    fn clear(&mut self) {
        self.element_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderedListStateSpec {
        static instance: OrderedListStateSpec = OrderedListStateSpec {
            element_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderedListStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderedListStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderedListStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderedListStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.CombiningStateSpec)
pub struct CombiningStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.CombiningStateSpec.accumulator_coder_id)
    pub accumulator_coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.CombiningStateSpec.combine_fn)
    pub combine_fn: ::protobuf::MessageField<FunctionSpec>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.CombiningStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CombiningStateSpec {
    fn default() -> &'a CombiningStateSpec {
        <CombiningStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl CombiningStateSpec {
    pub fn new() -> CombiningStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accumulator_coder_id",
            |m: &CombiningStateSpec| { &m.accumulator_coder_id },
            |m: &mut CombiningStateSpec| { &mut m.accumulator_coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "combine_fn",
            |m: &CombiningStateSpec| { &m.combine_fn },
            |m: &mut CombiningStateSpec| { &mut m.combine_fn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CombiningStateSpec>(
            "CombiningStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CombiningStateSpec {
    const NAME: &'static str = "CombiningStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accumulator_coder_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.combine_fn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.accumulator_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.accumulator_coder_id);
        }
        if let Some(v) = self.combine_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.accumulator_coder_id.is_empty() {
            os.write_string(1, &self.accumulator_coder_id)?;
        }
        if let Some(v) = self.combine_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CombiningStateSpec {
        CombiningStateSpec::new()
    }

    fn clear(&mut self) {
        self.accumulator_coder_id.clear();
        self.combine_fn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CombiningStateSpec {
        static instance: CombiningStateSpec = CombiningStateSpec {
            accumulator_coder_id: ::std::string::String::new(),
            combine_fn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CombiningStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CombiningStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CombiningStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombiningStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MapStateSpec)
pub struct MapStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MapStateSpec.key_coder_id)
    pub key_coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MapStateSpec.value_coder_id)
    pub value_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MapStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapStateSpec {
    fn default() -> &'a MapStateSpec {
        <MapStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl MapStateSpec {
    pub fn new() -> MapStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_coder_id",
            |m: &MapStateSpec| { &m.key_coder_id },
            |m: &mut MapStateSpec| { &mut m.key_coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value_coder_id",
            |m: &MapStateSpec| { &m.value_coder_id },
            |m: &mut MapStateSpec| { &mut m.value_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapStateSpec>(
            "MapStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapStateSpec {
    const NAME: &'static str = "MapStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_coder_id = is.read_string()?;
                },
                18 => {
                    self.value_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_coder_id);
        }
        if !self.value_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key_coder_id.is_empty() {
            os.write_string(1, &self.key_coder_id)?;
        }
        if !self.value_coder_id.is_empty() {
            os.write_string(2, &self.value_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapStateSpec {
        MapStateSpec::new()
    }

    fn clear(&mut self) {
        self.key_coder_id.clear();
        self.value_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapStateSpec {
        static instance: MapStateSpec = MapStateSpec {
            key_coder_id: ::std::string::String::new(),
            value_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.SetStateSpec)
pub struct SetStateSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.SetStateSpec.element_coder_id)
    pub element_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.SetStateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetStateSpec {
    fn default() -> &'a SetStateSpec {
        <SetStateSpec as ::protobuf::Message>::default_instance()
    }
}

impl SetStateSpec {
    pub fn new() -> SetStateSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "element_coder_id",
            |m: &SetStateSpec| { &m.element_coder_id },
            |m: &mut SetStateSpec| { &mut m.element_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetStateSpec>(
            "SetStateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetStateSpec {
    const NAME: &'static str = "SetStateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.element_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.element_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.element_coder_id.is_empty() {
            os.write_string(1, &self.element_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetStateSpec {
        SetStateSpec::new()
    }

    fn clear(&mut self) {
        self.element_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetStateSpec {
        static instance: SetStateSpec = SetStateSpec {
            element_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetStateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetStateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetStateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TimerFamilySpec)
pub struct TimerFamilySpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TimerFamilySpec.time_domain)
    pub time_domain: ::protobuf::EnumOrUnknown<time_domain::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TimerFamilySpec.timer_family_coder_id)
    pub timer_family_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TimerFamilySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimerFamilySpec {
    fn default() -> &'a TimerFamilySpec {
        <TimerFamilySpec as ::protobuf::Message>::default_instance()
    }
}

impl TimerFamilySpec {
    pub fn new() -> TimerFamilySpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_domain",
            |m: &TimerFamilySpec| { &m.time_domain },
            |m: &mut TimerFamilySpec| { &mut m.time_domain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timer_family_coder_id",
            |m: &TimerFamilySpec| { &m.timer_family_coder_id },
            |m: &mut TimerFamilySpec| { &mut m.timer_family_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimerFamilySpec>(
            "TimerFamilySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimerFamilySpec {
    const NAME: &'static str = "TimerFamilySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_domain = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.timer_family_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.time_domain != ::protobuf::EnumOrUnknown::new(time_domain::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.time_domain.value());
        }
        if !self.timer_family_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timer_family_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.time_domain != ::protobuf::EnumOrUnknown::new(time_domain::Enum::UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.time_domain))?;
        }
        if !self.timer_family_coder_id.is_empty() {
            os.write_string(2, &self.timer_family_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimerFamilySpec {
        TimerFamilySpec::new()
    }

    fn clear(&mut self) {
        self.time_domain = ::protobuf::EnumOrUnknown::new(time_domain::Enum::UNSPECIFIED);
        self.timer_family_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimerFamilySpec {
        static instance: TimerFamilySpec = TimerFamilySpec {
            time_domain: ::protobuf::EnumOrUnknown::from_i32(0),
            timer_family_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimerFamilySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimerFamilySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimerFamilySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimerFamilySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.IsBounded)
pub struct IsBounded {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.IsBounded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IsBounded {
    fn default() -> &'a IsBounded {
        <IsBounded as ::protobuf::Message>::default_instance()
    }
}

impl IsBounded {
    pub fn new() -> IsBounded {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IsBounded>(
            "IsBounded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IsBounded {
    const NAME: &'static str = "IsBounded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IsBounded {
        IsBounded::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IsBounded {
        static instance: IsBounded = IsBounded {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IsBounded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IsBounded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IsBounded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsBounded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `IsBounded`
pub mod is_bounded {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.IsBounded.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.IsBounded.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.IsBounded.Enum.UNBOUNDED)
        UNBOUNDED = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.IsBounded.Enum.BOUNDED)
        BOUNDED = 2,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::UNBOUNDED),
                2 => ::std::option::Option::Some(Enum::BOUNDED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::UNBOUNDED,
            Enum::BOUNDED,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("IsBounded.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("IsBounded.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ReadPayload)
pub struct ReadPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ReadPayload.source)
    pub source: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ReadPayload.is_bounded)
    pub is_bounded: ::protobuf::EnumOrUnknown<is_bounded::Enum>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ReadPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadPayload {
    fn default() -> &'a ReadPayload {
        <ReadPayload as ::protobuf::Message>::default_instance()
    }
}

impl ReadPayload {
    pub fn new() -> ReadPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "source",
            |m: &ReadPayload| { &m.source },
            |m: &mut ReadPayload| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bounded",
            |m: &ReadPayload| { &m.is_bounded },
            |m: &mut ReadPayload| { &mut m.is_bounded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadPayload>(
            "ReadPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadPayload {
    const NAME: &'static str = "ReadPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                16 => {
                    self.is_bounded = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.is_bounded.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.is_bounded))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadPayload {
        ReadPayload::new()
    }

    fn clear(&mut self) {
        self.source.clear();
        self.is_bounded = ::protobuf::EnumOrUnknown::new(is_bounded::Enum::UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadPayload {
        static instance: ReadPayload = ReadPayload {
            source: ::protobuf::MessageField::none(),
            is_bounded: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.WindowIntoPayload)
pub struct WindowIntoPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowIntoPayload.window_fn)
    pub window_fn: ::protobuf::MessageField<FunctionSpec>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.WindowIntoPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowIntoPayload {
    fn default() -> &'a WindowIntoPayload {
        <WindowIntoPayload as ::protobuf::Message>::default_instance()
    }
}

impl WindowIntoPayload {
    pub fn new() -> WindowIntoPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "window_fn",
            |m: &WindowIntoPayload| { &m.window_fn },
            |m: &mut WindowIntoPayload| { &mut m.window_fn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowIntoPayload>(
            "WindowIntoPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowIntoPayload {
    const NAME: &'static str = "WindowIntoPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.window_fn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.window_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.window_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowIntoPayload {
        WindowIntoPayload::new()
    }

    fn clear(&mut self) {
        self.window_fn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowIntoPayload {
        static instance: WindowIntoPayload = WindowIntoPayload {
            window_fn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowIntoPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowIntoPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowIntoPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowIntoPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.CombinePayload)
pub struct CombinePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.CombinePayload.combine_fn)
    pub combine_fn: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.CombinePayload.accumulator_coder_id)
    pub accumulator_coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.CombinePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CombinePayload {
    fn default() -> &'a CombinePayload {
        <CombinePayload as ::protobuf::Message>::default_instance()
    }
}

impl CombinePayload {
    pub fn new() -> CombinePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "combine_fn",
            |m: &CombinePayload| { &m.combine_fn },
            |m: &mut CombinePayload| { &mut m.combine_fn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accumulator_coder_id",
            |m: &CombinePayload| { &m.accumulator_coder_id },
            |m: &mut CombinePayload| { &mut m.accumulator_coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CombinePayload>(
            "CombinePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CombinePayload {
    const NAME: &'static str = "CombinePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.combine_fn)?;
                },
                18 => {
                    self.accumulator_coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.combine_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.accumulator_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.accumulator_coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.combine_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.accumulator_coder_id.is_empty() {
            os.write_string(2, &self.accumulator_coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CombinePayload {
        CombinePayload::new()
    }

    fn clear(&mut self) {
        self.combine_fn.clear();
        self.accumulator_coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CombinePayload {
        static instance: CombinePayload = CombinePayload {
            combine_fn: ::protobuf::MessageField::none(),
            accumulator_coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CombinePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CombinePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CombinePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombinePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload)
pub struct TestStreamPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.coder_id)
    pub coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.events)
    pub events: ::std::vec::Vec<test_stream_payload::Event>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.endpoint)
    pub endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestStreamPayload {
    fn default() -> &'a TestStreamPayload {
        <TestStreamPayload as ::protobuf::Message>::default_instance()
    }
}

impl TestStreamPayload {
    pub fn new() -> TestStreamPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coder_id",
            |m: &TestStreamPayload| { &m.coder_id },
            |m: &mut TestStreamPayload| { &mut m.coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &TestStreamPayload| { &m.events },
            |m: &mut TestStreamPayload| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "endpoint",
            |m: &TestStreamPayload| { &m.endpoint },
            |m: &mut TestStreamPayload| { &mut m.endpoint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestStreamPayload>(
            "TestStreamPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestStreamPayload {
    const NAME: &'static str = "TestStreamPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.coder_id = is.read_string()?;
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.endpoint)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.coder_id);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.coder_id.is_empty() {
            os.write_string(1, &self.coder_id)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestStreamPayload {
        TestStreamPayload::new()
    }

    fn clear(&mut self) {
        self.coder_id.clear();
        self.events.clear();
        self.endpoint.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestStreamPayload {
        static instance: TestStreamPayload = TestStreamPayload {
            coder_id: ::std::string::String::new(),
            events: ::std::vec::Vec::new(),
            endpoint: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestStreamPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestStreamPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestStreamPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestStreamPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TestStreamPayload`
pub mod test_stream_payload {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event)
    pub struct Event {
        // message oneof groups
        pub event: ::std::option::Option<event::Event>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event {
        fn default() -> &'a Event {
            <Event as ::protobuf::Message>::default_instance()
        }
    }

    impl Event {
        pub fn new() -> Event {
            ::std::default::Default::default()
        }

        // .org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceWatermark watermark_event = 1;

        pub fn watermark_event(&self) -> &event::AdvanceWatermark {
            match self.event {
                ::std::option::Option::Some(event::Event::WatermarkEvent(ref v)) => v,
                _ => <event::AdvanceWatermark as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_watermark_event(&mut self) {
            self.event = ::std::option::Option::None;
        }

        pub fn has_watermark_event(&self) -> bool {
            match self.event {
                ::std::option::Option::Some(event::Event::WatermarkEvent(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_watermark_event(&mut self, v: event::AdvanceWatermark) {
            self.event = ::std::option::Option::Some(event::Event::WatermarkEvent(v))
        }

        // Mutable pointer to the field.
        pub fn mut_watermark_event(&mut self) -> &mut event::AdvanceWatermark {
            if let ::std::option::Option::Some(event::Event::WatermarkEvent(_)) = self.event {
            } else {
                self.event = ::std::option::Option::Some(event::Event::WatermarkEvent(event::AdvanceWatermark::new()));
            }
            match self.event {
                ::std::option::Option::Some(event::Event::WatermarkEvent(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_watermark_event(&mut self) -> event::AdvanceWatermark {
            if self.has_watermark_event() {
                match self.event.take() {
                    ::std::option::Option::Some(event::Event::WatermarkEvent(v)) => v,
                    _ => panic!(),
                }
            } else {
                event::AdvanceWatermark::new()
            }
        }

        // .org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceProcessingTime processing_time_event = 2;

        pub fn processing_time_event(&self) -> &event::AdvanceProcessingTime {
            match self.event {
                ::std::option::Option::Some(event::Event::ProcessingTimeEvent(ref v)) => v,
                _ => <event::AdvanceProcessingTime as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_processing_time_event(&mut self) {
            self.event = ::std::option::Option::None;
        }

        pub fn has_processing_time_event(&self) -> bool {
            match self.event {
                ::std::option::Option::Some(event::Event::ProcessingTimeEvent(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_processing_time_event(&mut self, v: event::AdvanceProcessingTime) {
            self.event = ::std::option::Option::Some(event::Event::ProcessingTimeEvent(v))
        }

        // Mutable pointer to the field.
        pub fn mut_processing_time_event(&mut self) -> &mut event::AdvanceProcessingTime {
            if let ::std::option::Option::Some(event::Event::ProcessingTimeEvent(_)) = self.event {
            } else {
                self.event = ::std::option::Option::Some(event::Event::ProcessingTimeEvent(event::AdvanceProcessingTime::new()));
            }
            match self.event {
                ::std::option::Option::Some(event::Event::ProcessingTimeEvent(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_processing_time_event(&mut self) -> event::AdvanceProcessingTime {
            if self.has_processing_time_event() {
                match self.event.take() {
                    ::std::option::Option::Some(event::Event::ProcessingTimeEvent(v)) => v,
                    _ => panic!(),
                }
            } else {
                event::AdvanceProcessingTime::new()
            }
        }

        // .org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElements element_event = 3;

        pub fn element_event(&self) -> &event::AddElements {
            match self.event {
                ::std::option::Option::Some(event::Event::ElementEvent(ref v)) => v,
                _ => <event::AddElements as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_element_event(&mut self) {
            self.event = ::std::option::Option::None;
        }

        pub fn has_element_event(&self) -> bool {
            match self.event {
                ::std::option::Option::Some(event::Event::ElementEvent(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_element_event(&mut self, v: event::AddElements) {
            self.event = ::std::option::Option::Some(event::Event::ElementEvent(v))
        }

        // Mutable pointer to the field.
        pub fn mut_element_event(&mut self) -> &mut event::AddElements {
            if let ::std::option::Option::Some(event::Event::ElementEvent(_)) = self.event {
            } else {
                self.event = ::std::option::Option::Some(event::Event::ElementEvent(event::AddElements::new()));
            }
            match self.event {
                ::std::option::Option::Some(event::Event::ElementEvent(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_element_event(&mut self) -> event::AddElements {
            if self.has_element_event() {
                match self.event.take() {
                    ::std::option::Option::Some(event::Event::ElementEvent(v)) => v,
                    _ => panic!(),
                }
            } else {
                event::AddElements::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, event::AdvanceWatermark>(
                "watermark_event",
                Event::has_watermark_event,
                Event::watermark_event,
                Event::mut_watermark_event,
                Event::set_watermark_event,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, event::AdvanceProcessingTime>(
                "processing_time_event",
                Event::has_processing_time_event,
                Event::processing_time_event,
                Event::mut_processing_time_event,
                Event::set_processing_time_event,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, event::AddElements>(
                "element_event",
                Event::has_element_event,
                Event::element_event,
                Event::mut_element_event,
                Event::set_element_event,
            ));
            oneofs.push(event::Event::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
                "TestStreamPayload.Event",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Event {
        const NAME: &'static str = "Event";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.event = ::std::option::Option::Some(event::Event::WatermarkEvent(is.read_message()?));
                    },
                    18 => {
                        self.event = ::std::option::Option::Some(event::Event::ProcessingTimeEvent(is.read_message()?));
                    },
                    26 => {
                        self.event = ::std::option::Option::Some(event::Event::ElementEvent(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.event {
                match v {
                    &event::Event::WatermarkEvent(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &event::Event::ProcessingTimeEvent(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &event::Event::ElementEvent(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.event {
                match v {
                    &event::Event::WatermarkEvent(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &event::Event::ProcessingTimeEvent(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &event::Event::ElementEvent(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event {
            Event::new()
        }

        fn clear(&mut self) {
            self.event = ::std::option::Option::None;
            self.event = ::std::option::Option::None;
            self.event = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event {
            static instance: Event = Event {
                event: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Event {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestStreamPayload.Event").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Event {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Event`
    pub mod event {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.event)
        pub enum Event {
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.watermark_event)
            WatermarkEvent(AdvanceWatermark),
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.processing_time_event)
            ProcessingTimeEvent(AdvanceProcessingTime),
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.element_event)
            ElementEvent(AddElements),
        }

        impl ::protobuf::Oneof for Event {
        }

        impl ::protobuf::OneofFull for Event {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Event as ::protobuf::MessageFull>::descriptor().oneof_by_name("event").unwrap()).clone()
            }
        }

        impl Event {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Event>("event")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceWatermark)
        pub struct AdvanceWatermark {
            // message fields
            // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceWatermark.new_watermark)
            pub new_watermark: i64,
            // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceWatermark.tag)
            pub tag: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceWatermark.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AdvanceWatermark {
            fn default() -> &'a AdvanceWatermark {
                <AdvanceWatermark as ::protobuf::Message>::default_instance()
            }
        }

        impl AdvanceWatermark {
            pub fn new() -> AdvanceWatermark {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "new_watermark",
                    |m: &AdvanceWatermark| { &m.new_watermark },
                    |m: &mut AdvanceWatermark| { &mut m.new_watermark },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tag",
                    |m: &AdvanceWatermark| { &m.tag },
                    |m: &mut AdvanceWatermark| { &mut m.tag },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdvanceWatermark>(
                    "TestStreamPayload.Event.AdvanceWatermark",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AdvanceWatermark {
            const NAME: &'static str = "AdvanceWatermark";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.new_watermark = is.read_int64()?;
                        },
                        18 => {
                            self.tag = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.new_watermark != 0 {
                    my_size += ::protobuf::rt::int64_size(1, self.new_watermark);
                }
                if !self.tag.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.tag);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.new_watermark != 0 {
                    os.write_int64(1, self.new_watermark)?;
                }
                if !self.tag.is_empty() {
                    os.write_string(2, &self.tag)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AdvanceWatermark {
                AdvanceWatermark::new()
            }

            fn clear(&mut self) {
                self.new_watermark = 0;
                self.tag.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AdvanceWatermark {
                static instance: AdvanceWatermark = AdvanceWatermark {
                    new_watermark: 0,
                    tag: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AdvanceWatermark {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TestStreamPayload.Event.AdvanceWatermark").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AdvanceWatermark {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AdvanceWatermark {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceProcessingTime)
        pub struct AdvanceProcessingTime {
            // message fields
            // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceProcessingTime.advance_duration)
            pub advance_duration: i64,
            // special fields
            // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AdvanceProcessingTime.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AdvanceProcessingTime {
            fn default() -> &'a AdvanceProcessingTime {
                <AdvanceProcessingTime as ::protobuf::Message>::default_instance()
            }
        }

        impl AdvanceProcessingTime {
            pub fn new() -> AdvanceProcessingTime {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "advance_duration",
                    |m: &AdvanceProcessingTime| { &m.advance_duration },
                    |m: &mut AdvanceProcessingTime| { &mut m.advance_duration },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdvanceProcessingTime>(
                    "TestStreamPayload.Event.AdvanceProcessingTime",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AdvanceProcessingTime {
            const NAME: &'static str = "AdvanceProcessingTime";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.advance_duration = is.read_int64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.advance_duration != 0 {
                    my_size += ::protobuf::rt::int64_size(1, self.advance_duration);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.advance_duration != 0 {
                    os.write_int64(1, self.advance_duration)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AdvanceProcessingTime {
                AdvanceProcessingTime::new()
            }

            fn clear(&mut self) {
                self.advance_duration = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AdvanceProcessingTime {
                static instance: AdvanceProcessingTime = AdvanceProcessingTime {
                    advance_duration: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AdvanceProcessingTime {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TestStreamPayload.Event.AdvanceProcessingTime").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AdvanceProcessingTime {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AdvanceProcessingTime {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElements)
        pub struct AddElements {
            // message fields
            // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElements.elements)
            pub elements: ::std::vec::Vec<super::TimestampedElement>,
            // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElements.tag)
            pub tag: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElements.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AddElements {
            fn default() -> &'a AddElements {
                <AddElements as ::protobuf::Message>::default_instance()
            }
        }

        impl AddElements {
            pub fn new() -> AddElements {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "elements",
                    |m: &AddElements| { &m.elements },
                    |m: &mut AddElements| { &mut m.elements },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tag",
                    |m: &AddElements| { &m.tag },
                    |m: &mut AddElements| { &mut m.tag },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddElements>(
                    "TestStreamPayload.Event.AddElements",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AddElements {
            const NAME: &'static str = "AddElements";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.elements.push(is.read_message()?);
                        },
                        26 => {
                            self.tag = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.elements {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if !self.tag.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.tag);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.elements {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                if !self.tag.is_empty() {
                    os.write_string(3, &self.tag)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AddElements {
                AddElements::new()
            }

            fn clear(&mut self) {
                self.elements.clear();
                self.tag.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AddElements {
                static instance: AddElements = AddElements {
                    elements: ::std::vec::Vec::new(),
                    tag: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AddElements {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TestStreamPayload.Event.AddElements").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AddElements {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AddElements {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TestStreamPayload.TimestampedElement)
    pub struct TimestampedElement {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.TimestampedElement.encoded_element)
        pub encoded_element: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TestStreamPayload.TimestampedElement.timestamp)
        pub timestamp: i64,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TestStreamPayload.TimestampedElement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TimestampedElement {
        fn default() -> &'a TimestampedElement {
            <TimestampedElement as ::protobuf::Message>::default_instance()
        }
    }

    impl TimestampedElement {
        pub fn new() -> TimestampedElement {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "encoded_element",
                |m: &TimestampedElement| { &m.encoded_element },
                |m: &mut TimestampedElement| { &mut m.encoded_element },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &TimestampedElement| { &m.timestamp },
                |m: &mut TimestampedElement| { &mut m.timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimestampedElement>(
                "TestStreamPayload.TimestampedElement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TimestampedElement {
        const NAME: &'static str = "TimestampedElement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.encoded_element = is.read_bytes()?;
                    },
                    16 => {
                        self.timestamp = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.encoded_element.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.encoded_element);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.timestamp);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.encoded_element.is_empty() {
                os.write_bytes(1, &self.encoded_element)?;
            }
            if self.timestamp != 0 {
                os.write_int64(2, self.timestamp)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TimestampedElement {
            TimestampedElement::new()
        }

        fn clear(&mut self) {
            self.encoded_element.clear();
            self.timestamp = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TimestampedElement {
            static instance: TimestampedElement = TimestampedElement {
                encoded_element: ::std::vec::Vec::new(),
                timestamp: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TimestampedElement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestStreamPayload.TimestampedElement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TimestampedElement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TimestampedElement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.EventsRequest)
pub struct EventsRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.EventsRequest.output_ids)
    pub output_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.EventsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventsRequest {
    fn default() -> &'a EventsRequest {
        <EventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventsRequest {
    pub fn new() -> EventsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_ids",
            |m: &EventsRequest| { &m.output_ids },
            |m: &mut EventsRequest| { &mut m.output_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventsRequest>(
            "EventsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventsRequest {
    const NAME: &'static str = "EventsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.output_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.output_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventsRequest {
        EventsRequest::new()
    }

    fn clear(&mut self) {
        self.output_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventsRequest {
        static instance: EventsRequest = EventsRequest {
            output_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.WriteFilesPayload)
pub struct WriteFilesPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.sink)
    pub sink: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.format_function)
    pub format_function: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.windowed_writes)
    pub windowed_writes: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.runner_determined_sharding)
    pub runner_determined_sharding: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.side_inputs)
    pub side_inputs: ::std::collections::HashMap<::std::string::String, SideInput>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.WriteFilesPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteFilesPayload {
    fn default() -> &'a WriteFilesPayload {
        <WriteFilesPayload as ::protobuf::Message>::default_instance()
    }
}

impl WriteFilesPayload {
    pub fn new() -> WriteFilesPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "sink",
            |m: &WriteFilesPayload| { &m.sink },
            |m: &mut WriteFilesPayload| { &mut m.sink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "format_function",
            |m: &WriteFilesPayload| { &m.format_function },
            |m: &mut WriteFilesPayload| { &mut m.format_function },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "windowed_writes",
            |m: &WriteFilesPayload| { &m.windowed_writes },
            |m: &mut WriteFilesPayload| { &mut m.windowed_writes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_determined_sharding",
            |m: &WriteFilesPayload| { &m.runner_determined_sharding },
            |m: &mut WriteFilesPayload| { &mut m.runner_determined_sharding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "side_inputs",
            |m: &WriteFilesPayload| { &m.side_inputs },
            |m: &mut WriteFilesPayload| { &mut m.side_inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteFilesPayload>(
            "WriteFilesPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteFilesPayload {
    const NAME: &'static str = "WriteFilesPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sink)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.format_function)?;
                },
                24 => {
                    self.windowed_writes = is.read_bool()?;
                },
                32 => {
                    self.runner_determined_sharding = is.read_bool()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.side_inputs.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.format_function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.windowed_writes != false {
            my_size += 1 + 1;
        }
        if self.runner_determined_sharding != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.side_inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.format_function.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.windowed_writes != false {
            os.write_bool(3, self.windowed_writes)?;
        }
        if self.runner_determined_sharding != false {
            os.write_bool(4, self.runner_determined_sharding)?;
        }
        for (k, v) in &self.side_inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteFilesPayload {
        WriteFilesPayload::new()
    }

    fn clear(&mut self) {
        self.sink.clear();
        self.format_function.clear();
        self.windowed_writes = false;
        self.runner_determined_sharding = false;
        self.side_inputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteFilesPayload {
        static instance: ::protobuf::rt::Lazy<WriteFilesPayload> = ::protobuf::rt::Lazy::new();
        instance.get(WriteFilesPayload::new)
    }
}

impl ::protobuf::MessageFull for WriteFilesPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteFilesPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteFilesPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteFilesPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.PubSubReadPayload)
pub struct PubSubReadPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.topic)
    pub topic: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.subscription)
    pub subscription: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.timestamp_attribute)
    pub timestamp_attribute: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.id_attribute)
    pub id_attribute: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.with_attributes)
    pub with_attributes: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.topic_runtime_overridden)
    pub topic_runtime_overridden: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.subscription_runtime_overridden)
    pub subscription_runtime_overridden: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.PubSubReadPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubSubReadPayload {
    fn default() -> &'a PubSubReadPayload {
        <PubSubReadPayload as ::protobuf::Message>::default_instance()
    }
}

impl PubSubReadPayload {
    pub fn new() -> PubSubReadPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &PubSubReadPayload| { &m.topic },
            |m: &mut PubSubReadPayload| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &PubSubReadPayload| { &m.subscription },
            |m: &mut PubSubReadPayload| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp_attribute",
            |m: &PubSubReadPayload| { &m.timestamp_attribute },
            |m: &mut PubSubReadPayload| { &mut m.timestamp_attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id_attribute",
            |m: &PubSubReadPayload| { &m.id_attribute },
            |m: &mut PubSubReadPayload| { &mut m.id_attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "with_attributes",
            |m: &PubSubReadPayload| { &m.with_attributes },
            |m: &mut PubSubReadPayload| { &mut m.with_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic_runtime_overridden",
            |m: &PubSubReadPayload| { &m.topic_runtime_overridden },
            |m: &mut PubSubReadPayload| { &mut m.topic_runtime_overridden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription_runtime_overridden",
            |m: &PubSubReadPayload| { &m.subscription_runtime_overridden },
            |m: &mut PubSubReadPayload| { &mut m.subscription_runtime_overridden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubSubReadPayload>(
            "PubSubReadPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubSubReadPayload {
    const NAME: &'static str = "PubSubReadPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                18 => {
                    self.subscription = is.read_string()?;
                },
                26 => {
                    self.timestamp_attribute = is.read_string()?;
                },
                34 => {
                    self.id_attribute = is.read_string()?;
                },
                40 => {
                    self.with_attributes = is.read_bool()?;
                },
                50 => {
                    self.topic_runtime_overridden = is.read_string()?;
                },
                58 => {
                    self.subscription_runtime_overridden = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscription);
        }
        if !self.timestamp_attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.timestamp_attribute);
        }
        if !self.id_attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id_attribute);
        }
        if self.with_attributes != false {
            my_size += 1 + 1;
        }
        if !self.topic_runtime_overridden.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.topic_runtime_overridden);
        }
        if !self.subscription_runtime_overridden.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.subscription_runtime_overridden);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if !self.subscription.is_empty() {
            os.write_string(2, &self.subscription)?;
        }
        if !self.timestamp_attribute.is_empty() {
            os.write_string(3, &self.timestamp_attribute)?;
        }
        if !self.id_attribute.is_empty() {
            os.write_string(4, &self.id_attribute)?;
        }
        if self.with_attributes != false {
            os.write_bool(5, self.with_attributes)?;
        }
        if !self.topic_runtime_overridden.is_empty() {
            os.write_string(6, &self.topic_runtime_overridden)?;
        }
        if !self.subscription_runtime_overridden.is_empty() {
            os.write_string(7, &self.subscription_runtime_overridden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubSubReadPayload {
        PubSubReadPayload::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.subscription.clear();
        self.timestamp_attribute.clear();
        self.id_attribute.clear();
        self.with_attributes = false;
        self.topic_runtime_overridden.clear();
        self.subscription_runtime_overridden.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubSubReadPayload {
        static instance: PubSubReadPayload = PubSubReadPayload {
            topic: ::std::string::String::new(),
            subscription: ::std::string::String::new(),
            timestamp_attribute: ::std::string::String::new(),
            id_attribute: ::std::string::String::new(),
            with_attributes: false,
            topic_runtime_overridden: ::std::string::String::new(),
            subscription_runtime_overridden: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubSubReadPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubSubReadPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubSubReadPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubSubReadPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.PubSubWritePayload)
pub struct PubSubWritePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubWritePayload.topic)
    pub topic: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubWritePayload.timestamp_attribute)
    pub timestamp_attribute: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubWritePayload.id_attribute)
    pub id_attribute: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PubSubWritePayload.topic_runtime_overridden)
    pub topic_runtime_overridden: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.PubSubWritePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubSubWritePayload {
    fn default() -> &'a PubSubWritePayload {
        <PubSubWritePayload as ::protobuf::Message>::default_instance()
    }
}

impl PubSubWritePayload {
    pub fn new() -> PubSubWritePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &PubSubWritePayload| { &m.topic },
            |m: &mut PubSubWritePayload| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp_attribute",
            |m: &PubSubWritePayload| { &m.timestamp_attribute },
            |m: &mut PubSubWritePayload| { &mut m.timestamp_attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id_attribute",
            |m: &PubSubWritePayload| { &m.id_attribute },
            |m: &mut PubSubWritePayload| { &mut m.id_attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic_runtime_overridden",
            |m: &PubSubWritePayload| { &m.topic_runtime_overridden },
            |m: &mut PubSubWritePayload| { &mut m.topic_runtime_overridden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubSubWritePayload>(
            "PubSubWritePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubSubWritePayload {
    const NAME: &'static str = "PubSubWritePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                18 => {
                    self.timestamp_attribute = is.read_string()?;
                },
                26 => {
                    self.id_attribute = is.read_string()?;
                },
                34 => {
                    self.topic_runtime_overridden = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if !self.timestamp_attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timestamp_attribute);
        }
        if !self.id_attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id_attribute);
        }
        if !self.topic_runtime_overridden.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.topic_runtime_overridden);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if !self.timestamp_attribute.is_empty() {
            os.write_string(2, &self.timestamp_attribute)?;
        }
        if !self.id_attribute.is_empty() {
            os.write_string(3, &self.id_attribute)?;
        }
        if !self.topic_runtime_overridden.is_empty() {
            os.write_string(4, &self.topic_runtime_overridden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubSubWritePayload {
        PubSubWritePayload::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.timestamp_attribute.clear();
        self.id_attribute.clear();
        self.topic_runtime_overridden.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubSubWritePayload {
        static instance: PubSubWritePayload = PubSubWritePayload {
            topic: ::std::string::String::new(),
            timestamp_attribute: ::std::string::String::new(),
            id_attribute: ::std::string::String::new(),
            topic_runtime_overridden: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubSubWritePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubSubWritePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubSubWritePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubSubWritePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.GroupIntoBatchesPayload)
pub struct GroupIntoBatchesPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.GroupIntoBatchesPayload.batch_size)
    pub batch_size: i64,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.GroupIntoBatchesPayload.batch_size_bytes)
    pub batch_size_bytes: i64,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.GroupIntoBatchesPayload.max_buffering_duration_millis)
    pub max_buffering_duration_millis: i64,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.GroupIntoBatchesPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupIntoBatchesPayload {
    fn default() -> &'a GroupIntoBatchesPayload {
        <GroupIntoBatchesPayload as ::protobuf::Message>::default_instance()
    }
}

impl GroupIntoBatchesPayload {
    pub fn new() -> GroupIntoBatchesPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batch_size",
            |m: &GroupIntoBatchesPayload| { &m.batch_size },
            |m: &mut GroupIntoBatchesPayload| { &mut m.batch_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batch_size_bytes",
            |m: &GroupIntoBatchesPayload| { &m.batch_size_bytes },
            |m: &mut GroupIntoBatchesPayload| { &mut m.batch_size_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_buffering_duration_millis",
            |m: &GroupIntoBatchesPayload| { &m.max_buffering_duration_millis },
            |m: &mut GroupIntoBatchesPayload| { &mut m.max_buffering_duration_millis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupIntoBatchesPayload>(
            "GroupIntoBatchesPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupIntoBatchesPayload {
    const NAME: &'static str = "GroupIntoBatchesPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.batch_size = is.read_int64()?;
                },
                24 => {
                    self.batch_size_bytes = is.read_int64()?;
                },
                16 => {
                    self.max_buffering_duration_millis = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.batch_size);
        }
        if self.batch_size_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.batch_size_bytes);
        }
        if self.max_buffering_duration_millis != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.max_buffering_duration_millis);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.batch_size != 0 {
            os.write_int64(1, self.batch_size)?;
        }
        if self.batch_size_bytes != 0 {
            os.write_int64(3, self.batch_size_bytes)?;
        }
        if self.max_buffering_duration_millis != 0 {
            os.write_int64(2, self.max_buffering_duration_millis)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupIntoBatchesPayload {
        GroupIntoBatchesPayload::new()
    }

    fn clear(&mut self) {
        self.batch_size = 0;
        self.batch_size_bytes = 0;
        self.max_buffering_duration_millis = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupIntoBatchesPayload {
        static instance: GroupIntoBatchesPayload = GroupIntoBatchesPayload {
            batch_size: 0,
            batch_size_bytes: 0,
            max_buffering_duration_millis: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupIntoBatchesPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupIntoBatchesPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupIntoBatchesPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupIntoBatchesPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Coder)
pub struct Coder {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Coder.spec)
    pub spec: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Coder.component_coder_ids)
    pub component_coder_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Coder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Coder {
    fn default() -> &'a Coder {
        <Coder as ::protobuf::Message>::default_instance()
    }
}

impl Coder {
    pub fn new() -> Coder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "spec",
            |m: &Coder| { &m.spec },
            |m: &mut Coder| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "component_coder_ids",
            |m: &Coder| { &m.component_coder_ids },
            |m: &mut Coder| { &mut m.component_coder_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Coder>(
            "Coder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Coder {
    const NAME: &'static str = "Coder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                18 => {
                    self.component_coder_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.component_coder_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.component_coder_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Coder {
        Coder::new()
    }

    fn clear(&mut self) {
        self.spec.clear();
        self.component_coder_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Coder {
        static instance: Coder = Coder {
            spec: ::protobuf::MessageField::none(),
            component_coder_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Coder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Coder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Coder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardCoders)
pub struct StandardCoders {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardCoders.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardCoders {
    fn default() -> &'a StandardCoders {
        <StandardCoders as ::protobuf::Message>::default_instance()
    }
}

impl StandardCoders {
    pub fn new() -> StandardCoders {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardCoders>(
            "StandardCoders",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardCoders {
    const NAME: &'static str = "StandardCoders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardCoders {
        StandardCoders::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardCoders {
        static instance: StandardCoders = StandardCoders {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardCoders {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardCoders").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardCoders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardCoders {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardCoders`
pub mod standard_coders {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardCoders.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.BYTES)
        BYTES = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.STRING_UTF8)
        STRING_UTF8 = 10,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.KV)
        KV = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.BOOL)
        BOOL = 12,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.VARINT)
        VARINT = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.DOUBLE)
        DOUBLE = 11,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.ITERABLE)
        ITERABLE = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.TIMER)
        TIMER = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.INTERVAL_WINDOW)
        INTERVAL_WINDOW = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.LENGTH_PREFIX)
        LENGTH_PREFIX = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.GLOBAL_WINDOW)
        GLOBAL_WINDOW = 7,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.WINDOWED_VALUE)
        WINDOWED_VALUE = 8,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.PARAM_WINDOWED_VALUE)
        PARAM_WINDOWED_VALUE = 14,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.STATE_BACKED_ITERABLE)
        STATE_BACKED_ITERABLE = 9,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.CUSTOM_WINDOW)
        CUSTOM_WINDOW = 16,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.ROW)
        ROW = 13,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.SHARDED_KEY)
        SHARDED_KEY = 15,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardCoders.Enum.NULLABLE)
        NULLABLE = 17,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::BYTES),
                10 => ::std::option::Option::Some(Enum::STRING_UTF8),
                1 => ::std::option::Option::Some(Enum::KV),
                12 => ::std::option::Option::Some(Enum::BOOL),
                2 => ::std::option::Option::Some(Enum::VARINT),
                11 => ::std::option::Option::Some(Enum::DOUBLE),
                3 => ::std::option::Option::Some(Enum::ITERABLE),
                4 => ::std::option::Option::Some(Enum::TIMER),
                5 => ::std::option::Option::Some(Enum::INTERVAL_WINDOW),
                6 => ::std::option::Option::Some(Enum::LENGTH_PREFIX),
                7 => ::std::option::Option::Some(Enum::GLOBAL_WINDOW),
                8 => ::std::option::Option::Some(Enum::WINDOWED_VALUE),
                14 => ::std::option::Option::Some(Enum::PARAM_WINDOWED_VALUE),
                9 => ::std::option::Option::Some(Enum::STATE_BACKED_ITERABLE),
                16 => ::std::option::Option::Some(Enum::CUSTOM_WINDOW),
                13 => ::std::option::Option::Some(Enum::ROW),
                15 => ::std::option::Option::Some(Enum::SHARDED_KEY),
                17 => ::std::option::Option::Some(Enum::NULLABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::BYTES,
            Enum::STRING_UTF8,
            Enum::KV,
            Enum::BOOL,
            Enum::VARINT,
            Enum::DOUBLE,
            Enum::ITERABLE,
            Enum::TIMER,
            Enum::INTERVAL_WINDOW,
            Enum::LENGTH_PREFIX,
            Enum::GLOBAL_WINDOW,
            Enum::WINDOWED_VALUE,
            Enum::PARAM_WINDOWED_VALUE,
            Enum::STATE_BACKED_ITERABLE,
            Enum::CUSTOM_WINDOW,
            Enum::ROW,
            Enum::SHARDED_KEY,
            Enum::NULLABLE,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardCoders.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Enum::BYTES => 0,
                Enum::STRING_UTF8 => 1,
                Enum::KV => 2,
                Enum::BOOL => 3,
                Enum::VARINT => 4,
                Enum::DOUBLE => 5,
                Enum::ITERABLE => 6,
                Enum::TIMER => 7,
                Enum::INTERVAL_WINDOW => 8,
                Enum::LENGTH_PREFIX => 9,
                Enum::GLOBAL_WINDOW => 10,
                Enum::WINDOWED_VALUE => 11,
                Enum::PARAM_WINDOWED_VALUE => 12,
                Enum::STATE_BACKED_ITERABLE => 13,
                Enum::CUSTOM_WINDOW => 14,
                Enum::ROW => 15,
                Enum::SHARDED_KEY => 16,
                Enum::NULLABLE => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::BYTES
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardCoders.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.WindowingStrategy)
pub struct WindowingStrategy {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.window_fn)
    pub window_fn: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.merge_status)
    pub merge_status: ::protobuf::EnumOrUnknown<merge_status::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.window_coder_id)
    pub window_coder_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.trigger)
    pub trigger: ::protobuf::MessageField<Trigger>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.accumulation_mode)
    pub accumulation_mode: ::protobuf::EnumOrUnknown<accumulation_mode::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.output_time)
    pub output_time: ::protobuf::EnumOrUnknown<output_time::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.closing_behavior)
    pub closing_behavior: ::protobuf::EnumOrUnknown<closing_behavior::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.allowed_lateness)
    pub allowed_lateness: i64,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.on_time_behavior)
    pub on_time_behavior: ::protobuf::EnumOrUnknown<on_time_behavior::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.assigns_to_one_window)
    pub assigns_to_one_window: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.WindowingStrategy.environment_id)
    pub environment_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.WindowingStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowingStrategy {
    fn default() -> &'a WindowingStrategy {
        <WindowingStrategy as ::protobuf::Message>::default_instance()
    }
}

impl WindowingStrategy {
    pub fn new() -> WindowingStrategy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "window_fn",
            |m: &WindowingStrategy| { &m.window_fn },
            |m: &mut WindowingStrategy| { &mut m.window_fn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merge_status",
            |m: &WindowingStrategy| { &m.merge_status },
            |m: &mut WindowingStrategy| { &mut m.merge_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "window_coder_id",
            |m: &WindowingStrategy| { &m.window_coder_id },
            |m: &mut WindowingStrategy| { &mut m.window_coder_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Trigger>(
            "trigger",
            |m: &WindowingStrategy| { &m.trigger },
            |m: &mut WindowingStrategy| { &mut m.trigger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accumulation_mode",
            |m: &WindowingStrategy| { &m.accumulation_mode },
            |m: &mut WindowingStrategy| { &mut m.accumulation_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_time",
            |m: &WindowingStrategy| { &m.output_time },
            |m: &mut WindowingStrategy| { &mut m.output_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closing_behavior",
            |m: &WindowingStrategy| { &m.closing_behavior },
            |m: &mut WindowingStrategy| { &mut m.closing_behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowed_lateness",
            |m: &WindowingStrategy| { &m.allowed_lateness },
            |m: &mut WindowingStrategy| { &mut m.allowed_lateness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "on_time_behavior",
            |m: &WindowingStrategy| { &m.on_time_behavior },
            |m: &mut WindowingStrategy| { &mut m.on_time_behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assigns_to_one_window",
            |m: &WindowingStrategy| { &m.assigns_to_one_window },
            |m: &mut WindowingStrategy| { &mut m.assigns_to_one_window },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "environment_id",
            |m: &WindowingStrategy| { &m.environment_id },
            |m: &mut WindowingStrategy| { &mut m.environment_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowingStrategy>(
            "WindowingStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowingStrategy {
    const NAME: &'static str = "WindowingStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.window_fn)?;
                },
                16 => {
                    self.merge_status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.window_coder_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trigger)?;
                },
                40 => {
                    self.accumulation_mode = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.output_time = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.closing_behavior = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.allowed_lateness = is.read_int64()?;
                },
                72 => {
                    self.on_time_behavior = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.assigns_to_one_window = is.read_bool()?;
                },
                90 => {
                    self.environment_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.window_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.merge_status != ::protobuf::EnumOrUnknown::new(merge_status::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.merge_status.value());
        }
        if !self.window_coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.window_coder_id);
        }
        if let Some(v) = self.trigger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.accumulation_mode != ::protobuf::EnumOrUnknown::new(accumulation_mode::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.accumulation_mode.value());
        }
        if self.output_time != ::protobuf::EnumOrUnknown::new(output_time::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(6, self.output_time.value());
        }
        if self.closing_behavior != ::protobuf::EnumOrUnknown::new(closing_behavior::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(7, self.closing_behavior.value());
        }
        if self.allowed_lateness != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.allowed_lateness);
        }
        if self.on_time_behavior != ::protobuf::EnumOrUnknown::new(on_time_behavior::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(9, self.on_time_behavior.value());
        }
        if self.assigns_to_one_window != false {
            my_size += 1 + 1;
        }
        if !self.environment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.environment_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.window_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.merge_status != ::protobuf::EnumOrUnknown::new(merge_status::Enum::UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.merge_status))?;
        }
        if !self.window_coder_id.is_empty() {
            os.write_string(3, &self.window_coder_id)?;
        }
        if let Some(v) = self.trigger.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.accumulation_mode != ::protobuf::EnumOrUnknown::new(accumulation_mode::Enum::UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.accumulation_mode))?;
        }
        if self.output_time != ::protobuf::EnumOrUnknown::new(output_time::Enum::UNSPECIFIED) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.output_time))?;
        }
        if self.closing_behavior != ::protobuf::EnumOrUnknown::new(closing_behavior::Enum::UNSPECIFIED) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.closing_behavior))?;
        }
        if self.allowed_lateness != 0 {
            os.write_int64(8, self.allowed_lateness)?;
        }
        if self.on_time_behavior != ::protobuf::EnumOrUnknown::new(on_time_behavior::Enum::UNSPECIFIED) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.on_time_behavior))?;
        }
        if self.assigns_to_one_window != false {
            os.write_bool(10, self.assigns_to_one_window)?;
        }
        if !self.environment_id.is_empty() {
            os.write_string(11, &self.environment_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowingStrategy {
        WindowingStrategy::new()
    }

    fn clear(&mut self) {
        self.window_fn.clear();
        self.merge_status = ::protobuf::EnumOrUnknown::new(merge_status::Enum::UNSPECIFIED);
        self.window_coder_id.clear();
        self.trigger.clear();
        self.accumulation_mode = ::protobuf::EnumOrUnknown::new(accumulation_mode::Enum::UNSPECIFIED);
        self.output_time = ::protobuf::EnumOrUnknown::new(output_time::Enum::UNSPECIFIED);
        self.closing_behavior = ::protobuf::EnumOrUnknown::new(closing_behavior::Enum::UNSPECIFIED);
        self.allowed_lateness = 0;
        self.on_time_behavior = ::protobuf::EnumOrUnknown::new(on_time_behavior::Enum::UNSPECIFIED);
        self.assigns_to_one_window = false;
        self.environment_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowingStrategy {
        static instance: WindowingStrategy = WindowingStrategy {
            window_fn: ::protobuf::MessageField::none(),
            merge_status: ::protobuf::EnumOrUnknown::from_i32(0),
            window_coder_id: ::std::string::String::new(),
            trigger: ::protobuf::MessageField::none(),
            accumulation_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            output_time: ::protobuf::EnumOrUnknown::from_i32(0),
            closing_behavior: ::protobuf::EnumOrUnknown::from_i32(0),
            allowed_lateness: 0,
            on_time_behavior: ::protobuf::EnumOrUnknown::from_i32(0),
            assigns_to_one_window: false,
            environment_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowingStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowingStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowingStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowingStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MergeStatus)
pub struct MergeStatus {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MergeStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MergeStatus {
    fn default() -> &'a MergeStatus {
        <MergeStatus as ::protobuf::Message>::default_instance()
    }
}

impl MergeStatus {
    pub fn new() -> MergeStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MergeStatus>(
            "MergeStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MergeStatus {
    const NAME: &'static str = "MergeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MergeStatus {
        MergeStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MergeStatus {
        static instance: MergeStatus = MergeStatus {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MergeStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MergeStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MergeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MergeStatus`
pub mod merge_status {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.MergeStatus.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MergeStatus.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MergeStatus.Enum.NON_MERGING)
        NON_MERGING = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MergeStatus.Enum.NEEDS_MERGE)
        NEEDS_MERGE = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.MergeStatus.Enum.ALREADY_MERGED)
        ALREADY_MERGED = 3,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::NON_MERGING),
                2 => ::std::option::Option::Some(Enum::NEEDS_MERGE),
                3 => ::std::option::Option::Some(Enum::ALREADY_MERGED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::NON_MERGING,
            Enum::NEEDS_MERGE,
            Enum::ALREADY_MERGED,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MergeStatus.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("MergeStatus.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.AccumulationMode)
pub struct AccumulationMode {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.AccumulationMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccumulationMode {
    fn default() -> &'a AccumulationMode {
        <AccumulationMode as ::protobuf::Message>::default_instance()
    }
}

impl AccumulationMode {
    pub fn new() -> AccumulationMode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccumulationMode>(
            "AccumulationMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccumulationMode {
    const NAME: &'static str = "AccumulationMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccumulationMode {
        AccumulationMode::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccumulationMode {
        static instance: AccumulationMode = AccumulationMode {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccumulationMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccumulationMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccumulationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccumulationMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AccumulationMode`
pub mod accumulation_mode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.AccumulationMode.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.AccumulationMode.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.AccumulationMode.Enum.DISCARDING)
        DISCARDING = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.AccumulationMode.Enum.ACCUMULATING)
        ACCUMULATING = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.AccumulationMode.Enum.RETRACTING)
        RETRACTING = 3,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::DISCARDING),
                2 => ::std::option::Option::Some(Enum::ACCUMULATING),
                3 => ::std::option::Option::Some(Enum::RETRACTING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::DISCARDING,
            Enum::ACCUMULATING,
            Enum::RETRACTING,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AccumulationMode.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("AccumulationMode.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ClosingBehavior)
pub struct ClosingBehavior {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ClosingBehavior.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClosingBehavior {
    fn default() -> &'a ClosingBehavior {
        <ClosingBehavior as ::protobuf::Message>::default_instance()
    }
}

impl ClosingBehavior {
    pub fn new() -> ClosingBehavior {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClosingBehavior>(
            "ClosingBehavior",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClosingBehavior {
    const NAME: &'static str = "ClosingBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClosingBehavior {
        ClosingBehavior::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClosingBehavior {
        static instance: ClosingBehavior = ClosingBehavior {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClosingBehavior {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClosingBehavior").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClosingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosingBehavior {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClosingBehavior`
pub mod closing_behavior {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.ClosingBehavior.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.ClosingBehavior.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.ClosingBehavior.Enum.EMIT_ALWAYS)
        EMIT_ALWAYS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.ClosingBehavior.Enum.EMIT_IF_NONEMPTY)
        EMIT_IF_NONEMPTY = 2,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::EMIT_ALWAYS),
                2 => ::std::option::Option::Some(Enum::EMIT_IF_NONEMPTY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::EMIT_ALWAYS,
            Enum::EMIT_IF_NONEMPTY,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClosingBehavior.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("ClosingBehavior.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.OnTimeBehavior)
pub struct OnTimeBehavior {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.OnTimeBehavior.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnTimeBehavior {
    fn default() -> &'a OnTimeBehavior {
        <OnTimeBehavior as ::protobuf::Message>::default_instance()
    }
}

impl OnTimeBehavior {
    pub fn new() -> OnTimeBehavior {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnTimeBehavior>(
            "OnTimeBehavior",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnTimeBehavior {
    const NAME: &'static str = "OnTimeBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnTimeBehavior {
        OnTimeBehavior::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnTimeBehavior {
        static instance: OnTimeBehavior = OnTimeBehavior {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnTimeBehavior {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnTimeBehavior").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnTimeBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnTimeBehavior {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OnTimeBehavior`
pub mod on_time_behavior {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.OnTimeBehavior.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OnTimeBehavior.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OnTimeBehavior.Enum.FIRE_ALWAYS)
        FIRE_ALWAYS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OnTimeBehavior.Enum.FIRE_IF_NONEMPTY)
        FIRE_IF_NONEMPTY = 2,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::FIRE_ALWAYS),
                2 => ::std::option::Option::Some(Enum::FIRE_IF_NONEMPTY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::FIRE_ALWAYS,
            Enum::FIRE_IF_NONEMPTY,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OnTimeBehavior.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("OnTimeBehavior.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.OutputTime)
pub struct OutputTime {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.OutputTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutputTime {
    fn default() -> &'a OutputTime {
        <OutputTime as ::protobuf::Message>::default_instance()
    }
}

impl OutputTime {
    pub fn new() -> OutputTime {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputTime>(
            "OutputTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutputTime {
    const NAME: &'static str = "OutputTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutputTime {
        OutputTime::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutputTime {
        static instance: OutputTime = OutputTime {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutputTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutputTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutputTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OutputTime`
pub mod output_time {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.OutputTime.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OutputTime.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OutputTime.Enum.END_OF_WINDOW)
        END_OF_WINDOW = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OutputTime.Enum.LATEST_IN_PANE)
        LATEST_IN_PANE = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.OutputTime.Enum.EARLIEST_IN_PANE)
        EARLIEST_IN_PANE = 3,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::END_OF_WINDOW),
                2 => ::std::option::Option::Some(Enum::LATEST_IN_PANE),
                3 => ::std::option::Option::Some(Enum::EARLIEST_IN_PANE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::END_OF_WINDOW,
            Enum::LATEST_IN_PANE,
            Enum::EARLIEST_IN_PANE,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OutputTime.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("OutputTime.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TimeDomain)
pub struct TimeDomain {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TimeDomain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeDomain {
    fn default() -> &'a TimeDomain {
        <TimeDomain as ::protobuf::Message>::default_instance()
    }
}

impl TimeDomain {
    pub fn new() -> TimeDomain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeDomain>(
            "TimeDomain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeDomain {
    const NAME: &'static str = "TimeDomain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeDomain {
        TimeDomain::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeDomain {
        static instance: TimeDomain = TimeDomain {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeDomain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeDomain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeDomain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TimeDomain`
pub mod time_domain {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.TimeDomain.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.TimeDomain.Enum.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.TimeDomain.Enum.EVENT_TIME)
        EVENT_TIME = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.TimeDomain.Enum.PROCESSING_TIME)
        PROCESSING_TIME = 2,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                1 => ::std::option::Option::Some(Enum::EVENT_TIME),
                2 => ::std::option::Option::Some(Enum::PROCESSING_TIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::UNSPECIFIED,
            Enum::EVENT_TIME,
            Enum::PROCESSING_TIME,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TimeDomain.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::UNSPECIFIED
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("TimeDomain.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger)
pub struct Trigger {
    // message oneof groups
    pub trigger: ::std::option::Option<trigger::Trigger>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Trigger {
    fn default() -> &'a Trigger {
        <Trigger as ::protobuf::Message>::default_instance()
    }
}

impl Trigger {
    pub fn new() -> Trigger {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterAll after_all = 1;

    pub fn after_all(&self) -> &trigger::AfterAll {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAll(ref v)) => v,
            _ => <trigger::AfterAll as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_all(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_all(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAll(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_all(&mut self, v: trigger::AfterAll) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAll(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_all(&mut self) -> &mut trigger::AfterAll {
        if let ::std::option::Option::Some(trigger::Trigger::AfterAll(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAll(trigger::AfterAll::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAll(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_all(&mut self) -> trigger::AfterAll {
        if self.has_after_all() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterAll(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterAll::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterAny after_any = 2;

    pub fn after_any(&self) -> &trigger::AfterAny {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAny(ref v)) => v,
            _ => <trigger::AfterAny as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_any(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_any(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAny(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_any(&mut self, v: trigger::AfterAny) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAny(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_any(&mut self) -> &mut trigger::AfterAny {
        if let ::std::option::Option::Some(trigger::Trigger::AfterAny(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAny(trigger::AfterAny::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterAny(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_any(&mut self) -> trigger::AfterAny {
        if self.has_after_any() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterAny(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterAny::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterEach after_each = 3;

    pub fn after_each(&self) -> &trigger::AfterEach {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEach(ref v)) => v,
            _ => <trigger::AfterEach as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_each(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_each(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEach(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_each(&mut self, v: trigger::AfterEach) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEach(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_each(&mut self) -> &mut trigger::AfterEach {
        if let ::std::option::Option::Some(trigger::Trigger::AfterEach(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEach(trigger::AfterEach::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEach(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_each(&mut self) -> trigger::AfterEach {
        if self.has_after_each() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterEach(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterEach::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterEndOfWindow after_end_of_window = 4;

    pub fn after_end_of_window(&self) -> &trigger::AfterEndOfWindow {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(ref v)) => v,
            _ => <trigger::AfterEndOfWindow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_end_of_window(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_end_of_window(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_end_of_window(&mut self, v: trigger::AfterEndOfWindow) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_end_of_window(&mut self) -> &mut trigger::AfterEndOfWindow {
        if let ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(trigger::AfterEndOfWindow::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_end_of_window(&mut self) -> trigger::AfterEndOfWindow {
        if self.has_after_end_of_window() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterEndOfWindow::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterProcessingTime after_processing_time = 5;

    pub fn after_processing_time(&self) -> &trigger::AfterProcessingTime {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(ref v)) => v,
            _ => <trigger::AfterProcessingTime as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_processing_time(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_processing_time(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_processing_time(&mut self, v: trigger::AfterProcessingTime) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_processing_time(&mut self) -> &mut trigger::AfterProcessingTime {
        if let ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(trigger::AfterProcessingTime::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_processing_time(&mut self) -> trigger::AfterProcessingTime {
        if self.has_after_processing_time() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterProcessingTime::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.AfterSynchronizedProcessingTime after_synchronized_processing_time = 6;

    pub fn after_synchronized_processing_time(&self) -> &trigger::AfterSynchronizedProcessingTime {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(ref v)) => v,
            _ => <trigger::AfterSynchronizedProcessingTime as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_after_synchronized_processing_time(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_after_synchronized_processing_time(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_after_synchronized_processing_time(&mut self, v: trigger::AfterSynchronizedProcessingTime) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(v))
    }

    // Mutable pointer to the field.
    pub fn mut_after_synchronized_processing_time(&mut self) -> &mut trigger::AfterSynchronizedProcessingTime {
        if let ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(trigger::AfterSynchronizedProcessingTime::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_after_synchronized_processing_time(&mut self) -> trigger::AfterSynchronizedProcessingTime {
        if self.has_after_synchronized_processing_time() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::AfterSynchronizedProcessingTime::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.Always always = 12;

    pub fn always(&self) -> &trigger::Always {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Always(ref v)) => v,
            _ => <trigger::Always as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_always(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_always(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Always(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_always(&mut self, v: trigger::Always) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::Always(v))
    }

    // Mutable pointer to the field.
    pub fn mut_always(&mut self) -> &mut trigger::Always {
        if let ::std::option::Option::Some(trigger::Trigger::Always(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::Always(trigger::Always::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Always(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_always(&mut self) -> trigger::Always {
        if self.has_always() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::Always(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::Always::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.Default default = 7;

    pub fn default(&self) -> &trigger::Default {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Default(ref v)) => v,
            _ => <trigger::Default as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_default(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_default(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Default(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: trigger::Default) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::Default(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default(&mut self) -> &mut trigger::Default {
        if let ::std::option::Option::Some(trigger::Trigger::Default(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::Default(trigger::Default::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Default(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default(&mut self) -> trigger::Default {
        if self.has_default() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::Default(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::Default::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.ElementCount element_count = 8;

    pub fn element_count(&self) -> &trigger::ElementCount {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::ElementCount(ref v)) => v,
            _ => <trigger::ElementCount as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_element_count(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_element_count(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::ElementCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_element_count(&mut self, v: trigger::ElementCount) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::ElementCount(v))
    }

    // Mutable pointer to the field.
    pub fn mut_element_count(&mut self) -> &mut trigger::ElementCount {
        if let ::std::option::Option::Some(trigger::Trigger::ElementCount(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::ElementCount(trigger::ElementCount::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::ElementCount(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_element_count(&mut self) -> trigger::ElementCount {
        if self.has_element_count() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::ElementCount(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::ElementCount::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.Never never = 9;

    pub fn never(&self) -> &trigger::Never {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Never(ref v)) => v,
            _ => <trigger::Never as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_never(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_never(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Never(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_never(&mut self, v: trigger::Never) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::Never(v))
    }

    // Mutable pointer to the field.
    pub fn mut_never(&mut self) -> &mut trigger::Never {
        if let ::std::option::Option::Some(trigger::Trigger::Never(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::Never(trigger::Never::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Never(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_never(&mut self) -> trigger::Never {
        if self.has_never() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::Never(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::Never::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.OrFinally or_finally = 10;

    pub fn or_finally(&self) -> &trigger::OrFinally {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::OrFinally(ref v)) => v,
            _ => <trigger::OrFinally as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_or_finally(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_or_finally(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::OrFinally(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_finally(&mut self, v: trigger::OrFinally) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::OrFinally(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_finally(&mut self) -> &mut trigger::OrFinally {
        if let ::std::option::Option::Some(trigger::Trigger::OrFinally(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::OrFinally(trigger::OrFinally::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::OrFinally(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_finally(&mut self) -> trigger::OrFinally {
        if self.has_or_finally() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::OrFinally(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::OrFinally::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.Trigger.Repeat repeat = 11;

    pub fn repeat(&self) -> &trigger::Repeat {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Repeat(ref v)) => v,
            _ => <trigger::Repeat as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_repeat(&mut self) {
        self.trigger = ::std::option::Option::None;
    }

    pub fn has_repeat(&self) -> bool {
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Repeat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: trigger::Repeat) {
        self.trigger = ::std::option::Option::Some(trigger::Trigger::Repeat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_repeat(&mut self) -> &mut trigger::Repeat {
        if let ::std::option::Option::Some(trigger::Trigger::Repeat(_)) = self.trigger {
        } else {
            self.trigger = ::std::option::Option::Some(trigger::Trigger::Repeat(trigger::Repeat::new()));
        }
        match self.trigger {
            ::std::option::Option::Some(trigger::Trigger::Repeat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_repeat(&mut self) -> trigger::Repeat {
        if self.has_repeat() {
            match self.trigger.take() {
                ::std::option::Option::Some(trigger::Trigger::Repeat(v)) => v,
                _ => panic!(),
            }
        } else {
            trigger::Repeat::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterAll>(
            "after_all",
            Trigger::has_after_all,
            Trigger::after_all,
            Trigger::mut_after_all,
            Trigger::set_after_all,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterAny>(
            "after_any",
            Trigger::has_after_any,
            Trigger::after_any,
            Trigger::mut_after_any,
            Trigger::set_after_any,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterEach>(
            "after_each",
            Trigger::has_after_each,
            Trigger::after_each,
            Trigger::mut_after_each,
            Trigger::set_after_each,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterEndOfWindow>(
            "after_end_of_window",
            Trigger::has_after_end_of_window,
            Trigger::after_end_of_window,
            Trigger::mut_after_end_of_window,
            Trigger::set_after_end_of_window,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterProcessingTime>(
            "after_processing_time",
            Trigger::has_after_processing_time,
            Trigger::after_processing_time,
            Trigger::mut_after_processing_time,
            Trigger::set_after_processing_time,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::AfterSynchronizedProcessingTime>(
            "after_synchronized_processing_time",
            Trigger::has_after_synchronized_processing_time,
            Trigger::after_synchronized_processing_time,
            Trigger::mut_after_synchronized_processing_time,
            Trigger::set_after_synchronized_processing_time,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::Always>(
            "always",
            Trigger::has_always,
            Trigger::always,
            Trigger::mut_always,
            Trigger::set_always,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::Default>(
            "default",
            Trigger::has_default,
            Trigger::default,
            Trigger::mut_default,
            Trigger::set_default,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::ElementCount>(
            "element_count",
            Trigger::has_element_count,
            Trigger::element_count,
            Trigger::mut_element_count,
            Trigger::set_element_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::Never>(
            "never",
            Trigger::has_never,
            Trigger::never,
            Trigger::mut_never,
            Trigger::set_never,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::OrFinally>(
            "or_finally",
            Trigger::has_or_finally,
            Trigger::or_finally,
            Trigger::mut_or_finally,
            Trigger::set_or_finally,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, trigger::Repeat>(
            "repeat",
            Trigger::has_repeat,
            Trigger::repeat,
            Trigger::mut_repeat,
            Trigger::set_repeat,
        ));
        oneofs.push(trigger::Trigger::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Trigger>(
            "Trigger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Trigger {
    const NAME: &'static str = "Trigger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAll(is.read_message()?));
                },
                18 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterAny(is.read_message()?));
                },
                26 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEach(is.read_message()?));
                },
                34 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterEndOfWindow(is.read_message()?));
                },
                42 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterProcessingTime(is.read_message()?));
                },
                50 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::AfterSynchronizedProcessingTime(is.read_message()?));
                },
                98 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::Always(is.read_message()?));
                },
                58 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::Default(is.read_message()?));
                },
                66 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::ElementCount(is.read_message()?));
                },
                74 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::Never(is.read_message()?));
                },
                82 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::OrFinally(is.read_message()?));
                },
                90 => {
                    self.trigger = ::std::option::Option::Some(trigger::Trigger::Repeat(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.trigger {
            match v {
                &trigger::Trigger::AfterAll(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::AfterAny(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::AfterEach(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::AfterEndOfWindow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::AfterProcessingTime(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::AfterSynchronizedProcessingTime(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::Always(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::Default(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::ElementCount(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::Never(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::OrFinally(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &trigger::Trigger::Repeat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.trigger {
            match v {
                &trigger::Trigger::AfterAll(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &trigger::Trigger::AfterAny(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &trigger::Trigger::AfterEach(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &trigger::Trigger::AfterEndOfWindow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &trigger::Trigger::AfterProcessingTime(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &trigger::Trigger::AfterSynchronizedProcessingTime(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &trigger::Trigger::Always(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &trigger::Trigger::Default(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &trigger::Trigger::ElementCount(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &trigger::Trigger::Never(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &trigger::Trigger::OrFinally(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &trigger::Trigger::Repeat(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Trigger {
        Trigger::new()
    }

    fn clear(&mut self) {
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.trigger = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Trigger {
        static instance: Trigger = Trigger {
            trigger: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Trigger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Trigger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Trigger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trigger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Trigger`
pub mod trigger {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.Trigger.trigger)
    pub enum Trigger {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_all)
        AfterAll(AfterAll),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_any)
        AfterAny(AfterAny),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_each)
        AfterEach(AfterEach),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_end_of_window)
        AfterEndOfWindow(AfterEndOfWindow),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_processing_time)
        AfterProcessingTime(AfterProcessingTime),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.after_synchronized_processing_time)
        AfterSynchronizedProcessingTime(AfterSynchronizedProcessingTime),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.always)
        Always(Always),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.default)
        Default(Default),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.element_count)
        ElementCount(ElementCount),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.never)
        Never(Never),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.or_finally)
        OrFinally(OrFinally),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.Trigger.repeat)
        Repeat(Repeat),
    }

    impl ::protobuf::Oneof for Trigger {
    }

    impl ::protobuf::OneofFull for Trigger {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Trigger as ::protobuf::MessageFull>::descriptor().oneof_by_name("trigger").unwrap()).clone()
        }
    }

    impl Trigger {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Trigger>("trigger")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterAll)
    pub struct AfterAll {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterAll.subtriggers)
        pub subtriggers: ::std::vec::Vec<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterAll.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterAll {
        fn default() -> &'a AfterAll {
            <AfterAll as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterAll {
        pub fn new() -> AfterAll {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "subtriggers",
                |m: &AfterAll| { &m.subtriggers },
                |m: &mut AfterAll| { &mut m.subtriggers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterAll>(
                "Trigger.AfterAll",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterAll {
        const NAME: &'static str = "AfterAll";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.subtriggers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.subtriggers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.subtriggers {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterAll {
            AfterAll::new()
        }

        fn clear(&mut self) {
            self.subtriggers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterAll {
            static instance: AfterAll = AfterAll {
                subtriggers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterAll {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterAll").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterAll {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterAll {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterAny)
    pub struct AfterAny {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterAny.subtriggers)
        pub subtriggers: ::std::vec::Vec<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterAny.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterAny {
        fn default() -> &'a AfterAny {
            <AfterAny as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterAny {
        pub fn new() -> AfterAny {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "subtriggers",
                |m: &AfterAny| { &m.subtriggers },
                |m: &mut AfterAny| { &mut m.subtriggers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterAny>(
                "Trigger.AfterAny",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterAny {
        const NAME: &'static str = "AfterAny";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.subtriggers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.subtriggers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.subtriggers {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterAny {
            AfterAny::new()
        }

        fn clear(&mut self) {
            self.subtriggers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterAny {
            static instance: AfterAny = AfterAny {
                subtriggers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterAny {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterAny").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterAny {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterAny {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterEach)
    pub struct AfterEach {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterEach.subtriggers)
        pub subtriggers: ::std::vec::Vec<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterEach.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterEach {
        fn default() -> &'a AfterEach {
            <AfterEach as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterEach {
        pub fn new() -> AfterEach {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "subtriggers",
                |m: &AfterEach| { &m.subtriggers },
                |m: &mut AfterEach| { &mut m.subtriggers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterEach>(
                "Trigger.AfterEach",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterEach {
        const NAME: &'static str = "AfterEach";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.subtriggers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.subtriggers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.subtriggers {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterEach {
            AfterEach::new()
        }

        fn clear(&mut self) {
            self.subtriggers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterEach {
            static instance: AfterEach = AfterEach {
                subtriggers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterEach {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterEach").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterEach {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterEach {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterEndOfWindow)
    pub struct AfterEndOfWindow {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterEndOfWindow.early_firings)
        pub early_firings: ::protobuf::MessageField<super::Trigger>,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterEndOfWindow.late_firings)
        pub late_firings: ::protobuf::MessageField<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterEndOfWindow.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterEndOfWindow {
        fn default() -> &'a AfterEndOfWindow {
            <AfterEndOfWindow as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterEndOfWindow {
        pub fn new() -> AfterEndOfWindow {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Trigger>(
                "early_firings",
                |m: &AfterEndOfWindow| { &m.early_firings },
                |m: &mut AfterEndOfWindow| { &mut m.early_firings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Trigger>(
                "late_firings",
                |m: &AfterEndOfWindow| { &m.late_firings },
                |m: &mut AfterEndOfWindow| { &mut m.late_firings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterEndOfWindow>(
                "Trigger.AfterEndOfWindow",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterEndOfWindow {
        const NAME: &'static str = "AfterEndOfWindow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.early_firings)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.late_firings)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.early_firings.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.late_firings.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.early_firings.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.late_firings.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterEndOfWindow {
            AfterEndOfWindow::new()
        }

        fn clear(&mut self) {
            self.early_firings.clear();
            self.late_firings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterEndOfWindow {
            static instance: AfterEndOfWindow = AfterEndOfWindow {
                early_firings: ::protobuf::MessageField::none(),
                late_firings: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterEndOfWindow {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterEndOfWindow").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterEndOfWindow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterEndOfWindow {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterProcessingTime)
    pub struct AfterProcessingTime {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.AfterProcessingTime.timestamp_transforms)
        pub timestamp_transforms: ::std::vec::Vec<super::TimestampTransform>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterProcessingTime.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterProcessingTime {
        fn default() -> &'a AfterProcessingTime {
            <AfterProcessingTime as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterProcessingTime {
        pub fn new() -> AfterProcessingTime {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "timestamp_transforms",
                |m: &AfterProcessingTime| { &m.timestamp_transforms },
                |m: &mut AfterProcessingTime| { &mut m.timestamp_transforms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterProcessingTime>(
                "Trigger.AfterProcessingTime",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterProcessingTime {
        const NAME: &'static str = "AfterProcessingTime";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.timestamp_transforms.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.timestamp_transforms {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.timestamp_transforms {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterProcessingTime {
            AfterProcessingTime::new()
        }

        fn clear(&mut self) {
            self.timestamp_transforms.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterProcessingTime {
            static instance: AfterProcessingTime = AfterProcessingTime {
                timestamp_transforms: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterProcessingTime {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterProcessingTime").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterProcessingTime {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterProcessingTime {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.AfterSynchronizedProcessingTime)
    pub struct AfterSynchronizedProcessingTime {
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.AfterSynchronizedProcessingTime.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AfterSynchronizedProcessingTime {
        fn default() -> &'a AfterSynchronizedProcessingTime {
            <AfterSynchronizedProcessingTime as ::protobuf::Message>::default_instance()
        }
    }

    impl AfterSynchronizedProcessingTime {
        pub fn new() -> AfterSynchronizedProcessingTime {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AfterSynchronizedProcessingTime>(
                "Trigger.AfterSynchronizedProcessingTime",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AfterSynchronizedProcessingTime {
        const NAME: &'static str = "AfterSynchronizedProcessingTime";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AfterSynchronizedProcessingTime {
            AfterSynchronizedProcessingTime::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AfterSynchronizedProcessingTime {
            static instance: AfterSynchronizedProcessingTime = AfterSynchronizedProcessingTime {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AfterSynchronizedProcessingTime {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.AfterSynchronizedProcessingTime").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AfterSynchronizedProcessingTime {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AfterSynchronizedProcessingTime {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.Default)
    pub struct Default {
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.Default.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Default {
        fn default() -> &'a Default {
            <Default as ::protobuf::Message>::default_instance()
        }
    }

    impl Default {
        pub fn new() -> Default {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Default>(
                "Trigger.Default",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Default {
        const NAME: &'static str = "Default";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Default {
            Default::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Default {
            static instance: Default = Default {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Default {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.Default").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Default {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Default {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.ElementCount)
    pub struct ElementCount {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.ElementCount.element_count)
        pub element_count: i32,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.ElementCount.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ElementCount {
        fn default() -> &'a ElementCount {
            <ElementCount as ::protobuf::Message>::default_instance()
        }
    }

    impl ElementCount {
        pub fn new() -> ElementCount {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "element_count",
                |m: &ElementCount| { &m.element_count },
                |m: &mut ElementCount| { &mut m.element_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ElementCount>(
                "Trigger.ElementCount",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ElementCount {
        const NAME: &'static str = "ElementCount";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.element_count = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.element_count != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.element_count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.element_count != 0 {
                os.write_int32(1, self.element_count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ElementCount {
            ElementCount::new()
        }

        fn clear(&mut self) {
            self.element_count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ElementCount {
            static instance: ElementCount = ElementCount {
                element_count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ElementCount {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.ElementCount").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ElementCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ElementCount {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.Never)
    pub struct Never {
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.Never.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Never {
        fn default() -> &'a Never {
            <Never as ::protobuf::Message>::default_instance()
        }
    }

    impl Never {
        pub fn new() -> Never {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Never>(
                "Trigger.Never",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Never {
        const NAME: &'static str = "Never";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Never {
            Never::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Never {
            static instance: Never = Never {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Never {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.Never").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Never {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Never {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.Always)
    pub struct Always {
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.Always.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Always {
        fn default() -> &'a Always {
            <Always as ::protobuf::Message>::default_instance()
        }
    }

    impl Always {
        pub fn new() -> Always {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Always>(
                "Trigger.Always",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Always {
        const NAME: &'static str = "Always";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Always {
            Always::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Always {
            static instance: Always = Always {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Always {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.Always").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Always {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Always {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.OrFinally)
    pub struct OrFinally {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.OrFinally.main)
        pub main: ::protobuf::MessageField<super::Trigger>,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.OrFinally.finally)
        pub finally: ::protobuf::MessageField<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.OrFinally.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OrFinally {
        fn default() -> &'a OrFinally {
            <OrFinally as ::protobuf::Message>::default_instance()
        }
    }

    impl OrFinally {
        pub fn new() -> OrFinally {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Trigger>(
                "main",
                |m: &OrFinally| { &m.main },
                |m: &mut OrFinally| { &mut m.main },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Trigger>(
                "finally",
                |m: &OrFinally| { &m.finally },
                |m: &mut OrFinally| { &mut m.finally },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrFinally>(
                "Trigger.OrFinally",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OrFinally {
        const NAME: &'static str = "OrFinally";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.main)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.finally)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.main.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.finally.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.main.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.finally.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OrFinally {
            OrFinally::new()
        }

        fn clear(&mut self) {
            self.main.clear();
            self.finally.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OrFinally {
            static instance: OrFinally = OrFinally {
                main: ::protobuf::MessageField::none(),
                finally: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OrFinally {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.OrFinally").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OrFinally {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OrFinally {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Trigger.Repeat)
    pub struct Repeat {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Trigger.Repeat.subtrigger)
        pub subtrigger: ::protobuf::MessageField<super::Trigger>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Trigger.Repeat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Repeat {
        fn default() -> &'a Repeat {
            <Repeat as ::protobuf::Message>::default_instance()
        }
    }

    impl Repeat {
        pub fn new() -> Repeat {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Trigger>(
                "subtrigger",
                |m: &Repeat| { &m.subtrigger },
                |m: &mut Repeat| { &mut m.subtrigger },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Repeat>(
                "Trigger.Repeat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Repeat {
        const NAME: &'static str = "Repeat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.subtrigger)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.subtrigger.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.subtrigger.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Repeat {
            Repeat::new()
        }

        fn clear(&mut self) {
            self.subtrigger.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Repeat {
            static instance: Repeat = Repeat {
                subtrigger: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Repeat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Trigger.Repeat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Repeat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Repeat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TimestampTransform)
pub struct TimestampTransform {
    // message oneof groups
    pub timestamp_transform: ::std::option::Option<timestamp_transform::Timestamp_transform>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TimestampTransform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimestampTransform {
    fn default() -> &'a TimestampTransform {
        <TimestampTransform as ::protobuf::Message>::default_instance()
    }
}

impl TimestampTransform {
    pub fn new() -> TimestampTransform {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.pipeline.v1.TimestampTransform.Delay delay = 1;

    pub fn delay(&self) -> &timestamp_transform::Delay {
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(ref v)) => v,
            _ => <timestamp_transform::Delay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delay(&mut self) {
        self.timestamp_transform = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: timestamp_transform::Delay) {
        self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delay(&mut self) -> &mut timestamp_transform::Delay {
        if let ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(_)) = self.timestamp_transform {
        } else {
            self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(timestamp_transform::Delay::new()));
        }
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delay(&mut self) -> timestamp_transform::Delay {
        if self.has_delay() {
            match self.timestamp_transform.take() {
                ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(v)) => v,
                _ => panic!(),
            }
        } else {
            timestamp_transform::Delay::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.TimestampTransform.AlignTo align_to = 2;

    pub fn align_to(&self) -> &timestamp_transform::AlignTo {
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(ref v)) => v,
            _ => <timestamp_transform::AlignTo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_align_to(&mut self) {
        self.timestamp_transform = ::std::option::Option::None;
    }

    pub fn has_align_to(&self) -> bool {
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_align_to(&mut self, v: timestamp_transform::AlignTo) {
        self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_align_to(&mut self) -> &mut timestamp_transform::AlignTo {
        if let ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(_)) = self.timestamp_transform {
        } else {
            self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(timestamp_transform::AlignTo::new()));
        }
        match self.timestamp_transform {
            ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_align_to(&mut self) -> timestamp_transform::AlignTo {
        if self.has_align_to() {
            match self.timestamp_transform.take() {
                ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(v)) => v,
                _ => panic!(),
            }
        } else {
            timestamp_transform::AlignTo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, timestamp_transform::Delay>(
            "delay",
            TimestampTransform::has_delay,
            TimestampTransform::delay,
            TimestampTransform::mut_delay,
            TimestampTransform::set_delay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, timestamp_transform::AlignTo>(
            "align_to",
            TimestampTransform::has_align_to,
            TimestampTransform::align_to,
            TimestampTransform::mut_align_to,
            TimestampTransform::set_align_to,
        ));
        oneofs.push(timestamp_transform::Timestamp_transform::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimestampTransform>(
            "TimestampTransform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimestampTransform {
    const NAME: &'static str = "TimestampTransform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::Delay(is.read_message()?));
                },
                18 => {
                    self.timestamp_transform = ::std::option::Option::Some(timestamp_transform::Timestamp_transform::AlignTo(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.timestamp_transform {
            match v {
                &timestamp_transform::Timestamp_transform::Delay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &timestamp_transform::Timestamp_transform::AlignTo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.timestamp_transform {
            match v {
                &timestamp_transform::Timestamp_transform::Delay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &timestamp_transform::Timestamp_transform::AlignTo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimestampTransform {
        TimestampTransform::new()
    }

    fn clear(&mut self) {
        self.timestamp_transform = ::std::option::Option::None;
        self.timestamp_transform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimestampTransform {
        static instance: TimestampTransform = TimestampTransform {
            timestamp_transform: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimestampTransform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimestampTransform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimestampTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampTransform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TimestampTransform`
pub mod timestamp_transform {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.TimestampTransform.timestamp_transform)
    pub enum Timestamp_transform {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.TimestampTransform.delay)
        Delay(Delay),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.TimestampTransform.align_to)
        AlignTo(AlignTo),
    }

    impl ::protobuf::Oneof for Timestamp_transform {
    }

    impl ::protobuf::OneofFull for Timestamp_transform {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TimestampTransform as ::protobuf::MessageFull>::descriptor().oneof_by_name("timestamp_transform").unwrap()).clone()
        }
    }

    impl Timestamp_transform {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Timestamp_transform>("timestamp_transform")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TimestampTransform.Delay)
    pub struct Delay {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TimestampTransform.Delay.delay_millis)
        pub delay_millis: i64,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TimestampTransform.Delay.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Delay {
        fn default() -> &'a Delay {
            <Delay as ::protobuf::Message>::default_instance()
        }
    }

    impl Delay {
        pub fn new() -> Delay {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "delay_millis",
                |m: &Delay| { &m.delay_millis },
                |m: &mut Delay| { &mut m.delay_millis },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Delay>(
                "TimestampTransform.Delay",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Delay {
        const NAME: &'static str = "Delay";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.delay_millis = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.delay_millis != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.delay_millis);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.delay_millis != 0 {
                os.write_int64(1, self.delay_millis)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Delay {
            Delay::new()
        }

        fn clear(&mut self) {
            self.delay_millis = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Delay {
            static instance: Delay = Delay {
                delay_millis: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Delay {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TimestampTransform.Delay").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Delay {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Delay {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.TimestampTransform.AlignTo)
    pub struct AlignTo {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TimestampTransform.AlignTo.period)
        pub period: i64,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.TimestampTransform.AlignTo.offset)
        pub offset: i64,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.TimestampTransform.AlignTo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AlignTo {
        fn default() -> &'a AlignTo {
            <AlignTo as ::protobuf::Message>::default_instance()
        }
    }

    impl AlignTo {
        pub fn new() -> AlignTo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "period",
                |m: &AlignTo| { &m.period },
                |m: &mut AlignTo| { &mut m.period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "offset",
                |m: &AlignTo| { &m.offset },
                |m: &mut AlignTo| { &mut m.offset },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlignTo>(
                "TimestampTransform.AlignTo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AlignTo {
        const NAME: &'static str = "AlignTo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    24 => {
                        self.period = is.read_int64()?;
                    },
                    32 => {
                        self.offset = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.period != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.period);
            }
            if self.offset != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.offset);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.period != 0 {
                os.write_int64(3, self.period)?;
            }
            if self.offset != 0 {
                os.write_int64(4, self.offset)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AlignTo {
            AlignTo::new()
        }

        fn clear(&mut self) {
            self.period = 0;
            self.offset = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AlignTo {
            static instance: AlignTo = AlignTo {
                period: 0,
                offset: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AlignTo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TimestampTransform.AlignTo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AlignTo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AlignTo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.SideInput)
pub struct SideInput {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.SideInput.access_pattern)
    pub access_pattern: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.SideInput.view_fn)
    pub view_fn: ::protobuf::MessageField<FunctionSpec>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.SideInput.window_mapping_fn)
    pub window_mapping_fn: ::protobuf::MessageField<FunctionSpec>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.SideInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SideInput {
    fn default() -> &'a SideInput {
        <SideInput as ::protobuf::Message>::default_instance()
    }
}

impl SideInput {
    pub fn new() -> SideInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "access_pattern",
            |m: &SideInput| { &m.access_pattern },
            |m: &mut SideInput| { &mut m.access_pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "view_fn",
            |m: &SideInput| { &m.view_fn },
            |m: &mut SideInput| { &mut m.view_fn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionSpec>(
            "window_mapping_fn",
            |m: &SideInput| { &m.window_mapping_fn },
            |m: &mut SideInput| { &mut m.window_mapping_fn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SideInput>(
            "SideInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SideInput {
    const NAME: &'static str = "SideInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_pattern)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.view_fn)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.window_mapping_fn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_pattern.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.view_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.window_mapping_fn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_pattern.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.view_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.window_mapping_fn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SideInput {
        SideInput::new()
    }

    fn clear(&mut self) {
        self.access_pattern.clear();
        self.view_fn.clear();
        self.window_mapping_fn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SideInput {
        static instance: SideInput = SideInput {
            access_pattern: ::protobuf::MessageField::none(),
            view_fn: ::protobuf::MessageField::none(),
            window_mapping_fn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SideInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SideInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SideInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SideInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardArtifacts)
pub struct StandardArtifacts {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardArtifacts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardArtifacts {
    fn default() -> &'a StandardArtifacts {
        <StandardArtifacts as ::protobuf::Message>::default_instance()
    }
}

impl StandardArtifacts {
    pub fn new() -> StandardArtifacts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardArtifacts>(
            "StandardArtifacts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardArtifacts {
    const NAME: &'static str = "StandardArtifacts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardArtifacts {
        StandardArtifacts::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardArtifacts {
        static instance: StandardArtifacts = StandardArtifacts {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardArtifacts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardArtifacts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardArtifacts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardArtifacts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardArtifacts`
pub mod standard_artifacts {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types)
    pub enum Types {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.FILE)
        FILE = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.URL)
        URL = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.EMBEDDED)
        EMBEDDED = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.PYPI)
        PYPI = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.MAVEN)
        MAVEN = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Types.DEFERRED)
        DEFERRED = 5,
    }

    impl ::protobuf::Enum for Types {
        const NAME: &'static str = "Types";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Types> {
            match value {
                0 => ::std::option::Option::Some(Types::FILE),
                1 => ::std::option::Option::Some(Types::URL),
                2 => ::std::option::Option::Some(Types::EMBEDDED),
                3 => ::std::option::Option::Some(Types::PYPI),
                4 => ::std::option::Option::Some(Types::MAVEN),
                5 => ::std::option::Option::Some(Types::DEFERRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Types] = &[
            Types::FILE,
            Types::URL,
            Types::EMBEDDED,
            Types::PYPI,
            Types::MAVEN,
            Types::DEFERRED,
        ];
    }

    impl ::protobuf::EnumFull for Types {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardArtifacts.Types").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Types {
        fn default() -> Self {
            Types::FILE
        }
    }

    impl Types {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Types>("StandardArtifacts.Types")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardArtifacts.Roles)
    pub enum Roles {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Roles.STAGING_TO)
        STAGING_TO = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Roles.PIP_REQUIREMENTS_FILE)
        PIP_REQUIREMENTS_FILE = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardArtifacts.Roles.GO_WORKER_BINARY)
        GO_WORKER_BINARY = 2,
    }

    impl ::protobuf::Enum for Roles {
        const NAME: &'static str = "Roles";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Roles> {
            match value {
                0 => ::std::option::Option::Some(Roles::STAGING_TO),
                1 => ::std::option::Option::Some(Roles::PIP_REQUIREMENTS_FILE),
                2 => ::std::option::Option::Some(Roles::GO_WORKER_BINARY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Roles] = &[
            Roles::STAGING_TO,
            Roles::PIP_REQUIREMENTS_FILE,
            Roles::GO_WORKER_BINARY,
        ];
    }

    impl ::protobuf::EnumFull for Roles {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardArtifacts.Roles").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Roles {
        fn default() -> Self {
            Roles::STAGING_TO
        }
    }

    impl Roles {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Roles>("StandardArtifacts.Roles")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ArtifactFilePayload)
pub struct ArtifactFilePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactFilePayload.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactFilePayload.sha256)
    pub sha256: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ArtifactFilePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactFilePayload {
    fn default() -> &'a ArtifactFilePayload {
        <ArtifactFilePayload as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactFilePayload {
    pub fn new() -> ArtifactFilePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ArtifactFilePayload| { &m.path },
            |m: &mut ArtifactFilePayload| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sha256",
            |m: &ArtifactFilePayload| { &m.sha256 },
            |m: &mut ArtifactFilePayload| { &mut m.sha256 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactFilePayload>(
            "ArtifactFilePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactFilePayload {
    const NAME: &'static str = "ArtifactFilePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.sha256 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sha256);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.sha256.is_empty() {
            os.write_string(2, &self.sha256)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactFilePayload {
        ArtifactFilePayload::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.sha256.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactFilePayload {
        static instance: ArtifactFilePayload = ArtifactFilePayload {
            path: ::std::string::String::new(),
            sha256: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactFilePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactFilePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactFilePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactFilePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ArtifactUrlPayload)
pub struct ArtifactUrlPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactUrlPayload.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactUrlPayload.sha256)
    pub sha256: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ArtifactUrlPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactUrlPayload {
    fn default() -> &'a ArtifactUrlPayload {
        <ArtifactUrlPayload as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactUrlPayload {
    pub fn new() -> ArtifactUrlPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &ArtifactUrlPayload| { &m.url },
            |m: &mut ArtifactUrlPayload| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sha256",
            |m: &ArtifactUrlPayload| { &m.sha256 },
            |m: &mut ArtifactUrlPayload| { &mut m.sha256 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactUrlPayload>(
            "ArtifactUrlPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactUrlPayload {
    const NAME: &'static str = "ArtifactUrlPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    self.sha256 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sha256);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.sha256.is_empty() {
            os.write_string(2, &self.sha256)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactUrlPayload {
        ArtifactUrlPayload::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.sha256.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactUrlPayload {
        static instance: ArtifactUrlPayload = ArtifactUrlPayload {
            url: ::std::string::String::new(),
            sha256: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactUrlPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactUrlPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactUrlPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactUrlPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.EmbeddedFilePayload)
pub struct EmbeddedFilePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.EmbeddedFilePayload.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.EmbeddedFilePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmbeddedFilePayload {
    fn default() -> &'a EmbeddedFilePayload {
        <EmbeddedFilePayload as ::protobuf::Message>::default_instance()
    }
}

impl EmbeddedFilePayload {
    pub fn new() -> EmbeddedFilePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &EmbeddedFilePayload| { &m.data },
            |m: &mut EmbeddedFilePayload| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmbeddedFilePayload>(
            "EmbeddedFilePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmbeddedFilePayload {
    const NAME: &'static str = "EmbeddedFilePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmbeddedFilePayload {
        EmbeddedFilePayload::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmbeddedFilePayload {
        static instance: EmbeddedFilePayload = EmbeddedFilePayload {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmbeddedFilePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmbeddedFilePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmbeddedFilePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmbeddedFilePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.PyPIPayload)
pub struct PyPIPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PyPIPayload.artifact_id)
    pub artifact_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.PyPIPayload.version)
    pub version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.PyPIPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PyPIPayload {
    fn default() -> &'a PyPIPayload {
        <PyPIPayload as ::protobuf::Message>::default_instance()
    }
}

impl PyPIPayload {
    pub fn new() -> PyPIPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "artifact_id",
            |m: &PyPIPayload| { &m.artifact_id },
            |m: &mut PyPIPayload| { &mut m.artifact_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &PyPIPayload| { &m.version },
            |m: &mut PyPIPayload| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PyPIPayload>(
            "PyPIPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PyPIPayload {
    const NAME: &'static str = "PyPIPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artifact_id = is.read_string()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.artifact_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.artifact_id);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.artifact_id.is_empty() {
            os.write_string(1, &self.artifact_id)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PyPIPayload {
        PyPIPayload::new()
    }

    fn clear(&mut self) {
        self.artifact_id.clear();
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PyPIPayload {
        static instance: PyPIPayload = PyPIPayload {
            artifact_id: ::std::string::String::new(),
            version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PyPIPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PyPIPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PyPIPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PyPIPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MavenPayload)
pub struct MavenPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MavenPayload.artifact)
    pub artifact: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MavenPayload.repository_url)
    pub repository_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MavenPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MavenPayload {
    fn default() -> &'a MavenPayload {
        <MavenPayload as ::protobuf::Message>::default_instance()
    }
}

impl MavenPayload {
    pub fn new() -> MavenPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "artifact",
            |m: &MavenPayload| { &m.artifact },
            |m: &mut MavenPayload| { &mut m.artifact },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "repository_url",
            |m: &MavenPayload| { &m.repository_url },
            |m: &mut MavenPayload| { &mut m.repository_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MavenPayload>(
            "MavenPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MavenPayload {
    const NAME: &'static str = "MavenPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artifact = is.read_string()?;
                },
                18 => {
                    self.repository_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.artifact.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.artifact);
        }
        if !self.repository_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.repository_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.artifact.is_empty() {
            os.write_string(1, &self.artifact)?;
        }
        if !self.repository_url.is_empty() {
            os.write_string(2, &self.repository_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MavenPayload {
        MavenPayload::new()
    }

    fn clear(&mut self) {
        self.artifact.clear();
        self.repository_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MavenPayload {
        static instance: MavenPayload = MavenPayload {
            artifact: ::std::string::String::new(),
            repository_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MavenPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MavenPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MavenPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MavenPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.DeferredArtifactPayload)
pub struct DeferredArtifactPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.DeferredArtifactPayload.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.DeferredArtifactPayload.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.DeferredArtifactPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeferredArtifactPayload {
    fn default() -> &'a DeferredArtifactPayload {
        <DeferredArtifactPayload as ::protobuf::Message>::default_instance()
    }
}

impl DeferredArtifactPayload {
    pub fn new() -> DeferredArtifactPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DeferredArtifactPayload| { &m.key },
            |m: &mut DeferredArtifactPayload| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &DeferredArtifactPayload| { &m.data },
            |m: &mut DeferredArtifactPayload| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeferredArtifactPayload>(
            "DeferredArtifactPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeferredArtifactPayload {
    const NAME: &'static str = "DeferredArtifactPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeferredArtifactPayload {
        DeferredArtifactPayload::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeferredArtifactPayload {
        static instance: DeferredArtifactPayload = DeferredArtifactPayload {
            key: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeferredArtifactPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeferredArtifactPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeferredArtifactPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeferredArtifactPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ArtifactStagingToRolePayload)
pub struct ArtifactStagingToRolePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactStagingToRolePayload.staged_name)
    pub staged_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ArtifactStagingToRolePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactStagingToRolePayload {
    fn default() -> &'a ArtifactStagingToRolePayload {
        <ArtifactStagingToRolePayload as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactStagingToRolePayload {
    pub fn new() -> ArtifactStagingToRolePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "staged_name",
            |m: &ArtifactStagingToRolePayload| { &m.staged_name },
            |m: &mut ArtifactStagingToRolePayload| { &mut m.staged_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactStagingToRolePayload>(
            "ArtifactStagingToRolePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactStagingToRolePayload {
    const NAME: &'static str = "ArtifactStagingToRolePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.staged_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.staged_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.staged_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.staged_name.is_empty() {
            os.write_string(1, &self.staged_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactStagingToRolePayload {
        ArtifactStagingToRolePayload::new()
    }

    fn clear(&mut self) {
        self.staged_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactStagingToRolePayload {
        static instance: ArtifactStagingToRolePayload = ArtifactStagingToRolePayload {
            staged_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactStagingToRolePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactStagingToRolePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactStagingToRolePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactStagingToRolePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ArtifactInformation)
pub struct ArtifactInformation {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactInformation.type_urn)
    pub type_urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactInformation.type_payload)
    pub type_payload: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactInformation.role_urn)
    pub role_urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ArtifactInformation.role_payload)
    pub role_payload: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ArtifactInformation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtifactInformation {
    fn default() -> &'a ArtifactInformation {
        <ArtifactInformation as ::protobuf::Message>::default_instance()
    }
}

impl ArtifactInformation {
    pub fn new() -> ArtifactInformation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_urn",
            |m: &ArtifactInformation| { &m.type_urn },
            |m: &mut ArtifactInformation| { &mut m.type_urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_payload",
            |m: &ArtifactInformation| { &m.type_payload },
            |m: &mut ArtifactInformation| { &mut m.type_payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "role_urn",
            |m: &ArtifactInformation| { &m.role_urn },
            |m: &mut ArtifactInformation| { &mut m.role_urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "role_payload",
            |m: &ArtifactInformation| { &m.role_payload },
            |m: &mut ArtifactInformation| { &mut m.role_payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtifactInformation>(
            "ArtifactInformation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtifactInformation {
    const NAME: &'static str = "ArtifactInformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_urn = is.read_string()?;
                },
                18 => {
                    self.type_payload = is.read_bytes()?;
                },
                26 => {
                    self.role_urn = is.read_string()?;
                },
                34 => {
                    self.role_payload = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_urn.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_urn);
        }
        if !self.type_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.type_payload);
        }
        if !self.role_urn.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.role_urn);
        }
        if !self.role_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.role_payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_urn.is_empty() {
            os.write_string(1, &self.type_urn)?;
        }
        if !self.type_payload.is_empty() {
            os.write_bytes(2, &self.type_payload)?;
        }
        if !self.role_urn.is_empty() {
            os.write_string(3, &self.role_urn)?;
        }
        if !self.role_payload.is_empty() {
            os.write_bytes(4, &self.role_payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtifactInformation {
        ArtifactInformation::new()
    }

    fn clear(&mut self) {
        self.type_urn.clear();
        self.type_payload.clear();
        self.role_urn.clear();
        self.role_payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtifactInformation {
        static instance: ArtifactInformation = ArtifactInformation {
            type_urn: ::std::string::String::new(),
            type_payload: ::std::vec::Vec::new(),
            role_urn: ::std::string::String::new(),
            role_payload: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtifactInformation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtifactInformation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtifactInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtifactInformation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.Environment)
pub struct Environment {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.urn)
    pub urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.payload)
    pub payload: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.display_data)
    pub display_data: ::std::vec::Vec<DisplayData>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.capabilities)
    pub capabilities: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.dependencies)
    pub dependencies: ::std::vec::Vec<ArtifactInformation>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.Environment.resource_hints)
    pub resource_hints: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.Environment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Environment {
    fn default() -> &'a Environment {
        <Environment as ::protobuf::Message>::default_instance()
    }
}

impl Environment {
    pub fn new() -> Environment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "urn",
            |m: &Environment| { &m.urn },
            |m: &mut Environment| { &mut m.urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &Environment| { &m.payload },
            |m: &mut Environment| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_data",
            |m: &Environment| { &m.display_data },
            |m: &mut Environment| { &mut m.display_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "capabilities",
            |m: &Environment| { &m.capabilities },
            |m: &mut Environment| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dependencies",
            |m: &Environment| { &m.dependencies },
            |m: &mut Environment| { &mut m.dependencies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "resource_hints",
            |m: &Environment| { &m.resource_hints },
            |m: &mut Environment| { &mut m.resource_hints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Environment>(
            "Environment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Environment {
    const NAME: &'static str = "Environment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.urn = is.read_string()?;
                },
                26 => {
                    self.payload = is.read_bytes()?;
                },
                34 => {
                    self.display_data.push(is.read_message()?);
                },
                42 => {
                    self.capabilities.push(is.read_string()?);
                },
                50 => {
                    self.dependencies.push(is.read_message()?);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.resource_hints.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.urn.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.urn);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        for value in &self.display_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.capabilities {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.dependencies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.resource_hints {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.urn.is_empty() {
            os.write_string(2, &self.urn)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        for v in &self.display_data {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.capabilities {
            os.write_string(5, &v)?;
        };
        for v in &self.dependencies {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for (k, v) in &self.resource_hints {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Environment {
        Environment::new()
    }

    fn clear(&mut self) {
        self.urn.clear();
        self.payload.clear();
        self.display_data.clear();
        self.capabilities.clear();
        self.dependencies.clear();
        self.resource_hints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Environment {
        static instance: ::protobuf::rt::Lazy<Environment> = ::protobuf::rt::Lazy::new();
        instance.get(Environment::new)
    }
}

impl ::protobuf::MessageFull for Environment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Environment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Environment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Environment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardEnvironments)
pub struct StandardEnvironments {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardEnvironments.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardEnvironments {
    fn default() -> &'a StandardEnvironments {
        <StandardEnvironments as ::protobuf::Message>::default_instance()
    }
}

impl StandardEnvironments {
    pub fn new() -> StandardEnvironments {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardEnvironments>(
            "StandardEnvironments",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardEnvironments {
    const NAME: &'static str = "StandardEnvironments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardEnvironments {
        StandardEnvironments::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardEnvironments {
        static instance: StandardEnvironments = StandardEnvironments {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardEnvironments {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardEnvironments").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardEnvironments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardEnvironments {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardEnvironments`
pub mod standard_environments {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardEnvironments.Environments)
    pub enum Environments {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardEnvironments.Environments.DOCKER)
        DOCKER = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardEnvironments.Environments.PROCESS)
        PROCESS = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardEnvironments.Environments.EXTERNAL)
        EXTERNAL = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardEnvironments.Environments.DEFAULT)
        DEFAULT = 3,
    }

    impl ::protobuf::Enum for Environments {
        const NAME: &'static str = "Environments";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Environments> {
            match value {
                0 => ::std::option::Option::Some(Environments::DOCKER),
                1 => ::std::option::Option::Some(Environments::PROCESS),
                2 => ::std::option::Option::Some(Environments::EXTERNAL),
                3 => ::std::option::Option::Some(Environments::DEFAULT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Environments] = &[
            Environments::DOCKER,
            Environments::PROCESS,
            Environments::EXTERNAL,
            Environments::DEFAULT,
        ];
    }

    impl ::protobuf::EnumFull for Environments {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardEnvironments.Environments").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Environments {
        fn default() -> Self {
            Environments::DOCKER
        }
    }

    impl Environments {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Environments>("StandardEnvironments.Environments")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.DockerPayload)
pub struct DockerPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.DockerPayload.container_image)
    pub container_image: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.DockerPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DockerPayload {
    fn default() -> &'a DockerPayload {
        <DockerPayload as ::protobuf::Message>::default_instance()
    }
}

impl DockerPayload {
    pub fn new() -> DockerPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "container_image",
            |m: &DockerPayload| { &m.container_image },
            |m: &mut DockerPayload| { &mut m.container_image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DockerPayload>(
            "DockerPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DockerPayload {
    const NAME: &'static str = "DockerPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container_image = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.container_image.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_image);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.container_image.is_empty() {
            os.write_string(1, &self.container_image)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DockerPayload {
        DockerPayload::new()
    }

    fn clear(&mut self) {
        self.container_image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DockerPayload {
        static instance: DockerPayload = DockerPayload {
            container_image: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DockerPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DockerPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DockerPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DockerPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ProcessPayload)
pub struct ProcessPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ProcessPayload.os)
    pub os: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ProcessPayload.arch)
    pub arch: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ProcessPayload.command)
    pub command: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ProcessPayload.env)
    pub env: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ProcessPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessPayload {
    fn default() -> &'a ProcessPayload {
        <ProcessPayload as ::protobuf::Message>::default_instance()
    }
}

impl ProcessPayload {
    pub fn new() -> ProcessPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "os",
            |m: &ProcessPayload| { &m.os },
            |m: &mut ProcessPayload| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "arch",
            |m: &ProcessPayload| { &m.arch },
            |m: &mut ProcessPayload| { &mut m.arch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &ProcessPayload| { &m.command },
            |m: &mut ProcessPayload| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "env",
            |m: &ProcessPayload| { &m.env },
            |m: &mut ProcessPayload| { &mut m.env },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessPayload>(
            "ProcessPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessPayload {
    const NAME: &'static str = "ProcessPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.os = is.read_string()?;
                },
                18 => {
                    self.arch = is.read_string()?;
                },
                26 => {
                    self.command = is.read_string()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.env.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.os.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os);
        }
        if !self.arch.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.arch);
        }
        if !self.command.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.command);
        }
        for (k, v) in &self.env {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.os.is_empty() {
            os.write_string(1, &self.os)?;
        }
        if !self.arch.is_empty() {
            os.write_string(2, &self.arch)?;
        }
        if !self.command.is_empty() {
            os.write_string(3, &self.command)?;
        }
        for (k, v) in &self.env {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessPayload {
        ProcessPayload::new()
    }

    fn clear(&mut self) {
        self.os.clear();
        self.arch.clear();
        self.command.clear();
        self.env.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessPayload {
        static instance: ::protobuf::rt::Lazy<ProcessPayload> = ::protobuf::rt::Lazy::new();
        instance.get(ProcessPayload::new)
    }
}

impl ::protobuf::MessageFull for ProcessPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExternalPayload)
pub struct ExternalPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExternalPayload.endpoint)
    pub endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExternalPayload.params)
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExternalPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalPayload {
    fn default() -> &'a ExternalPayload {
        <ExternalPayload as ::protobuf::Message>::default_instance()
    }
}

impl ExternalPayload {
    pub fn new() -> ExternalPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "endpoint",
            |m: &ExternalPayload| { &m.endpoint },
            |m: &mut ExternalPayload| { &mut m.endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "params",
            |m: &ExternalPayload| { &m.params },
            |m: &mut ExternalPayload| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalPayload>(
            "ExternalPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalPayload {
    const NAME: &'static str = "ExternalPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.endpoint)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.params.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalPayload {
        ExternalPayload::new()
    }

    fn clear(&mut self) {
        self.endpoint.clear();
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalPayload {
        static instance: ::protobuf::rt::Lazy<ExternalPayload> = ::protobuf::rt::Lazy::new();
        instance.get(ExternalPayload::new)
    }
}

impl ::protobuf::MessageFull for ExternalPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardProtocols)
pub struct StandardProtocols {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardProtocols.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardProtocols {
    fn default() -> &'a StandardProtocols {
        <StandardProtocols as ::protobuf::Message>::default_instance()
    }
}

impl StandardProtocols {
    pub fn new() -> StandardProtocols {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardProtocols>(
            "StandardProtocols",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardProtocols {
    const NAME: &'static str = "StandardProtocols";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardProtocols {
        StandardProtocols::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardProtocols {
        static instance: StandardProtocols = StandardProtocols {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardProtocols {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardProtocols").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardProtocols {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardProtocols {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardProtocols`
pub mod standard_protocols {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.LEGACY_PROGRESS_REPORTING)
        LEGACY_PROGRESS_REPORTING = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.PROGRESS_REPORTING)
        PROGRESS_REPORTING = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.WORKER_STATUS)
        WORKER_STATUS = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.MULTI_CORE_BUNDLE_PROCESSING)
        MULTI_CORE_BUNDLE_PROCESSING = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.SIBLING_WORKERS)
        SIBLING_WORKERS = 5,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.HARNESS_MONITORING_INFOS)
        HARNESS_MONITORING_INFOS = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.CONTROL_REQUEST_ELEMENTS_EMBEDDING)
        CONTROL_REQUEST_ELEMENTS_EMBEDDING = 6,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardProtocols.Enum.STATE_CACHING)
        STATE_CACHING = 7,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::LEGACY_PROGRESS_REPORTING),
                1 => ::std::option::Option::Some(Enum::PROGRESS_REPORTING),
                2 => ::std::option::Option::Some(Enum::WORKER_STATUS),
                3 => ::std::option::Option::Some(Enum::MULTI_CORE_BUNDLE_PROCESSING),
                5 => ::std::option::Option::Some(Enum::SIBLING_WORKERS),
                4 => ::std::option::Option::Some(Enum::HARNESS_MONITORING_INFOS),
                6 => ::std::option::Option::Some(Enum::CONTROL_REQUEST_ELEMENTS_EMBEDDING),
                7 => ::std::option::Option::Some(Enum::STATE_CACHING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::LEGACY_PROGRESS_REPORTING,
            Enum::PROGRESS_REPORTING,
            Enum::WORKER_STATUS,
            Enum::MULTI_CORE_BUNDLE_PROCESSING,
            Enum::SIBLING_WORKERS,
            Enum::HARNESS_MONITORING_INFOS,
            Enum::CONTROL_REQUEST_ELEMENTS_EMBEDDING,
            Enum::STATE_CACHING,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardProtocols.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Enum::LEGACY_PROGRESS_REPORTING => 0,
                Enum::PROGRESS_REPORTING => 1,
                Enum::WORKER_STATUS => 2,
                Enum::MULTI_CORE_BUNDLE_PROCESSING => 3,
                Enum::SIBLING_WORKERS => 4,
                Enum::HARNESS_MONITORING_INFOS => 5,
                Enum::CONTROL_REQUEST_ELEMENTS_EMBEDDING => 6,
                Enum::STATE_CACHING => 7,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::LEGACY_PROGRESS_REPORTING
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardProtocols.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardRunnerProtocols)
pub struct StandardRunnerProtocols {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardRunnerProtocols.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardRunnerProtocols {
    fn default() -> &'a StandardRunnerProtocols {
        <StandardRunnerProtocols as ::protobuf::Message>::default_instance()
    }
}

impl StandardRunnerProtocols {
    pub fn new() -> StandardRunnerProtocols {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardRunnerProtocols>(
            "StandardRunnerProtocols",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardRunnerProtocols {
    const NAME: &'static str = "StandardRunnerProtocols";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardRunnerProtocols {
        StandardRunnerProtocols::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardRunnerProtocols {
        static instance: StandardRunnerProtocols = StandardRunnerProtocols {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardRunnerProtocols {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardRunnerProtocols").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardRunnerProtocols {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardRunnerProtocols {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardRunnerProtocols`
pub mod standard_runner_protocols {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardRunnerProtocols.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRunnerProtocols.Enum.MONITORING_INFO_SHORT_IDS)
        MONITORING_INFO_SHORT_IDS = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRunnerProtocols.Enum.CONTROL_RESPONSE_ELEMENTS_EMBEDDING)
        CONTROL_RESPONSE_ELEMENTS_EMBEDDING = 6,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::MONITORING_INFO_SHORT_IDS),
                6 => ::std::option::Option::Some(Enum::CONTROL_RESPONSE_ELEMENTS_EMBEDDING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::MONITORING_INFO_SHORT_IDS,
            Enum::CONTROL_RESPONSE_ELEMENTS_EMBEDDING,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardRunnerProtocols.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Enum::MONITORING_INFO_SHORT_IDS => 0,
                Enum::CONTROL_RESPONSE_ELEMENTS_EMBEDDING => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::MONITORING_INFO_SHORT_IDS
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardRunnerProtocols.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardRequirements)
pub struct StandardRequirements {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardRequirements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardRequirements {
    fn default() -> &'a StandardRequirements {
        <StandardRequirements as ::protobuf::Message>::default_instance()
    }
}

impl StandardRequirements {
    pub fn new() -> StandardRequirements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardRequirements>(
            "StandardRequirements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardRequirements {
    const NAME: &'static str = "StandardRequirements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardRequirements {
        StandardRequirements::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardRequirements {
        static instance: StandardRequirements = StandardRequirements {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardRequirements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardRequirements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardRequirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardRequirements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardRequirements`
pub mod standard_requirements {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_STATEFUL_PROCESSING)
        REQUIRES_STATEFUL_PROCESSING = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_BUNDLE_FINALIZATION)
        REQUIRES_BUNDLE_FINALIZATION = 1,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_STABLE_INPUT)
        REQUIRES_STABLE_INPUT = 2,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_TIME_SORTED_INPUT)
        REQUIRES_TIME_SORTED_INPUT = 3,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_SPLITTABLE_DOFN)
        REQUIRES_SPLITTABLE_DOFN = 4,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardRequirements.Enum.REQUIRES_ON_WINDOW_EXPIRATION)
        REQUIRES_ON_WINDOW_EXPIRATION = 5,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::REQUIRES_STATEFUL_PROCESSING),
                1 => ::std::option::Option::Some(Enum::REQUIRES_BUNDLE_FINALIZATION),
                2 => ::std::option::Option::Some(Enum::REQUIRES_STABLE_INPUT),
                3 => ::std::option::Option::Some(Enum::REQUIRES_TIME_SORTED_INPUT),
                4 => ::std::option::Option::Some(Enum::REQUIRES_SPLITTABLE_DOFN),
                5 => ::std::option::Option::Some(Enum::REQUIRES_ON_WINDOW_EXPIRATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::REQUIRES_STATEFUL_PROCESSING,
            Enum::REQUIRES_BUNDLE_FINALIZATION,
            Enum::REQUIRES_STABLE_INPUT,
            Enum::REQUIRES_TIME_SORTED_INPUT,
            Enum::REQUIRES_SPLITTABLE_DOFN,
            Enum::REQUIRES_ON_WINDOW_EXPIRATION,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardRequirements.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::REQUIRES_STATEFUL_PROCESSING
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardRequirements.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.FunctionSpec)
pub struct FunctionSpec {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.FunctionSpec.urn)
    pub urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.FunctionSpec.payload)
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.FunctionSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FunctionSpec {
    fn default() -> &'a FunctionSpec {
        <FunctionSpec as ::protobuf::Message>::default_instance()
    }
}

impl FunctionSpec {
    pub fn new() -> FunctionSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "urn",
            |m: &FunctionSpec| { &m.urn },
            |m: &mut FunctionSpec| { &mut m.urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &FunctionSpec| { &m.payload },
            |m: &mut FunctionSpec| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FunctionSpec>(
            "FunctionSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FunctionSpec {
    const NAME: &'static str = "FunctionSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.urn = is.read_string()?;
                },
                26 => {
                    self.payload = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.urn.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.urn);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.urn.is_empty() {
            os.write_string(1, &self.urn)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FunctionSpec {
        FunctionSpec::new()
    }

    fn clear(&mut self) {
        self.urn.clear();
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FunctionSpec {
        static instance: FunctionSpec = FunctionSpec {
            urn: ::std::string::String::new(),
            payload: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FunctionSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FunctionSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FunctionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardDisplayData)
pub struct StandardDisplayData {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardDisplayData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardDisplayData {
    fn default() -> &'a StandardDisplayData {
        <StandardDisplayData as ::protobuf::Message>::default_instance()
    }
}

impl StandardDisplayData {
    pub fn new() -> StandardDisplayData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardDisplayData>(
            "StandardDisplayData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardDisplayData {
    const NAME: &'static str = "StandardDisplayData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardDisplayData {
        StandardDisplayData::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardDisplayData {
        static instance: StandardDisplayData = StandardDisplayData {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardDisplayData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardDisplayData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardDisplayData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardDisplayData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardDisplayData`
pub mod standard_display_data {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardDisplayData.DisplayData)
    pub enum DisplayData {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardDisplayData.DisplayData.LABELLED)
        LABELLED = 0,
    }

    impl ::protobuf::Enum for DisplayData {
        const NAME: &'static str = "DisplayData";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DisplayData> {
            match value {
                0 => ::std::option::Option::Some(DisplayData::LABELLED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DisplayData] = &[
            DisplayData::LABELLED,
        ];
    }

    impl ::protobuf::EnumFull for DisplayData {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardDisplayData.DisplayData").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DisplayData {
        fn default() -> Self {
            DisplayData::LABELLED
        }
    }

    impl DisplayData {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DisplayData>("StandardDisplayData.DisplayData")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.LabelledPayload)
pub struct LabelledPayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.LabelledPayload.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.LabelledPayload.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.LabelledPayload.namespace)
    pub namespace: ::std::string::String,
    // message oneof groups
    pub value: ::std::option::Option<labelled_payload::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.LabelledPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelledPayload {
    fn default() -> &'a LabelledPayload {
        <LabelledPayload as ::protobuf::Message>::default_instance()
    }
}

impl LabelledPayload {
    pub fn new() -> LabelledPayload {
        ::std::default::Default::default()
    }

    // string string_value = 2;

    pub fn string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::StringValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::StringValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(labelled_payload::Value::StringValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(labelled_payload::Value::StringValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(labelled_payload::Value::StringValue(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::StringValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(labelled_payload::Value::StringValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool bool_value = 3;

    pub fn bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::BoolValue(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::BoolValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(labelled_payload::Value::BoolValue(v))
    }

    // double double_value = 4;

    pub fn double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::DoubleValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::DoubleValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(labelled_payload::Value::DoubleValue(v))
    }

    // int64 int_value = 5;

    pub fn int_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::IntValue(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(labelled_payload::Value::IntValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(labelled_payload::Value::IntValue(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &LabelledPayload| { &m.label },
            |m: &mut LabelledPayload| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string_value",
            LabelledPayload::has_string_value,
            LabelledPayload::string_value,
            LabelledPayload::set_string_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool_value",
            LabelledPayload::has_bool_value,
            LabelledPayload::bool_value,
            LabelledPayload::set_bool_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "double_value",
            LabelledPayload::has_double_value,
            LabelledPayload::double_value,
            LabelledPayload::set_double_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int_value",
            LabelledPayload::has_int_value,
            LabelledPayload::int_value,
            LabelledPayload::set_int_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LabelledPayload| { &m.key },
            |m: &mut LabelledPayload| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &LabelledPayload| { &m.namespace },
            |m: &mut LabelledPayload| { &mut m.namespace },
        ));
        oneofs.push(labelled_payload::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelledPayload>(
            "LabelledPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelledPayload {
    const NAME: &'static str = "LabelledPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                18 => {
                    self.value = ::std::option::Option::Some(labelled_payload::Value::StringValue(is.read_string()?));
                },
                24 => {
                    self.value = ::std::option::Option::Some(labelled_payload::Value::BoolValue(is.read_bool()?));
                },
                33 => {
                    self.value = ::std::option::Option::Some(labelled_payload::Value::DoubleValue(is.read_double()?));
                },
                40 => {
                    self.value = ::std::option::Option::Some(labelled_payload::Value::IntValue(is.read_int64()?));
                },
                50 => {
                    self.key = is.read_string()?;
                },
                58 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.key);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.namespace);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &labelled_payload::Value::StringValue(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &labelled_payload::Value::BoolValue(v) => {
                    my_size += 1 + 1;
                },
                &labelled_payload::Value::DoubleValue(v) => {
                    my_size += 1 + 8;
                },
                &labelled_payload::Value::IntValue(v) => {
                    my_size += ::protobuf::rt::int64_size(5, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.key.is_empty() {
            os.write_string(6, &self.key)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(7, &self.namespace)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &labelled_payload::Value::StringValue(ref v) => {
                    os.write_string(2, v)?;
                },
                &labelled_payload::Value::BoolValue(v) => {
                    os.write_bool(3, v)?;
                },
                &labelled_payload::Value::DoubleValue(v) => {
                    os.write_double(4, v)?;
                },
                &labelled_payload::Value::IntValue(v) => {
                    os.write_int64(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelledPayload {
        LabelledPayload::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.key.clear();
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelledPayload {
        static instance: LabelledPayload = LabelledPayload {
            label: ::std::string::String::new(),
            key: ::std::string::String::new(),
            namespace: ::std::string::String::new(),
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelledPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelledPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelledPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelledPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LabelledPayload`
pub mod labelled_payload {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.LabelledPayload.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.LabelledPayload.string_value)
        StringValue(::std::string::String),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.LabelledPayload.bool_value)
        BoolValue(bool),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.LabelledPayload.double_value)
        DoubleValue(f64),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.LabelledPayload.int_value)
        IntValue(i64),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LabelledPayload as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.DisplayData)
pub struct DisplayData {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.DisplayData.urn)
    pub urn: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.DisplayData.payload)
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.DisplayData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayData {
    fn default() -> &'a DisplayData {
        <DisplayData as ::protobuf::Message>::default_instance()
    }
}

impl DisplayData {
    pub fn new() -> DisplayData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "urn",
            |m: &DisplayData| { &m.urn },
            |m: &mut DisplayData| { &mut m.urn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &DisplayData| { &m.payload },
            |m: &mut DisplayData| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayData>(
            "DisplayData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayData {
    const NAME: &'static str = "DisplayData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.urn = is.read_string()?;
                },
                18 => {
                    self.payload = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.urn.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.urn);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.urn.is_empty() {
            os.write_string(1, &self.urn)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(2, &self.payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayData {
        DisplayData::new()
    }

    fn clear(&mut self) {
        self.urn.clear();
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayData {
        static instance: DisplayData = DisplayData {
            urn: ::std::string::String::new(),
            payload: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.MessageWithComponents)
pub struct MessageWithComponents {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.MessageWithComponents.components)
    pub components: ::protobuf::MessageField<Components>,
    // message oneof groups
    pub root: ::std::option::Option<message_with_components::Root>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageWithComponents {
    fn default() -> &'a MessageWithComponents {
        <MessageWithComponents as ::protobuf::Message>::default_instance()
    }
}

impl MessageWithComponents {
    pub fn new() -> MessageWithComponents {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.pipeline.v1.Coder coder = 2;

    pub fn coder(&self) -> &Coder {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Coder(ref v)) => v,
            _ => <Coder as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_coder(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_coder(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Coder(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coder(&mut self, v: Coder) {
        self.root = ::std::option::Option::Some(message_with_components::Root::Coder(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coder(&mut self) -> &mut Coder {
        if let ::std::option::Option::Some(message_with_components::Root::Coder(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::Coder(Coder::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Coder(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coder(&mut self) -> Coder {
        if self.has_coder() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::Coder(v)) => v,
                _ => panic!(),
            }
        } else {
            Coder::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.CombinePayload combine_payload = 3;

    pub fn combine_payload(&self) -> &CombinePayload {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::CombinePayload(ref v)) => v,
            _ => <CombinePayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine_payload(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_combine_payload(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::CombinePayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_payload(&mut self, v: CombinePayload) {
        self.root = ::std::option::Option::Some(message_with_components::Root::CombinePayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_payload(&mut self) -> &mut CombinePayload {
        if let ::std::option::Option::Some(message_with_components::Root::CombinePayload(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::CombinePayload(CombinePayload::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::CombinePayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_payload(&mut self) -> CombinePayload {
        if self.has_combine_payload() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::CombinePayload(v)) => v,
                _ => panic!(),
            }
        } else {
            CombinePayload::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.FunctionSpec function_spec = 4;

    pub fn function_spec(&self) -> &FunctionSpec {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::FunctionSpec(ref v)) => v,
            _ => <FunctionSpec as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_function_spec(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_function_spec(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::FunctionSpec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function_spec(&mut self, v: FunctionSpec) {
        self.root = ::std::option::Option::Some(message_with_components::Root::FunctionSpec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function_spec(&mut self) -> &mut FunctionSpec {
        if let ::std::option::Option::Some(message_with_components::Root::FunctionSpec(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::FunctionSpec(FunctionSpec::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::FunctionSpec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function_spec(&mut self) -> FunctionSpec {
        if self.has_function_spec() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::FunctionSpec(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionSpec::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.ParDoPayload par_do_payload = 6;

    pub fn par_do_payload(&self) -> &ParDoPayload {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ParDoPayload(ref v)) => v,
            _ => <ParDoPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_par_do_payload(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_par_do_payload(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ParDoPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_par_do_payload(&mut self, v: ParDoPayload) {
        self.root = ::std::option::Option::Some(message_with_components::Root::ParDoPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_par_do_payload(&mut self) -> &mut ParDoPayload {
        if let ::std::option::Option::Some(message_with_components::Root::ParDoPayload(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::ParDoPayload(ParDoPayload::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ParDoPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_par_do_payload(&mut self) -> ParDoPayload {
        if self.has_par_do_payload() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::ParDoPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ParDoPayload::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.PTransform ptransform = 7;

    pub fn ptransform(&self) -> &PTransform {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Ptransform(ref v)) => v,
            _ => <PTransform as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ptransform(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_ptransform(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Ptransform(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ptransform(&mut self, v: PTransform) {
        self.root = ::std::option::Option::Some(message_with_components::Root::Ptransform(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ptransform(&mut self) -> &mut PTransform {
        if let ::std::option::Option::Some(message_with_components::Root::Ptransform(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::Ptransform(PTransform::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Ptransform(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ptransform(&mut self) -> PTransform {
        if self.has_ptransform() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::Ptransform(v)) => v,
                _ => panic!(),
            }
        } else {
            PTransform::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.PCollection pcollection = 8;

    pub fn pcollection(&self) -> &PCollection {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Pcollection(ref v)) => v,
            _ => <PCollection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pcollection(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_pcollection(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Pcollection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pcollection(&mut self, v: PCollection) {
        self.root = ::std::option::Option::Some(message_with_components::Root::Pcollection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pcollection(&mut self) -> &mut PCollection {
        if let ::std::option::Option::Some(message_with_components::Root::Pcollection(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::Pcollection(PCollection::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::Pcollection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pcollection(&mut self) -> PCollection {
        if self.has_pcollection() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::Pcollection(v)) => v,
                _ => panic!(),
            }
        } else {
            PCollection::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.ReadPayload read_payload = 9;

    pub fn read_payload(&self) -> &ReadPayload {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ReadPayload(ref v)) => v,
            _ => <ReadPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_payload(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_read_payload(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ReadPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_payload(&mut self, v: ReadPayload) {
        self.root = ::std::option::Option::Some(message_with_components::Root::ReadPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_payload(&mut self) -> &mut ReadPayload {
        if let ::std::option::Option::Some(message_with_components::Root::ReadPayload(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::ReadPayload(ReadPayload::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::ReadPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_payload(&mut self) -> ReadPayload {
        if self.has_read_payload() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::ReadPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadPayload::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.SideInput side_input = 11;

    pub fn side_input(&self) -> &SideInput {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::SideInput(ref v)) => v,
            _ => <SideInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_side_input(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_side_input(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::SideInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_side_input(&mut self, v: SideInput) {
        self.root = ::std::option::Option::Some(message_with_components::Root::SideInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_side_input(&mut self) -> &mut SideInput {
        if let ::std::option::Option::Some(message_with_components::Root::SideInput(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::SideInput(SideInput::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::SideInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_side_input(&mut self) -> SideInput {
        if self.has_side_input() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::SideInput(v)) => v,
                _ => panic!(),
            }
        } else {
            SideInput::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.WindowIntoPayload window_into_payload = 12;

    pub fn window_into_payload(&self) -> &WindowIntoPayload {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(ref v)) => v,
            _ => <WindowIntoPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_window_into_payload(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_window_into_payload(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window_into_payload(&mut self, v: WindowIntoPayload) {
        self.root = ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window_into_payload(&mut self) -> &mut WindowIntoPayload {
        if let ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(WindowIntoPayload::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window_into_payload(&mut self) -> WindowIntoPayload {
        if self.has_window_into_payload() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowIntoPayload::new()
        }
    }

    // .org.apache.beam.model.pipeline.v1.WindowingStrategy windowing_strategy = 13;

    pub fn windowing_strategy(&self) -> &WindowingStrategy {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(ref v)) => v,
            _ => <WindowingStrategy as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_windowing_strategy(&mut self) {
        self.root = ::std::option::Option::None;
    }

    pub fn has_windowing_strategy(&self) -> bool {
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_windowing_strategy(&mut self, v: WindowingStrategy) {
        self.root = ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_windowing_strategy(&mut self) -> &mut WindowingStrategy {
        if let ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(_)) = self.root {
        } else {
            self.root = ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(WindowingStrategy::new()));
        }
        match self.root {
            ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_windowing_strategy(&mut self) -> WindowingStrategy {
        if self.has_windowing_strategy() {
            match self.root.take() {
                ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowingStrategy::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Components>(
            "components",
            |m: &MessageWithComponents| { &m.components },
            |m: &mut MessageWithComponents| { &mut m.components },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Coder>(
            "coder",
            MessageWithComponents::has_coder,
            MessageWithComponents::coder,
            MessageWithComponents::mut_coder,
            MessageWithComponents::set_coder,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CombinePayload>(
            "combine_payload",
            MessageWithComponents::has_combine_payload,
            MessageWithComponents::combine_payload,
            MessageWithComponents::mut_combine_payload,
            MessageWithComponents::set_combine_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FunctionSpec>(
            "function_spec",
            MessageWithComponents::has_function_spec,
            MessageWithComponents::function_spec,
            MessageWithComponents::mut_function_spec,
            MessageWithComponents::set_function_spec,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ParDoPayload>(
            "par_do_payload",
            MessageWithComponents::has_par_do_payload,
            MessageWithComponents::par_do_payload,
            MessageWithComponents::mut_par_do_payload,
            MessageWithComponents::set_par_do_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PTransform>(
            "ptransform",
            MessageWithComponents::has_ptransform,
            MessageWithComponents::ptransform,
            MessageWithComponents::mut_ptransform,
            MessageWithComponents::set_ptransform,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PCollection>(
            "pcollection",
            MessageWithComponents::has_pcollection,
            MessageWithComponents::pcollection,
            MessageWithComponents::mut_pcollection,
            MessageWithComponents::set_pcollection,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadPayload>(
            "read_payload",
            MessageWithComponents::has_read_payload,
            MessageWithComponents::read_payload,
            MessageWithComponents::mut_read_payload,
            MessageWithComponents::set_read_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SideInput>(
            "side_input",
            MessageWithComponents::has_side_input,
            MessageWithComponents::side_input,
            MessageWithComponents::mut_side_input,
            MessageWithComponents::set_side_input,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WindowIntoPayload>(
            "window_into_payload",
            MessageWithComponents::has_window_into_payload,
            MessageWithComponents::window_into_payload,
            MessageWithComponents::mut_window_into_payload,
            MessageWithComponents::set_window_into_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WindowingStrategy>(
            "windowing_strategy",
            MessageWithComponents::has_windowing_strategy,
            MessageWithComponents::windowing_strategy,
            MessageWithComponents::mut_windowing_strategy,
            MessageWithComponents::set_windowing_strategy,
        ));
        oneofs.push(message_with_components::Root::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageWithComponents>(
            "MessageWithComponents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageWithComponents {
    const NAME: &'static str = "MessageWithComponents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.components)?;
                },
                18 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::Coder(is.read_message()?));
                },
                26 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::CombinePayload(is.read_message()?));
                },
                34 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::FunctionSpec(is.read_message()?));
                },
                50 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::ParDoPayload(is.read_message()?));
                },
                58 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::Ptransform(is.read_message()?));
                },
                66 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::Pcollection(is.read_message()?));
                },
                74 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::ReadPayload(is.read_message()?));
                },
                90 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::SideInput(is.read_message()?));
                },
                98 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::WindowIntoPayload(is.read_message()?));
                },
                106 => {
                    self.root = ::std::option::Option::Some(message_with_components::Root::WindowingStrategy(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.components.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.root {
            match v {
                &message_with_components::Root::Coder(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::CombinePayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::FunctionSpec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::ParDoPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::Ptransform(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::Pcollection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::ReadPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::SideInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::WindowIntoPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_with_components::Root::WindowingStrategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.components.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.root {
            match v {
                &message_with_components::Root::Coder(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &message_with_components::Root::CombinePayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message_with_components::Root::FunctionSpec(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message_with_components::Root::ParDoPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message_with_components::Root::Ptransform(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message_with_components::Root::Pcollection(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &message_with_components::Root::ReadPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &message_with_components::Root::SideInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &message_with_components::Root::WindowIntoPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &message_with_components::Root::WindowingStrategy(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageWithComponents {
        MessageWithComponents::new()
    }

    fn clear(&mut self) {
        self.components.clear();
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.root = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageWithComponents {
        static instance: MessageWithComponents = MessageWithComponents {
            components: ::protobuf::MessageField::none(),
            root: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageWithComponents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageWithComponents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageWithComponents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageWithComponents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MessageWithComponents`
pub mod message_with_components {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.MessageWithComponents.root)
    pub enum Root {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.coder)
        Coder(super::Coder),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.combine_payload)
        CombinePayload(super::CombinePayload),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.function_spec)
        FunctionSpec(super::FunctionSpec),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.par_do_payload)
        ParDoPayload(super::ParDoPayload),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.ptransform)
        Ptransform(super::PTransform),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.pcollection)
        Pcollection(super::PCollection),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.read_payload)
        ReadPayload(super::ReadPayload),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.side_input)
        SideInput(super::SideInput),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.window_into_payload)
        WindowIntoPayload(super::WindowIntoPayload),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.MessageWithComponents.windowing_strategy)
        WindowingStrategy(super::WindowingStrategy),
    }

    impl ::protobuf::Oneof for Root {
    }

    impl ::protobuf::OneofFull for Root {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MessageWithComponents as ::protobuf::MessageFull>::descriptor().oneof_by_name("root").unwrap()).clone()
        }
    }

    impl Root {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Root>("root")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload)
pub struct ExecutableStagePayload {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.environment)
    pub environment: ::protobuf::MessageField<Environment>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.wire_coder_settings)
    pub wire_coder_settings: ::std::vec::Vec<executable_stage_payload::WireCoderSetting>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.input)
    pub input: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.side_inputs)
    pub side_inputs: ::std::vec::Vec<executable_stage_payload::SideInputId>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.transforms)
    pub transforms: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.outputs)
    pub outputs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.components)
    pub components: ::protobuf::MessageField<Components>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.user_states)
    pub user_states: ::std::vec::Vec<executable_stage_payload::UserStateId>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.timers)
    pub timers: ::std::vec::Vec<executable_stage_payload::TimerId>,
    // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.timerFamilies)
    pub timerFamilies: ::std::vec::Vec<executable_stage_payload::TimerFamilyId>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecutableStagePayload {
    fn default() -> &'a ExecutableStagePayload {
        <ExecutableStagePayload as ::protobuf::Message>::default_instance()
    }
}

impl ExecutableStagePayload {
    pub fn new() -> ExecutableStagePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Environment>(
            "environment",
            |m: &ExecutableStagePayload| { &m.environment },
            |m: &mut ExecutableStagePayload| { &mut m.environment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wire_coder_settings",
            |m: &ExecutableStagePayload| { &m.wire_coder_settings },
            |m: &mut ExecutableStagePayload| { &mut m.wire_coder_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &ExecutableStagePayload| { &m.input },
            |m: &mut ExecutableStagePayload| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "side_inputs",
            |m: &ExecutableStagePayload| { &m.side_inputs },
            |m: &mut ExecutableStagePayload| { &mut m.side_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transforms",
            |m: &ExecutableStagePayload| { &m.transforms },
            |m: &mut ExecutableStagePayload| { &mut m.transforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &ExecutableStagePayload| { &m.outputs },
            |m: &mut ExecutableStagePayload| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Components>(
            "components",
            |m: &ExecutableStagePayload| { &m.components },
            |m: &mut ExecutableStagePayload| { &mut m.components },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_states",
            |m: &ExecutableStagePayload| { &m.user_states },
            |m: &mut ExecutableStagePayload| { &mut m.user_states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timers",
            |m: &ExecutableStagePayload| { &m.timers },
            |m: &mut ExecutableStagePayload| { &mut m.timers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timerFamilies",
            |m: &ExecutableStagePayload| { &m.timerFamilies },
            |m: &mut ExecutableStagePayload| { &mut m.timerFamilies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutableStagePayload>(
            "ExecutableStagePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecutableStagePayload {
    const NAME: &'static str = "ExecutableStagePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.environment)?;
                },
                74 => {
                    self.wire_coder_settings.push(is.read_message()?);
                },
                18 => {
                    self.input = is.read_string()?;
                },
                26 => {
                    self.side_inputs.push(is.read_message()?);
                },
                34 => {
                    self.transforms.push(is.read_string()?);
                },
                42 => {
                    self.outputs.push(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.components)?;
                },
                58 => {
                    self.user_states.push(is.read_message()?);
                },
                66 => {
                    self.timers.push(is.read_message()?);
                },
                82 => {
                    self.timerFamilies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.environment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.wire_coder_settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input);
        }
        for value in &self.side_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transforms {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.outputs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.components.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.timers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.timerFamilies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.environment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.wire_coder_settings {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if !self.input.is_empty() {
            os.write_string(2, &self.input)?;
        }
        for v in &self.side_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.transforms {
            os.write_string(4, &v)?;
        };
        for v in &self.outputs {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.components.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.user_states {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.timers {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.timerFamilies {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecutableStagePayload {
        ExecutableStagePayload::new()
    }

    fn clear(&mut self) {
        self.environment.clear();
        self.wire_coder_settings.clear();
        self.input.clear();
        self.side_inputs.clear();
        self.transforms.clear();
        self.outputs.clear();
        self.components.clear();
        self.user_states.clear();
        self.timers.clear();
        self.timerFamilies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecutableStagePayload {
        static instance: ExecutableStagePayload = ExecutableStagePayload {
            environment: ::protobuf::MessageField::none(),
            wire_coder_settings: ::std::vec::Vec::new(),
            input: ::std::string::String::new(),
            side_inputs: ::std::vec::Vec::new(),
            transforms: ::std::vec::Vec::new(),
            outputs: ::std::vec::Vec::new(),
            components: ::protobuf::MessageField::none(),
            user_states: ::std::vec::Vec::new(),
            timers: ::std::vec::Vec::new(),
            timerFamilies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecutableStagePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecutableStagePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecutableStagePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutableStagePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExecutableStagePayload`
pub mod executable_stage_payload {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.SideInputId)
    pub struct SideInputId {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.SideInputId.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.SideInputId.local_name)
        pub local_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.SideInputId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SideInputId {
        fn default() -> &'a SideInputId {
            <SideInputId as ::protobuf::Message>::default_instance()
        }
    }

    impl SideInputId {
        pub fn new() -> SideInputId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &SideInputId| { &m.transform_id },
                |m: &mut SideInputId| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "local_name",
                |m: &SideInputId| { &m.local_name },
                |m: &mut SideInputId| { &mut m.local_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SideInputId>(
                "ExecutableStagePayload.SideInputId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SideInputId {
        const NAME: &'static str = "SideInputId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.local_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.local_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.local_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.local_name.is_empty() {
                os.write_string(2, &self.local_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SideInputId {
            SideInputId::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.local_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SideInputId {
            static instance: SideInputId = SideInputId {
                transform_id: ::std::string::String::new(),
                local_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SideInputId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecutableStagePayload.SideInputId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SideInputId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SideInputId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.UserStateId)
    pub struct UserStateId {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.UserStateId.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.UserStateId.local_name)
        pub local_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.UserStateId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserStateId {
        fn default() -> &'a UserStateId {
            <UserStateId as ::protobuf::Message>::default_instance()
        }
    }

    impl UserStateId {
        pub fn new() -> UserStateId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &UserStateId| { &m.transform_id },
                |m: &mut UserStateId| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "local_name",
                |m: &UserStateId| { &m.local_name },
                |m: &mut UserStateId| { &mut m.local_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserStateId>(
                "ExecutableStagePayload.UserStateId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserStateId {
        const NAME: &'static str = "UserStateId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.local_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.local_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.local_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.local_name.is_empty() {
                os.write_string(2, &self.local_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserStateId {
            UserStateId::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.local_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserStateId {
            static instance: UserStateId = UserStateId {
                transform_id: ::std::string::String::new(),
                local_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserStateId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecutableStagePayload.UserStateId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserStateId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserStateId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerId)
    pub struct TimerId {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerId.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerId.local_name)
        pub local_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TimerId {
        fn default() -> &'a TimerId {
            <TimerId as ::protobuf::Message>::default_instance()
        }
    }

    impl TimerId {
        pub fn new() -> TimerId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &TimerId| { &m.transform_id },
                |m: &mut TimerId| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "local_name",
                |m: &TimerId| { &m.local_name },
                |m: &mut TimerId| { &mut m.local_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimerId>(
                "ExecutableStagePayload.TimerId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TimerId {
        const NAME: &'static str = "TimerId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.local_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.local_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.local_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.local_name.is_empty() {
                os.write_string(2, &self.local_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TimerId {
            TimerId::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.local_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TimerId {
            static instance: TimerId = TimerId {
                transform_id: ::std::string::String::new(),
                local_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TimerId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecutableStagePayload.TimerId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TimerId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TimerId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerFamilyId)
    pub struct TimerFamilyId {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerFamilyId.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerFamilyId.local_name)
        pub local_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerFamilyId.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TimerFamilyId {
        fn default() -> &'a TimerFamilyId {
            <TimerFamilyId as ::protobuf::Message>::default_instance()
        }
    }

    impl TimerFamilyId {
        pub fn new() -> TimerFamilyId {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &TimerFamilyId| { &m.transform_id },
                |m: &mut TimerFamilyId| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "local_name",
                |m: &TimerFamilyId| { &m.local_name },
                |m: &mut TimerFamilyId| { &mut m.local_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimerFamilyId>(
                "ExecutableStagePayload.TimerFamilyId",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TimerFamilyId {
        const NAME: &'static str = "TimerFamilyId";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.local_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.local_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.local_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.local_name.is_empty() {
                os.write_string(2, &self.local_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TimerFamilyId {
            TimerFamilyId::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.local_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TimerFamilyId {
            static instance: TimerFamilyId = TimerFamilyId {
                transform_id: ::std::string::String::new(),
                local_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TimerFamilyId {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecutableStagePayload.TimerFamilyId").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TimerFamilyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TimerFamilyId {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting)
    pub struct WireCoderSetting {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.urn)
        pub urn: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.payload)
        pub payload: ::std::vec::Vec<u8>,
        // message oneof groups
        pub target: ::std::option::Option<wire_coder_setting::Target>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WireCoderSetting {
        fn default() -> &'a WireCoderSetting {
            <WireCoderSetting as ::protobuf::Message>::default_instance()
        }
    }

    impl WireCoderSetting {
        pub fn new() -> WireCoderSetting {
            ::std::default::Default::default()
        }

        // string input_or_output_id = 3;

        pub fn input_or_output_id(&self) -> &str {
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_input_or_output_id(&mut self) {
            self.target = ::std::option::Option::None;
        }

        pub fn has_input_or_output_id(&self) -> bool {
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_input_or_output_id(&mut self, v: ::std::string::String) {
            self.target = ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(v))
        }

        // Mutable pointer to the field.
        pub fn mut_input_or_output_id(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(_)) = self.target {
            } else {
                self.target = ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(::std::string::String::new()));
            }
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_input_or_output_id(&mut self) -> ::std::string::String {
            if self.has_input_or_output_id() {
                match self.target.take() {
                    ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // .org.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerId timer = 4;

        pub fn timer(&self) -> &TimerId {
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::Timer(ref v)) => v,
                _ => <TimerId as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_timer(&mut self) {
            self.target = ::std::option::Option::None;
        }

        pub fn has_timer(&self) -> bool {
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::Timer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_timer(&mut self, v: TimerId) {
            self.target = ::std::option::Option::Some(wire_coder_setting::Target::Timer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_timer(&mut self) -> &mut TimerId {
            if let ::std::option::Option::Some(wire_coder_setting::Target::Timer(_)) = self.target {
            } else {
                self.target = ::std::option::Option::Some(wire_coder_setting::Target::Timer(TimerId::new()));
            }
            match self.target {
                ::std::option::Option::Some(wire_coder_setting::Target::Timer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_timer(&mut self) -> TimerId {
            if self.has_timer() {
                match self.target.take() {
                    ::std::option::Option::Some(wire_coder_setting::Target::Timer(v)) => v,
                    _ => panic!(),
                }
            } else {
                TimerId::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "urn",
                |m: &WireCoderSetting| { &m.urn },
                |m: &mut WireCoderSetting| { &mut m.urn },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "payload",
                |m: &WireCoderSetting| { &m.payload },
                |m: &mut WireCoderSetting| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "input_or_output_id",
                WireCoderSetting::has_input_or_output_id,
                WireCoderSetting::input_or_output_id,
                WireCoderSetting::set_input_or_output_id,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TimerId>(
                "timer",
                WireCoderSetting::has_timer,
                WireCoderSetting::timer,
                WireCoderSetting::mut_timer,
                WireCoderSetting::set_timer,
            ));
            oneofs.push(wire_coder_setting::Target::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WireCoderSetting>(
                "ExecutableStagePayload.WireCoderSetting",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WireCoderSetting {
        const NAME: &'static str = "WireCoderSetting";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.urn = is.read_string()?;
                    },
                    18 => {
                        self.payload = is.read_bytes()?;
                    },
                    26 => {
                        self.target = ::std::option::Option::Some(wire_coder_setting::Target::InputOrOutputId(is.read_string()?));
                    },
                    34 => {
                        self.target = ::std::option::Option::Some(wire_coder_setting::Target::Timer(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.urn.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.urn);
            }
            if !self.payload.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.payload);
            }
            if let ::std::option::Option::Some(ref v) = self.target {
                match v {
                    &wire_coder_setting::Target::InputOrOutputId(ref v) => {
                        my_size += ::protobuf::rt::string_size(3, &v);
                    },
                    &wire_coder_setting::Target::Timer(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.urn.is_empty() {
                os.write_string(1, &self.urn)?;
            }
            if !self.payload.is_empty() {
                os.write_bytes(2, &self.payload)?;
            }
            if let ::std::option::Option::Some(ref v) = self.target {
                match v {
                    &wire_coder_setting::Target::InputOrOutputId(ref v) => {
                        os.write_string(3, v)?;
                    },
                    &wire_coder_setting::Target::Timer(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WireCoderSetting {
            WireCoderSetting::new()
        }

        fn clear(&mut self) {
            self.urn.clear();
            self.payload.clear();
            self.target = ::std::option::Option::None;
            self.target = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WireCoderSetting {
            static instance: WireCoderSetting = WireCoderSetting {
                urn: ::std::string::String::new(),
                payload: ::std::vec::Vec::new(),
                target: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WireCoderSetting {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecutableStagePayload.WireCoderSetting").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WireCoderSetting {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WireCoderSetting {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `WireCoderSetting`
    pub mod wire_coder_setting {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.target)
        pub enum Target {
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.input_or_output_id)
            InputOrOutputId(::std::string::String),
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.pipeline.v1.ExecutableStagePayload.WireCoderSetting.timer)
            Timer(super::TimerId),
        }

        impl ::protobuf::Oneof for Target {
        }

        impl ::protobuf::OneofFull for Target {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::WireCoderSetting as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
            }
        }

        impl Target {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.pipeline.v1.StandardResourceHints)
pub struct StandardResourceHints {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.pipeline.v1.StandardResourceHints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StandardResourceHints {
    fn default() -> &'a StandardResourceHints {
        <StandardResourceHints as ::protobuf::Message>::default_instance()
    }
}

impl StandardResourceHints {
    pub fn new() -> StandardResourceHints {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StandardResourceHints>(
            "StandardResourceHints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StandardResourceHints {
    const NAME: &'static str = "StandardResourceHints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StandardResourceHints {
        StandardResourceHints::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StandardResourceHints {
        static instance: StandardResourceHints = StandardResourceHints {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StandardResourceHints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StandardResourceHints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StandardResourceHints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StandardResourceHints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StandardResourceHints`
pub mod standard_resource_hints {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.apache.beam.model.pipeline.v1.StandardResourceHints.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardResourceHints.Enum.ACCELERATOR)
        ACCELERATOR = 0,
        // @@protoc_insertion_point(enum_value:org.apache.beam.model.pipeline.v1.StandardResourceHints.Enum.MIN_RAM_BYTES)
        MIN_RAM_BYTES = 1,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::ACCELERATOR),
                1 => ::std::option::Option::Some(Enum::MIN_RAM_BYTES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::ACCELERATOR,
            Enum::MIN_RAM_BYTES,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StandardResourceHints.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::ACCELERATOR
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("StandardResourceHints.Enum")
        }
    }
}

/// Extension fields
pub mod exts {

    pub const beam_urn: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(185324356, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);

    pub const beam_constant: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, ::std::string::String> = ::protobuf::ext::ExtFieldOptional::new(185324357, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n7org/apache/beam/model/pipeline/v1/beam_runner_api.proto\x12!org.apach\
    e.beam.model.pipeline.v1\x1a1org/apache/beam/model/pipeline/v1/endpoints\
    .proto\x1a\x20google/protobuf/descriptor.proto\"\xc2\x01\n\rBeamConstant\
    s\"\xb0\x01\n\tConstants\x121\n\x14MIN_TIMESTAMP_MILLIS\x10\0\x1a\x17\
    \xaa\xb4\xfa\xc2\x05\x11-9223372036854775\x120\n\x14MAX_TIMESTAMP_MILLIS\
    \x10\x01\x1a\x16\xaa\xb4\xfa\xc2\x05\x109223372036854775\x12>\n\"GLOBAL_\
    WINDOW_MAX_TIMESTAMP_MILLIS\x10\x02\x1a\x16\xaa\xb4\xfa\xc2\x05\x1092233\
    71950454775\"\xb6\x08\n\nComponents\x12]\n\ntransforms\x18\x01\x20\x03(\
    \x0b2=.org.apache.beam.model.pipeline.v1.Components.TransformsEntryR\ntr\
    ansforms\x12c\n\x0cpcollections\x18\x02\x20\x03(\x0b2?.org.apache.beam.m\
    odel.pipeline.v1.Components.PcollectionsEntryR\x0cpcollections\x12y\n\
    \x14windowing_strategies\x18\x03\x20\x03(\x0b2F.org.apache.beam.model.pi\
    peline.v1.Components.WindowingStrategiesEntryR\x13windowingStrategies\
    \x12Q\n\x06coders\x18\x04\x20\x03(\x0b29.org.apache.beam.model.pipeline.\
    v1.Components.CodersEntryR\x06coders\x12c\n\x0cenvironments\x18\x05\x20\
    \x03(\x0b2?.org.apache.beam.model.pipeline.v1.Components.EnvironmentsEnt\
    ryR\x0cenvironments\x1al\n\x0fTransformsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12C\n\x05value\x18\x02\x20\x01(\x0b2-.org.apache.be\
    am.model.pipeline.v1.PTransformR\x05value:\x028\x01\x1ao\n\x11Pcollectio\
    nsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\
    \x02\x20\x01(\x0b2..org.apache.beam.model.pipeline.v1.PCollectionR\x05va\
    lue:\x028\x01\x1a|\n\x18WindowingStrategiesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12J\n\x05value\x18\x02\x20\x01(\x0b24.org.apach\
    e.beam.model.pipeline.v1.WindowingStrategyR\x05value:\x028\x01\x1ac\n\
    \x0bCodersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12>\n\x05va\
    lue\x18\x02\x20\x01(\x0b2(.org.apache.beam.model.pipeline.v1.CoderR\x05v\
    alue:\x028\x01\x1ao\n\x11EnvironmentsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..org.apache.beam.m\
    odel.pipeline.v1.EnvironmentR\x05value:\x028\x01\"\xfe\x01\n\x08Pipeline\
    \x12M\n\ncomponents\x18\x01\x20\x01(\x0b2-.org.apache.beam.model.pipelin\
    e.v1.ComponentsR\ncomponents\x12,\n\x12root_transform_ids\x18\x02\x20\
    \x03(\tR\x10rootTransformIds\x12Q\n\x0cdisplay_data\x18\x03\x20\x03(\x0b\
    2..org.apache.beam.model.pipeline.v1.DisplayDataR\x0bdisplayData\x12\"\n\
    \x0crequirements\x18\x04\x20\x03(\tR\x0crequirements\"\xd4\x05\n\nPTrans\
    form\x12\x1f\n\x0bunique_name\x18\x05\x20\x01(\tR\nuniqueName\x12C\n\x04\
    spec\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.FunctionSp\
    ecR\x04spec\x12$\n\rsubtransforms\x18\x02\x20\x03(\tR\rsubtransforms\x12\
    Q\n\x06inputs\x18\x03\x20\x03(\x0b29.org.apache.beam.model.pipeline.v1.P\
    Transform.InputsEntryR\x06inputs\x12T\n\x07outputs\x18\x04\x20\x03(\x0b2\
    :.org.apache.beam.model.pipeline.v1.PTransform.OutputsEntryR\x07outputs\
    \x12Q\n\x0cdisplay_data\x18\x06\x20\x03(\x0b2..org.apache.beam.model.pip\
    eline.v1.DisplayDataR\x0bdisplayData\x12%\n\x0eenvironment_id\x18\x07\
    \x20\x01(\tR\renvironmentId\x12`\n\x0bannotations\x18\x08\x20\x03(\x0b2>\
    .org.apache.beam.model.pipeline.v1.PTransform.AnnotationsEntryR\x0bannot\
    ations\x1a9\n\x0bInputsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a:\n\x0cOut\
    putsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10AnnotationsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x0cR\x05value:\x028\x01\"\xc5\x10\n\x13StandardPTransforms\"\xdb\
    \x03\n\nPrimitives\x12)\n\x06PAR_DO\x10\0\x1a\x1d\xa2\xb4\xfa\xc2\x05\
    \x17beam:transform:pardo:v1\x12,\n\x07FLATTEN\x10\x01\x1a\x1f\xa2\xb4\
    \xfa\xc2\x05\x19beam:transform:flatten:v1\x126\n\x0cGROUP_BY_KEY\x10\x02\
    \x1a$\xa2\xb4\xfa\xc2\x05\x1ebeam:transform:group_by_key:v1\x12,\n\x07IM\
    PULSE\x10\x03\x1a\x1f\xa2\xb4\xfa\xc2\x05\x19beam:transform:impulse:v1\
    \x127\n\x0eASSIGN_WINDOWS\x10\x04\x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:trans\
    form:window_into:v1\x123\n\x0bTEST_STREAM\x10\x05\x1a\"\xa2\xb4\xfa\xc2\
    \x05\x1cbeam:transform:teststream:v1\x124\n\x0bMAP_WINDOWS\x10\x06\x1a#\
    \xa2\xb4\xfa\xc2\x05\x1dbeam:transform:map_windows:v1\x128\n\rMERGE_WIND\
    OWS\x10\x07\x1a%\xa2\xb4\xfa\xc2\x05\x1fbeam:transform:merge_windows:v1\
    \x120\n\tTO_STRING\x10\x08\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:transform:to\
    _string:v1\"t\n\x14DeprecatedPrimitives\x12&\n\x04READ\x10\0\x1a\x1c\xa2\
    \xb4\xfa\xc2\x05\x16beam:transform:read:v1\x124\n\x0bCREATE_VIEW\x10\x01\
    \x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:transform:create_view:v1\"\x81\x04\n\n\
    Composites\x12<\n\x0fCOMBINE_PER_KEY\x10\0\x1a'\xa2\xb4\xfa\xc2\x05!beam\
    :transform:combine_per_key:v1\x12>\n\x10COMBINE_GLOBALLY\x10\x01\x1a(\
    \xa2\xb4\xfa\xc2\x05\"beam:transform:combine_globally:v1\x120\n\tRESHUFF\
    LE\x10\x02\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:transform:reshuffle:v1\x124\
    \n\x0bWRITE_FILES\x10\x03\x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:transform:wri\
    te_files:v1\x124\n\x0bPUBSUB_READ\x10\x04\x1a#\xa2\xb4\xfa\xc2\x05\x1dbe\
    am:transform:pubsub_read:v1\x126\n\x0cPUBSUB_WRITE\x10\x05\x1a$\xa2\xb4\
    \xfa\xc2\x05\x1ebeam:transform:pubsub_write:v1\x129\n\x0fPUBSUB_WRITE_V2\
    \x10\x07\x1a$\xa2\xb4\xfa\xc2\x05\x1ebeam:transform:pubsub_write:v2\x12d\
    \n#GROUP_INTO_BATCHES_WITH_SHARDED_KEY\x10\x06\x1a;\xa2\xb4\xfa\xc2\x055\
    beam:transform:group_into_batches_with_sharded_key:v1\"\xe3\x03\n\x11Com\
    bineComponents\x12R\n\x1aCOMBINE_PER_KEY_PRECOMBINE\x10\0\x1a2\xa2\xb4\
    \xfa\xc2\x05,beam:transform:combine_per_key_precombine:v1\x12b\n\"COMBIN\
    E_PER_KEY_MERGE_ACCUMULATORS\x10\x01\x1a:\xa2\xb4\xfa\xc2\x054beam:trans\
    form:combine_per_key_merge_accumulators:v1\x12\\\n\x1fCOMBINE_PER_KEY_EX\
    TRACT_OUTPUTS\x10\x02\x1a7\xa2\xb4\xfa\xc2\x051beam:transform:combine_pe\
    r_key_extract_outputs:v1\x12J\n\x16COMBINE_GROUPED_VALUES\x10\x03\x1a.\
    \xa2\xb4\xfa\xc2\x05(beam:transform:combine_grouped_values:v1\x12l\n'COM\
    BINE_PER_KEY_CONVERT_TO_ACCUMULATORS\x10\x04\x1a?\xa2\xb4\xfa\xc2\x059be\
    am:transform:combine_per_key_convert_to_accumulators:v1\"\x8d\x03\n\x19S\
    plittableParDoComponents\x12L\n\x15PAIR_WITH_RESTRICTION\x10\0\x1a1\xa2\
    \xb4\xfa\xc2\x05+beam:transform:sdf_pair_with_restriction:v1\x12X\n\x1bS\
    PLIT_AND_SIZE_RESTRICTIONS\x10\x01\x1a7\xa2\xb4\xfa\xc2\x051beam:transfo\
    rm:sdf_split_and_size_restrictions:v1\x12o\n'PROCESS_SIZED_ELEMENTS_AND_\
    RESTRICTIONS\x10\x02\x1aB\xa2\xb4\xfa\xc2\x05<beam:transform:sdf_process\
    _sized_element_and_restrictions:v1\x12W\n\x1aTRUNCATE_SIZED_RESTRICTION\
    \x10\x03\x1a7\xa2\xb4\xfa\xc2\x051beam:transform:sdf_truncate_sized_rest\
    rictions:v1\"`\n\x1aGroupIntoBatchesComponents\x12B\n\x12GROUP_INTO_BATC\
    HES\x10\0\x1a*\xa2\xb4\xfa\xc2\x05$beam:transform:group_into_batches:v1\
    \"\x82\x01\n\x16StandardSideInputTypes\"h\n\x04Enum\x12/\n\x08ITERABLE\
    \x10\0\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:side_input:iterable:v1\x12/\n\
    \x08MULTIMAP\x10\x01\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:side_input:multima\
    p:v1\"x\n\x16StandardUserStateTypes\"^\n\x04Enum\x12%\n\x03BAG\x10\0\x1a\
    \x1c\xa2\xb4\xfa\xc2\x05\x16beam:user_state:bag:v1\x12/\n\x08MULTIMAP\
    \x10\x01\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:user_state:multimap:v1\"\xa2\
    \x02\n\x0bPCollection\x12\x1f\n\x0bunique_name\x18\x01\x20\x01(\tR\nuniq\
    ueName\x12\x19\n\x08coder_id\x18\x02\x20\x01(\tR\x07coderId\x12P\n\nis_b\
    ounded\x18\x03\x20\x01(\x0e21.org.apache.beam.model.pipeline.v1.IsBounde\
    d.EnumR\tisBounded\x122\n\x15windowing_strategy_id\x18\x04\x20\x01(\tR\
    \x13windowingStrategyId\x12Q\n\x0cdisplay_data\x18\x05\x20\x03(\x0b2..or\
    g.apache.beam.model.pipeline.v1.DisplayDataR\x0bdisplayData\"\x91\x08\n\
    \x0cParDoPayload\x12D\n\x05do_fn\x18\x01\x20\x01(\x0b2/.org.apache.beam.\
    model.pipeline.v1.FunctionSpecR\x04doFn\x12`\n\x0bside_inputs\x18\x03\
    \x20\x03(\x0b2?.org.apache.beam.model.pipeline.v1.ParDoPayload.SideInput\
    sEntryR\nsideInputs\x12`\n\x0bstate_specs\x18\x04\x20\x03(\x0b2?.org.apa\
    che.beam.model.pipeline.v1.ParDoPayload.StateSpecsEntryR\nstateSpecs\x12\
    s\n\x12timer_family_specs\x18\t\x20\x03(\x0b2E.org.apache.beam.model.pip\
    eline.v1.ParDoPayload.TimerFamilySpecsEntryR\x10timerFamilySpecs\x120\n\
    \x14restriction_coder_id\x18\x07\x20\x01(\tR\x12restrictionCoderId\x123\
    \n\x15requests_finalization\x18\x08\x20\x01(\x08R\x14requestsFinalizatio\
    n\x12;\n\x1arequires_time_sorted_input\x18\n\x20\x01(\x08R\x17requiresTi\
    meSortedInput\x122\n\x15requires_stable_input\x18\x0b\x20\x01(\x08R\x13r\
    equiresStableInput\x12Q\n&on_window_expiration_timer_family_spec\x18\x0c\
    \x20\x01(\tR!onWindowExpirationTimerFamilySpec\x1ak\n\x0fSideInputsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12B\n\x05value\x18\x02\x20\
    \x01(\x0b2,.org.apache.beam.model.pipeline.v1.SideInputR\x05value:\x028\
    \x01\x1ak\n\x0fStateSpecsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12B\n\x05value\x18\x02\x20\x01(\x0b2,.org.apache.beam.model.pipeline\
    .v1.StateSpecR\x05value:\x028\x01\x1aw\n\x15TimerFamilySpecsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12H\n\x05value\x18\x02\x20\x01\
    (\x0b22.org.apache.beam.model.pipeline.v1.TimerFamilySpecR\x05value:\x02\
    8\x01J\x04\x08\x06\x10\x07\"\x85\x05\n\tStateSpec\x12r\n\x16read_modify_\
    write_spec\x18\x01\x20\x01(\x0b2;.org.apache.beam.model.pipeline.v1.Read\
    ModifyWriteStateSpecH\0R\x13readModifyWriteSpec\x12L\n\x08bag_spec\x18\
    \x02\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.BagStateSpecH\0R\
    \x07bagSpec\x12^\n\x0ecombining_spec\x18\x03\x20\x01(\x0b25.org.apache.b\
    eam.model.pipeline.v1.CombiningStateSpecH\0R\rcombiningSpec\x12L\n\x08ma\
    p_spec\x18\x04\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.MapState\
    SpecH\0R\x07mapSpec\x12L\n\x08set_spec\x18\x05\x20\x01(\x0b2/.org.apache\
    .beam.model.pipeline.v1.SetStateSpecH\0R\x07setSpec\x12e\n\x11ordered_li\
    st_spec\x18\x06\x20\x01(\x0b27.org.apache.beam.model.pipeline.v1.Ordered\
    ListStateSpecH\0R\x0forderedListSpec\x12K\n\x08protocol\x18\x07\x20\x01(\
    \x0b2/.org.apache.beam.model.pipeline.v1.FunctionSpecR\x08protocolB\x06\
    \n\x04spec\"5\n\x18ReadModifyWriteStateSpec\x12\x19\n\x08coder_id\x18\
    \x01\x20\x01(\tR\x07coderId\"8\n\x0cBagStateSpec\x12(\n\x10element_coder\
    _id\x18\x01\x20\x01(\tR\x0eelementCoderId\"@\n\x14OrderedListStateSpec\
    \x12(\n\x10element_coder_id\x18\x01\x20\x01(\tR\x0eelementCoderId\"\x96\
    \x01\n\x12CombiningStateSpec\x120\n\x14accumulator_coder_id\x18\x01\x20\
    \x01(\tR\x12accumulatorCoderId\x12N\n\ncombine_fn\x18\x02\x20\x01(\x0b2/\
    .org.apache.beam.model.pipeline.v1.FunctionSpecR\tcombineFn\"V\n\x0cMapS\
    tateSpec\x12\x20\n\x0ckey_coder_id\x18\x01\x20\x01(\tR\nkeyCoderId\x12$\
    \n\x0evalue_coder_id\x18\x02\x20\x01(\tR\x0cvalueCoderId\"8\n\x0cSetStat\
    eSpec\x12(\n\x10element_coder_id\x18\x01\x20\x01(\tR\x0eelementCoderId\"\
    \x99\x01\n\x0fTimerFamilySpec\x12S\n\x0btime_domain\x18\x01\x20\x01(\x0e\
    22.org.apache.beam.model.pipeline.v1.TimeDomain.EnumR\ntimeDomain\x121\n\
    \x15timer_family_coder_id\x18\x02\x20\x01(\tR\x12timerFamilyCoderId\"@\n\
    \tIsBounded\"3\n\x04Enum\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\r\n\tUNBOUND\
    ED\x10\x01\x12\x0b\n\x07BOUNDED\x10\x02\"\xa8\x01\n\x0bReadPayload\x12G\
    \n\x06source\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.Fu\
    nctionSpecR\x06source\x12P\n\nis_bounded\x18\x02\x20\x01(\x0e21.org.apac\
    he.beam.model.pipeline.v1.IsBounded.EnumR\tisBounded\"a\n\x11WindowIntoP\
    ayload\x12L\n\twindow_fn\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pi\
    peline.v1.FunctionSpecR\x08windowFn\"\x92\x01\n\x0eCombinePayload\x12N\n\
    \ncombine_fn\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.Fu\
    nctionSpecR\tcombineFn\x120\n\x14accumulator_coder_id\x18\x02\x20\x01(\t\
    R\x12accumulatorCoderId\"\xcd\x07\n\x11TestStreamPayload\x12\x19\n\x08co\
    der_id\x18\x01\x20\x01(\tR\x07coderId\x12R\n\x06events\x18\x02\x20\x03(\
    \x0b2:.org.apache.beam.model.pipeline.v1.TestStreamPayload.EventR\x06eve\
    nts\x12S\n\x08endpoint\x18\x03\x20\x01(\x0b27.org.apache.beam.model.pipe\
    line.v1.ApiServiceDescriptorR\x08endpoint\x1a\x96\x05\n\x05Event\x12v\n\
    \x0fwatermark_event\x18\x01\x20\x01(\x0b2K.org.apache.beam.model.pipelin\
    e.v1.TestStreamPayload.Event.AdvanceWatermarkH\0R\x0ewatermarkEvent\x12\
    \x86\x01\n\x15processing_time_event\x18\x02\x20\x01(\x0b2P.org.apache.be\
    am.model.pipeline.v1.TestStreamPayload.Event.AdvanceProcessingTimeH\0R\
    \x13processingTimeEvent\x12m\n\relement_event\x18\x03\x20\x01(\x0b2F.org\
    .apache.beam.model.pipeline.v1.TestStreamPayload.Event.AddElementsH\0R\
    \x0celementEvent\x1aI\n\x10AdvanceWatermark\x12#\n\rnew_watermark\x18\
    \x01\x20\x01(\x03R\x0cnewWatermark\x12\x10\n\x03tag\x18\x02\x20\x01(\tR\
    \x03tag\x1aB\n\x15AdvanceProcessingTime\x12)\n\x10advance_duration\x18\
    \x01\x20\x01(\x03R\x0fadvanceDuration\x1a\x84\x01\n\x0bAddElements\x12c\
    \n\x08elements\x18\x01\x20\x03(\x0b2G.org.apache.beam.model.pipeline.v1.\
    TestStreamPayload.TimestampedElementR\x08elements\x12\x10\n\x03tag\x18\
    \x03\x20\x01(\tR\x03tagB\x07\n\x05event\x1a[\n\x12TimestampedElement\x12\
    '\n\x0fencoded_element\x18\x01\x20\x01(\x0cR\x0eencodedElement\x12\x1c\n\
    \ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\".\n\rEventsRequest\x12\x1d\
    \n\noutput_ids\x18\x01\x20\x03(\tR\toutputIds\"\xed\x03\n\x11WriteFilesP\
    ayload\x12C\n\x04sink\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pipel\
    ine.v1.FunctionSpecR\x04sink\x12X\n\x0fformat_function\x18\x02\x20\x01(\
    \x0b2/.org.apache.beam.model.pipeline.v1.FunctionSpecR\x0eformatFunction\
    \x12'\n\x0fwindowed_writes\x18\x03\x20\x01(\x08R\x0ewindowedWrites\x12<\
    \n\x1arunner_determined_sharding\x18\x04\x20\x01(\x08R\x18runnerDetermin\
    edSharding\x12e\n\x0bside_inputs\x18\x05\x20\x03(\x0b2D.org.apache.beam.\
    model.pipeline.v1.WriteFilesPayload.SideInputsEntryR\nsideInputs\x1ak\n\
    \x0fSideInputsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12B\n\
    \x05value\x18\x02\x20\x01(\x0b2,.org.apache.beam.model.pipeline.v1.SideI\
    nputR\x05value:\x028\x01\"\xcc\x02\n\x11PubSubReadPayload\x12\x14\n\x05t\
    opic\x18\x01\x20\x01(\tR\x05topic\x12\"\n\x0csubscription\x18\x02\x20\
    \x01(\tR\x0csubscription\x12/\n\x13timestamp_attribute\x18\x03\x20\x01(\
    \tR\x12timestampAttribute\x12!\n\x0cid_attribute\x18\x04\x20\x01(\tR\x0b\
    idAttribute\x12'\n\x0fwith_attributes\x18\x05\x20\x01(\x08R\x0ewithAttri\
    butes\x128\n\x18topic_runtime_overridden\x18\x06\x20\x01(\tR\x16topicRun\
    timeOverridden\x12F\n\x1fsubscription_runtime_overridden\x18\x07\x20\x01\
    (\tR\x1dsubscriptionRuntimeOverridden\"\xb8\x01\n\x12PubSubWritePayload\
    \x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12/\n\x13timestamp_att\
    ribute\x18\x02\x20\x01(\tR\x12timestampAttribute\x12!\n\x0cid_attribute\
    \x18\x03\x20\x01(\tR\x0bidAttribute\x128\n\x18topic_runtime_overridden\
    \x18\x04\x20\x01(\tR\x16topicRuntimeOverridden\"\xa5\x01\n\x17GroupIntoB\
    atchesPayload\x12\x1d\n\nbatch_size\x18\x01\x20\x01(\x03R\tbatchSize\x12\
    (\n\x10batch_size_bytes\x18\x03\x20\x01(\x03R\x0ebatchSizeBytes\x12A\n\
    \x1dmax_buffering_duration_millis\x18\x02\x20\x01(\x03R\x1amaxBufferingD\
    urationMillis\"|\n\x05Coder\x12C\n\x04spec\x18\x01\x20\x01(\x0b2/.org.ap\
    ache.beam.model.pipeline.v1.FunctionSpecR\x04spec\x12.\n\x13component_co\
    der_ids\x18\x02\x20\x03(\tR\x11componentCoderIds\"\xf5\x06\n\x0eStandard\
    Coders\"\xe2\x06\n\x04Enum\x12$\n\x05BYTES\x10\0\x1a\x19\xa2\xb4\xfa\xc2\
    \x05\x13beam:coder:bytes:v1\x120\n\x0bSTRING_UTF8\x10\n\x1a\x1f\xa2\xb4\
    \xfa\xc2\x05\x19beam:coder:string_utf8:v1\x12\x1e\n\x02KV\x10\x01\x1a\
    \x16\xa2\xb4\xfa\xc2\x05\x10beam:coder:kv:v1\x12\"\n\x04BOOL\x10\x0c\x1a\
    \x18\xa2\xb4\xfa\xc2\x05\x12beam:coder:bool:v1\x12&\n\x06VARINT\x10\x02\
    \x1a\x1a\xa2\xb4\xfa\xc2\x05\x14beam:coder:varint:v1\x12&\n\x06DOUBLE\
    \x10\x0b\x1a\x1a\xa2\xb4\xfa\xc2\x05\x14beam:coder:double:v1\x12*\n\x08I\
    TERABLE\x10\x03\x1a\x1c\xa2\xb4\xfa\xc2\x05\x16beam:coder:iterable:v1\
    \x12$\n\x05TIMER\x10\x04\x1a\x19\xa2\xb4\xfa\xc2\x05\x13beam:coder:timer\
    :v1\x128\n\x0fINTERVAL_WINDOW\x10\x05\x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:c\
    oder:interval_window:v1\x124\n\rLENGTH_PREFIX\x10\x06\x1a!\xa2\xb4\xfa\
    \xc2\x05\x1bbeam:coder:length_prefix:v1\x124\n\rGLOBAL_WINDOW\x10\x07\
    \x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:coder:global_window:v1\x126\n\x0eWINDO\
    WED_VALUE\x10\x08\x1a\"\xa2\xb4\xfa\xc2\x05\x1cbeam:coder:windowed_value\
    :v1\x12B\n\x14PARAM_WINDOWED_VALUE\x10\x0e\x1a(\xa2\xb4\xfa\xc2\x05\"bea\
    m:coder:param_windowed_value:v1\x12D\n\x15STATE_BACKED_ITERABLE\x10\t\
    \x1a)\xa2\xb4\xfa\xc2\x05#beam:coder:state_backed_iterable:v1\x124\n\rCU\
    STOM_WINDOW\x10\x10\x1a!\xa2\xb4\xfa\xc2\x05\x1bbeam:coder:custom_window\
    :v1\x12\x20\n\x03ROW\x10\r\x1a\x17\xa2\xb4\xfa\xc2\x05\x11beam:coder:row\
    :v1\x120\n\x0bSHARDED_KEY\x10\x0f\x1a\x1f\xa2\xb4\xfa\xc2\x05\x19beam:co\
    der:sharded_key:v1\x12*\n\x08NULLABLE\x10\x11\x1a\x1c\xa2\xb4\xfa\xc2\
    \x05\x16beam:coder:nullable:v1\"\xae\x06\n\x11WindowingStrategy\x12L\n\t\
    window_fn\x18\x01\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.Funct\
    ionSpecR\x08windowFn\x12V\n\x0cmerge_status\x18\x02\x20\x01(\x0e23.org.a\
    pache.beam.model.pipeline.v1.MergeStatus.EnumR\x0bmergeStatus\x12&\n\x0f\
    window_coder_id\x18\x03\x20\x01(\tR\rwindowCoderId\x12D\n\x07trigger\x18\
    \x04\x20\x01(\x0b2*.org.apache.beam.model.pipeline.v1.TriggerR\x07trigge\
    r\x12e\n\x11accumulation_mode\x18\x05\x20\x01(\x0e28.org.apache.beam.mod\
    el.pipeline.v1.AccumulationMode.EnumR\x10accumulationMode\x12S\n\x0boutp\
    ut_time\x18\x06\x20\x01(\x0e22.org.apache.beam.model.pipeline.v1.OutputT\
    ime.EnumR\noutputTime\x12b\n\x10closing_behavior\x18\x07\x20\x01(\x0e27.\
    org.apache.beam.model.pipeline.v1.ClosingBehavior.EnumR\x0fclosingBehavi\
    or\x12)\n\x10allowed_lateness\x18\x08\x20\x01(\x03R\x0fallowedLateness\
    \x12`\n\x10on_time_behavior\x18\t\x20\x01(\x0e26.org.apache.beam.model.p\
    ipeline.v1.OnTimeBehavior.EnumR\x0eonTimeBehavior\x121\n\x15assigns_to_o\
    ne_window\x18\n\x20\x01(\x08R\x12assignsToOneWindow\x12%\n\x0eenvironmen\
    t_id\x18\x0b\x20\x01(\tR\renvironmentId\"\\\n\x0bMergeStatus\"M\n\x04Enu\
    m\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x0f\n\x0bNON_MERGING\x10\x01\x12\
    \x0f\n\x0bNEEDS_MERGE\x10\x02\x12\x12\n\x0eALREADY_MERGED\x10\x03\"]\n\
    \x10AccumulationMode\"I\n\x04Enum\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x0e\
    \n\nDISCARDING\x10\x01\x12\x10\n\x0cACCUMULATING\x10\x02\x12\x0e\n\nRETR\
    ACTING\x10\x03\"Q\n\x0fClosingBehavior\">\n\x04Enum\x12\x0f\n\x0bUNSPECI\
    FIED\x10\0\x12\x0f\n\x0bEMIT_ALWAYS\x10\x01\x12\x14\n\x10EMIT_IF_NONEMPT\
    Y\x10\x02\"P\n\x0eOnTimeBehavior\">\n\x04Enum\x12\x0f\n\x0bUNSPECIFIED\
    \x10\0\x12\x0f\n\x0bFIRE_ALWAYS\x10\x01\x12\x14\n\x10FIRE_IF_NONEMPTY\
    \x10\x02\"b\n\nOutputTime\"T\n\x04Enum\x12\x0f\n\x0bUNSPECIFIED\x10\0\
    \x12\x11\n\rEND_OF_WINDOW\x10\x01\x12\x12\n\x0eLATEST_IN_PANE\x10\x02\
    \x12\x14\n\x10EARLIEST_IN_PANE\x10\x03\"n\n\nTimeDomain\"`\n\x04Enum\x12\
    \x0f\n\x0bUNSPECIFIED\x10\0\x12\x0e\n\nEVENT_TIME\x10\x01\x12\x13\n\x0fP\
    ROCESSING_TIME\x10\x02\"\x04\x08\x03\x10\x03*\x1cSYNCHRONIZED_PROCESSING\
    _TIME\"\xa3\x10\n\x07Trigger\x12R\n\tafter_all\x18\x01\x20\x01(\x0b23.or\
    g.apache.beam.model.pipeline.v1.Trigger.AfterAllH\0R\x08afterAll\x12R\n\
    \tafter_any\x18\x02\x20\x01(\x0b23.org.apache.beam.model.pipeline.v1.Tri\
    gger.AfterAnyH\0R\x08afterAny\x12U\n\nafter_each\x18\x03\x20\x01(\x0b24.\
    org.apache.beam.model.pipeline.v1.Trigger.AfterEachH\0R\tafterEach\x12l\
    \n\x13after_end_of_window\x18\x04\x20\x01(\x0b2;.org.apache.beam.model.p\
    ipeline.v1.Trigger.AfterEndOfWindowH\0R\x10afterEndOfWindow\x12t\n\x15af\
    ter_processing_time\x18\x05\x20\x01(\x0b2>.org.apache.beam.model.pipelin\
    e.v1.Trigger.AfterProcessingTimeH\0R\x13afterProcessingTime\x12\x99\x01\
    \n\"after_synchronized_processing_time\x18\x06\x20\x01(\x0b2J.org.apache\
    .beam.model.pipeline.v1.Trigger.AfterSynchronizedProcessingTimeH\0R\x1fa\
    fterSynchronizedProcessingTime\x12K\n\x06always\x18\x0c\x20\x01(\x0b21.o\
    rg.apache.beam.model.pipeline.v1.Trigger.AlwaysH\0R\x06always\x12N\n\x07\
    default\x18\x07\x20\x01(\x0b22.org.apache.beam.model.pipeline.v1.Trigger\
    .DefaultH\0R\x07default\x12^\n\relement_count\x18\x08\x20\x01(\x0b27.org\
    .apache.beam.model.pipeline.v1.Trigger.ElementCountH\0R\x0celementCount\
    \x12H\n\x05never\x18\t\x20\x01(\x0b20.org.apache.beam.model.pipeline.v1.\
    Trigger.NeverH\0R\x05never\x12U\n\nor_finally\x18\n\x20\x01(\x0b24.org.a\
    pache.beam.model.pipeline.v1.Trigger.OrFinallyH\0R\torFinally\x12K\n\x06\
    repeat\x18\x0b\x20\x01(\x0b21.org.apache.beam.model.pipeline.v1.Trigger.\
    RepeatH\0R\x06repeat\x1aX\n\x08AfterAll\x12L\n\x0bsubtriggers\x18\x01\
    \x20\x03(\x0b2*.org.apache.beam.model.pipeline.v1.TriggerR\x0bsubtrigger\
    s\x1aX\n\x08AfterAny\x12L\n\x0bsubtriggers\x18\x01\x20\x03(\x0b2*.org.ap\
    ache.beam.model.pipeline.v1.TriggerR\x0bsubtriggers\x1aY\n\tAfterEach\
    \x12L\n\x0bsubtriggers\x18\x01\x20\x03(\x0b2*.org.apache.beam.model.pipe\
    line.v1.TriggerR\x0bsubtriggers\x1a\xb2\x01\n\x10AfterEndOfWindow\x12O\n\
    \rearly_firings\x18\x01\x20\x01(\x0b2*.org.apache.beam.model.pipeline.v1\
    .TriggerR\x0cearlyFirings\x12M\n\x0clate_firings\x18\x02\x20\x01(\x0b2*.\
    org.apache.beam.model.pipeline.v1.TriggerR\x0blateFirings\x1a\x7f\n\x13A\
    fterProcessingTime\x12h\n\x14timestamp_transforms\x18\x01\x20\x03(\x0b25\
    .org.apache.beam.model.pipeline.v1.TimestampTransformR\x13timestampTrans\
    forms\x1a!\n\x1fAfterSynchronizedProcessingTime\x1a\t\n\x07Default\x1a3\
    \n\x0cElementCount\x12#\n\relement_count\x18\x01\x20\x01(\x05R\x0celemen\
    tCount\x1a\x07\n\x05Never\x1a\x08\n\x06Always\x1a\x91\x01\n\tOrFinally\
    \x12>\n\x04main\x18\x01\x20\x01(\x0b2*.org.apache.beam.model.pipeline.v1\
    .TriggerR\x04main\x12D\n\x07finally\x18\x02\x20\x01(\x0b2*.org.apache.be\
    am.model.pipeline.v1.TriggerR\x07finally\x1aT\n\x06Repeat\x12J\n\nsubtri\
    gger\x18\x01\x20\x01(\x0b2*.org.apache.beam.model.pipeline.v1.TriggerR\n\
    subtriggerB\t\n\x07trigger\"\xc3\x02\n\x12TimestampTransform\x12S\n\x05d\
    elay\x18\x01\x20\x01(\x0b2;.org.apache.beam.model.pipeline.v1.TimestampT\
    ransform.DelayH\0R\x05delay\x12Z\n\x08align_to\x18\x02\x20\x01(\x0b2=.or\
    g.apache.beam.model.pipeline.v1.TimestampTransform.AlignToH\0R\x07alignT\
    o\x1a*\n\x05Delay\x12!\n\x0cdelay_millis\x18\x01\x20\x01(\x03R\x0bdelayM\
    illis\x1a9\n\x07AlignTo\x12\x16\n\x06period\x18\x03\x20\x01(\x03R\x06per\
    iod\x12\x16\n\x06offset\x18\x04\x20\x01(\x03R\x06offsetB\x15\n\x13timest\
    amp_transform\"\x8a\x02\n\tSideInput\x12V\n\x0eaccess_pattern\x18\x01\
    \x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.FunctionSpecR\raccessP\
    attern\x12H\n\x07view_fn\x18\x02\x20\x01(\x0b2/.org.apache.beam.model.pi\
    peline.v1.FunctionSpecR\x06viewFn\x12[\n\x11window_mapping_fn\x18\x03\
    \x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.FunctionSpecR\x0fwindo\
    wMappingFn\"\x89\x04\n\x11StandardArtifacts\"\x9f\x02\n\x05Types\x12*\n\
    \x04FILE\x10\0\x1a\x20\xa2\xb4\xfa\xc2\x05\x1abeam:artifact:type:file:v1\
    \x12(\n\x03URL\x10\x01\x1a\x1f\xa2\xb4\xfa\xc2\x05\x19beam:artifact:type\
    :url:v1\x122\n\x08EMBEDDED\x10\x02\x1a$\xa2\xb4\xfa\xc2\x05\x1ebeam:arti\
    fact:type:embedded:v1\x12*\n\x04PYPI\x10\x03\x1a\x20\xa2\xb4\xfa\xc2\x05\
    \x1abeam:artifact:type:pypi:v1\x12,\n\x05MAVEN\x10\x04\x1a!\xa2\xb4\xfa\
    \xc2\x05\x1bbeam:artifact:type:maven:v1\x122\n\x08DEFERRED\x10\x05\x1a$\
    \xa2\xb4\xfa\xc2\x05\x1ebeam:artifact:type:deferred:v1\"\xd1\x01\n\x05Ro\
    les\x126\n\nSTAGING_TO\x10\0\x1a&\xa2\xb4\xfa\xc2\x05\x20beam:artifact:r\
    ole:staging_to:v1\x12L\n\x15PIP_REQUIREMENTS_FILE\x10\x01\x1a1\xa2\xb4\
    \xfa\xc2\x05+beam:artifact:role:pip_requirements_file:v1\x12B\n\x10GO_WO\
    RKER_BINARY\x10\x02\x1a,\xa2\xb4\xfa\xc2\x05&beam:artifact:role:go_worke\
    r_binary:v1\"A\n\x13ArtifactFilePayload\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12\x16\n\x06sha256\x18\x02\x20\x01(\tR\x06sha256\">\n\
    \x12ArtifactUrlPayload\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\
    \x16\n\x06sha256\x18\x02\x20\x01(\tR\x06sha256\")\n\x13EmbeddedFilePaylo\
    ad\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"H\n\x0bPyPIPayload\
    \x12\x1f\n\x0bartifact_id\x18\x01\x20\x01(\tR\nartifactId\x12\x18\n\x07v\
    ersion\x18\x02\x20\x01(\tR\x07version\"Q\n\x0cMavenPayload\x12\x1a\n\x08\
    artifact\x18\x01\x20\x01(\tR\x08artifact\x12%\n\x0erepository_url\x18\
    \x02\x20\x01(\tR\rrepositoryUrl\"?\n\x17DeferredArtifactPayload\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x12\n\x04data\x18\x02\x20\x01(\
    \x0cR\x04data\"?\n\x1cArtifactStagingToRolePayload\x12\x1f\n\x0bstaged_n\
    ame\x18\x01\x20\x01(\tR\nstagedName\"\x91\x01\n\x13ArtifactInformation\
    \x12\x19\n\x08type_urn\x18\x01\x20\x01(\tR\x07typeUrn\x12!\n\x0ctype_pay\
    load\x18\x02\x20\x01(\x0cR\x0btypePayload\x12\x19\n\x08role_urn\x18\x03\
    \x20\x01(\tR\x07roleUrn\x12!\n\x0crole_payload\x18\x04\x20\x01(\x0cR\x0b\
    rolePayload\"\xbe\x03\n\x0bEnvironment\x12\x10\n\x03urn\x18\x02\x20\x01(\
    \tR\x03urn\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12Q\n\
    \x0cdisplay_data\x18\x04\x20\x03(\x0b2..org.apache.beam.model.pipeline.v\
    1.DisplayDataR\x0bdisplayData\x12\"\n\x0ccapabilities\x18\x05\x20\x03(\t\
    R\x0ccapabilities\x12Z\n\x0cdependencies\x18\x06\x20\x03(\x0b26.org.apac\
    he.beam.model.pipeline.v1.ArtifactInformationR\x0cdependencies\x12h\n\
    \x0eresource_hints\x18\x07\x20\x03(\x0b2A.org.apache.beam.model.pipeline\
    .v1.Environment.ResourceHintsEntryR\rresourceHints\x1a@\n\x12ResourceHin\
    tsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x0cR\x05value:\x028\x01J\x04\x08\x01\x10\x02\"\xc7\x01\
    \n\x14StandardEnvironments\"\xae\x01\n\x0cEnvironments\x12$\n\x06DOCKER\
    \x10\0\x1a\x18\xa2\xb4\xfa\xc2\x05\x12beam:env:docker:v1\x12&\n\x07PROCE\
    SS\x10\x01\x1a\x19\xa2\xb4\xfa\xc2\x05\x13beam:env:process:v1\x12(\n\x08\
    EXTERNAL\x10\x02\x1a\x1a\xa2\xb4\xfa\xc2\x05\x14beam:env:external:v1\x12\
    &\n\x07DEFAULT\x10\x03\x1a\x19\xa2\xb4\xfa\xc2\x05\x13beam:env:default:v\
    1\"8\n\rDockerPayload\x12'\n\x0fcontainer_image\x18\x01\x20\x01(\tR\x0ec\
    ontainerImage\"\xd4\x01\n\x0eProcessPayload\x12\x0e\n\x02os\x18\x01\x20\
    \x01(\tR\x02os\x12\x12\n\x04arch\x18\x02\x20\x01(\tR\x04arch\x12\x18\n\
    \x07command\x18\x03\x20\x01(\tR\x07command\x12L\n\x03env\x18\x04\x20\x03\
    (\x0b2:.org.apache.beam.model.pipeline.v1.ProcessPayload.EnvEntryR\x03en\
    v\x1a6\n\x08EnvEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xf9\x01\n\x0fExtern\
    alPayload\x12S\n\x08endpoint\x18\x01\x20\x01(\x0b27.org.apache.beam.mode\
    l.pipeline.v1.ApiServiceDescriptorR\x08endpoint\x12V\n\x06params\x18\x02\
    \x20\x03(\x0b2>.org.apache.beam.model.pipeline.v1.ExternalPayload.Params\
    EntryR\x06params\x1a9\n\x0bParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\
    \xe1\x04\n\x11StandardProtocols\"\xcb\x04\n\x04Enum\x12H\n\x19LEGACY_PRO\
    GRESS_REPORTING\x10\0\x1a)\xa2\xb4\xfa\xc2\x05#beam:protocol:progress_re\
    porting:v0\x12A\n\x12PROGRESS_REPORTING\x10\x01\x1a)\xa2\xb4\xfa\xc2\x05\
    #beam:protocol:progress_reporting:v1\x127\n\rWORKER_STATUS\x10\x02\x1a$\
    \xa2\xb4\xfa\xc2\x05\x1ebeam:protocol:worker_status:v1\x12U\n\x1cMULTI_C\
    ORE_BUNDLE_PROCESSING\x10\x03\x1a3\xa2\xb4\xfa\xc2\x05-beam:protocol:mul\
    ti_core_bundle_processing:v1\x12;\n\x0fSIBLING_WORKERS\x10\x05\x1a&\xa2\
    \xb4\xfa\xc2\x05\x20beam:protocol:sibling_workers:v1\x12M\n\x18HARNESS_M\
    ONITORING_INFOS\x10\x04\x1a/\xa2\xb4\xfa\xc2\x05)beam:protocol:harness_m\
    onitoring_infos:v1\x12a\n\"CONTROL_REQUEST_ELEMENTS_EMBEDDING\x10\x06\
    \x1a9\xa2\xb4\xfa\xc2\x053beam:protocol:control_request_elements_embeddi\
    ng:v1\x127\n\rSTATE_CACHING\x10\x07\x1a$\xa2\xb4\xfa\xc2\x05\x1ebeam:pro\
    tocol:state_caching:v1\"\xd8\x01\n\x17StandardRunnerProtocols\"\xbc\x01\
    \n\x04Enum\x12O\n\x19MONITORING_INFO_SHORT_IDS\x10\0\x1a0\xa2\xb4\xfa\
    \xc2\x05*beam:protocol:monitoring_info_short_ids:v1\x12c\n#CONTROL_RESPO\
    NSE_ELEMENTS_EMBEDDING\x10\x06\x1a:\xa2\xb4\xfa\xc2\x054beam:protocol:co\
    ntrol_response_elements_embedding:v1\"\xff\x03\n\x14StandardRequirements\
    \"\xe6\x03\n\x04Enum\x12J\n\x1cREQUIRES_STATEFUL_PROCESSING\x10\0\x1a(\
    \xa2\xb4\xfa\xc2\x05\"beam:requirement:pardo:stateful:v1\x12N\n\x1cREQUI\
    RES_BUNDLE_FINALIZATION\x10\x01\x1a,\xa2\xb4\xfa\xc2\x05&beam:requiremen\
    t:pardo:finalization:v1\x12G\n\x15REQUIRES_STABLE_INPUT\x10\x02\x1a,\xa2\
    \xb4\xfa\xc2\x05&beam:requirement:pardo:stable_input:v1\x12Q\n\x1aREQUIR\
    ES_TIME_SORTED_INPUT\x10\x03\x1a1\xa2\xb4\xfa\xc2\x05+beam:requirement:p\
    ardo:time_sorted_input:v1\x12M\n\x18REQUIRES_SPLITTABLE_DOFN\x10\x04\x1a\
    /\xa2\xb4\xfa\xc2\x05)beam:requirement:pardo:splittable_dofn:v1\x12W\n\
    \x1dREQUIRES_ON_WINDOW_EXPIRATION\x10\x05\x1a4\xa2\xb4\xfa\xc2\x05.beam:\
    requirement:pardo:on_window_expiration:v1\":\n\x0cFunctionSpec\x12\x10\n\
    \x03urn\x18\x01\x20\x01(\tR\x03urn\x12\x18\n\x07payload\x18\x03\x20\x01(\
    \x0cR\x07payload\"W\n\x13StandardDisplayData\"@\n\x0bDisplayData\x121\n\
    \x08LABELLED\x10\0\x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:display_data:labelle\
    d:v1\"\xea\x01\n\x0fLabelledPayload\x12\x14\n\x05label\x18\x01\x20\x01(\
    \tR\x05label\x12#\n\x0cstring_value\x18\x02\x20\x01(\tH\0R\x0bstringValu\
    e\x12\x1f\n\nbool_value\x18\x03\x20\x01(\x08H\0R\tboolValue\x12#\n\x0cdo\
    uble_value\x18\x04\x20\x01(\x01H\0R\x0bdoubleValue\x12\x1d\n\tint_value\
    \x18\x05\x20\x01(\x03H\0R\x08intValue\x12\x10\n\x03key\x18\x06\x20\x01(\
    \tR\x03key\x12\x1c\n\tnamespace\x18\x07\x20\x01(\tR\tnamespaceB\x07\n\
    \x05value\"9\n\x0bDisplayData\x12\x10\n\x03urn\x18\x01\x20\x01(\tR\x03ur\
    n\x12\x18\n\x07payload\x18\x02\x20\x01(\x0cR\x07payload\"\xd7\x07\n\x15M\
    essageWithComponents\x12M\n\ncomponents\x18\x01\x20\x01(\x0b2-.org.apach\
    e.beam.model.pipeline.v1.ComponentsR\ncomponents\x12@\n\x05coder\x18\x02\
    \x20\x01(\x0b2(.org.apache.beam.model.pipeline.v1.CoderH\0R\x05coder\x12\
    \\\n\x0fcombine_payload\x18\x03\x20\x01(\x0b21.org.apache.beam.model.pip\
    eline.v1.CombinePayloadH\0R\x0ecombinePayload\x12V\n\rfunction_spec\x18\
    \x04\x20\x01(\x0b2/.org.apache.beam.model.pipeline.v1.FunctionSpecH\0R\
    \x0cfunctionSpec\x12W\n\x0epar_do_payload\x18\x06\x20\x01(\x0b2/.org.apa\
    che.beam.model.pipeline.v1.ParDoPayloadH\0R\x0cparDoPayload\x12O\n\nptra\
    nsform\x18\x07\x20\x01(\x0b2-.org.apache.beam.model.pipeline.v1.PTransfo\
    rmH\0R\nptransform\x12R\n\x0bpcollection\x18\x08\x20\x01(\x0b2..org.apac\
    he.beam.model.pipeline.v1.PCollectionH\0R\x0bpcollection\x12S\n\x0cread_\
    payload\x18\t\x20\x01(\x0b2..org.apache.beam.model.pipeline.v1.ReadPaylo\
    adH\0R\x0breadPayload\x12M\n\nside_input\x18\x0b\x20\x01(\x0b2,.org.apac\
    he.beam.model.pipeline.v1.SideInputH\0R\tsideInput\x12f\n\x13window_into\
    _payload\x18\x0c\x20\x01(\x0b24.org.apache.beam.model.pipeline.v1.Window\
    IntoPayloadH\0R\x11windowIntoPayload\x12e\n\x12windowing_strategy\x18\r\
    \x20\x01(\x0b24.org.apache.beam.model.pipeline.v1.WindowingStrategyH\0R\
    \x11windowingStrategyB\x06\n\x04root\"\xb6\n\n\x16ExecutableStagePayload\
    \x12P\n\x0benvironment\x18\x01\x20\x01(\x0b2..org.apache.beam.model.pipe\
    line.v1.EnvironmentR\x0benvironment\x12z\n\x13wire_coder_settings\x18\t\
    \x20\x03(\x0b2J.org.apache.beam.model.pipeline.v1.ExecutableStagePayload\
    .WireCoderSettingR\x11wireCoderSettings\x12\x14\n\x05input\x18\x02\x20\
    \x01(\tR\x05input\x12f\n\x0bside_inputs\x18\x03\x20\x03(\x0b2E.org.apach\
    e.beam.model.pipeline.v1.ExecutableStagePayload.SideInputIdR\nsideInputs\
    \x12\x1e\n\ntransforms\x18\x04\x20\x03(\tR\ntransforms\x12\x18\n\x07outp\
    uts\x18\x05\x20\x03(\tR\x07outputs\x12M\n\ncomponents\x18\x06\x20\x01(\
    \x0b2-.org.apache.beam.model.pipeline.v1.ComponentsR\ncomponents\x12f\n\
    \x0buser_states\x18\x07\x20\x03(\x0b2E.org.apache.beam.model.pipeline.v1\
    .ExecutableStagePayload.UserStateIdR\nuserStates\x12Y\n\x06timers\x18\
    \x08\x20\x03(\x0b2A.org.apache.beam.model.pipeline.v1.ExecutableStagePay\
    load.TimerIdR\x06timers\x12m\n\rtimerFamilies\x18\n\x20\x03(\x0b2G.org.a\
    pache.beam.model.pipeline.v1.ExecutableStagePayload.TimerFamilyIdR\rtime\
    rFamilies\x1aO\n\x0bSideInputId\x12!\n\x0ctransform_id\x18\x01\x20\x01(\
    \tR\x0btransformId\x12\x1d\n\nlocal_name\x18\x02\x20\x01(\tR\tlocalName\
    \x1aO\n\x0bUserStateId\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btra\
    nsformId\x12\x1d\n\nlocal_name\x18\x02\x20\x01(\tR\tlocalName\x1aK\n\x07\
    TimerId\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btransformId\x12\
    \x1d\n\nlocal_name\x18\x02\x20\x01(\tR\tlocalName\x1aQ\n\rTimerFamilyId\
    \x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btransformId\x12\x1d\n\nlo\
    cal_name\x18\x02\x20\x01(\tR\tlocalName\x1a\xd2\x01\n\x10WireCoderSettin\
    g\x12\x10\n\x03urn\x18\x01\x20\x01(\tR\x03urn\x12\x18\n\x07payload\x18\
    \x02\x20\x01(\x0cR\x07payload\x12-\n\x12input_or_output_id\x18\x03\x20\
    \x01(\tH\0R\x0finputOrOutputId\x12Y\n\x05timer\x18\x04\x20\x01(\x0b2A.or\
    g.apache.beam.model.pipeline.v1.ExecutableStagePayload.TimerIdH\0R\x05ti\
    merB\x08\n\x06target\"\x8f\x01\n\x15StandardResourceHints\"v\n\x04Enum\
    \x124\n\x0bACCELERATOR\x10\0\x1a#\xa2\xb4\xfa\xc2\x05\x1dbeam:resources:\
    accelerator:v1\x128\n\rMIN_RAM_BYTES\x10\x01\x1a%\xa2\xb4\xfa\xc2\x05\
    \x1fbeam:resources:min_ram_bytes:v12\x8f\x01\n\x11TestStreamService\x12z\
    \n\x06Events\x120.org.apache.beam.model.pipeline.v1.EventsRequest\x1a:.o\
    rg.apache.beam.model.pipeline.v1.TestStreamPayload.Event\"\00\x01:?\n\
    \x08beam_urn\x18\xc4\xa6\xafX\x20\x01(\t\x12!.google.protobuf.EnumValueO\
    ptionsR\x07beamUrn:I\n\rbeam_constant\x18\xc5\xa6\xafX\x20\x01(\t\x12!.g\
    oogle.protobuf.EnumValueOptionsR\x0cbeamConstantBx\n!org.apache.beam.mod\
    el.pipeline.v1B\tRunnerApiZHgithub.com/apache/beam/sdks/v2/go/pkg/beam/m\
    odel/pipeline_v1;pipeline_v1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::endpoints::file_descriptor().clone());
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(87);
            messages.push(BeamConstants::generated_message_descriptor_data());
            messages.push(Components::generated_message_descriptor_data());
            messages.push(Pipeline::generated_message_descriptor_data());
            messages.push(PTransform::generated_message_descriptor_data());
            messages.push(StandardPTransforms::generated_message_descriptor_data());
            messages.push(StandardSideInputTypes::generated_message_descriptor_data());
            messages.push(StandardUserStateTypes::generated_message_descriptor_data());
            messages.push(PCollection::generated_message_descriptor_data());
            messages.push(ParDoPayload::generated_message_descriptor_data());
            messages.push(StateSpec::generated_message_descriptor_data());
            messages.push(ReadModifyWriteStateSpec::generated_message_descriptor_data());
            messages.push(BagStateSpec::generated_message_descriptor_data());
            messages.push(OrderedListStateSpec::generated_message_descriptor_data());
            messages.push(CombiningStateSpec::generated_message_descriptor_data());
            messages.push(MapStateSpec::generated_message_descriptor_data());
            messages.push(SetStateSpec::generated_message_descriptor_data());
            messages.push(TimerFamilySpec::generated_message_descriptor_data());
            messages.push(IsBounded::generated_message_descriptor_data());
            messages.push(ReadPayload::generated_message_descriptor_data());
            messages.push(WindowIntoPayload::generated_message_descriptor_data());
            messages.push(CombinePayload::generated_message_descriptor_data());
            messages.push(TestStreamPayload::generated_message_descriptor_data());
            messages.push(EventsRequest::generated_message_descriptor_data());
            messages.push(WriteFilesPayload::generated_message_descriptor_data());
            messages.push(PubSubReadPayload::generated_message_descriptor_data());
            messages.push(PubSubWritePayload::generated_message_descriptor_data());
            messages.push(GroupIntoBatchesPayload::generated_message_descriptor_data());
            messages.push(Coder::generated_message_descriptor_data());
            messages.push(StandardCoders::generated_message_descriptor_data());
            messages.push(WindowingStrategy::generated_message_descriptor_data());
            messages.push(MergeStatus::generated_message_descriptor_data());
            messages.push(AccumulationMode::generated_message_descriptor_data());
            messages.push(ClosingBehavior::generated_message_descriptor_data());
            messages.push(OnTimeBehavior::generated_message_descriptor_data());
            messages.push(OutputTime::generated_message_descriptor_data());
            messages.push(TimeDomain::generated_message_descriptor_data());
            messages.push(Trigger::generated_message_descriptor_data());
            messages.push(TimestampTransform::generated_message_descriptor_data());
            messages.push(SideInput::generated_message_descriptor_data());
            messages.push(StandardArtifacts::generated_message_descriptor_data());
            messages.push(ArtifactFilePayload::generated_message_descriptor_data());
            messages.push(ArtifactUrlPayload::generated_message_descriptor_data());
            messages.push(EmbeddedFilePayload::generated_message_descriptor_data());
            messages.push(PyPIPayload::generated_message_descriptor_data());
            messages.push(MavenPayload::generated_message_descriptor_data());
            messages.push(DeferredArtifactPayload::generated_message_descriptor_data());
            messages.push(ArtifactStagingToRolePayload::generated_message_descriptor_data());
            messages.push(ArtifactInformation::generated_message_descriptor_data());
            messages.push(Environment::generated_message_descriptor_data());
            messages.push(StandardEnvironments::generated_message_descriptor_data());
            messages.push(DockerPayload::generated_message_descriptor_data());
            messages.push(ProcessPayload::generated_message_descriptor_data());
            messages.push(ExternalPayload::generated_message_descriptor_data());
            messages.push(StandardProtocols::generated_message_descriptor_data());
            messages.push(StandardRunnerProtocols::generated_message_descriptor_data());
            messages.push(StandardRequirements::generated_message_descriptor_data());
            messages.push(FunctionSpec::generated_message_descriptor_data());
            messages.push(StandardDisplayData::generated_message_descriptor_data());
            messages.push(LabelledPayload::generated_message_descriptor_data());
            messages.push(DisplayData::generated_message_descriptor_data());
            messages.push(MessageWithComponents::generated_message_descriptor_data());
            messages.push(ExecutableStagePayload::generated_message_descriptor_data());
            messages.push(StandardResourceHints::generated_message_descriptor_data());
            messages.push(test_stream_payload::Event::generated_message_descriptor_data());
            messages.push(test_stream_payload::TimestampedElement::generated_message_descriptor_data());
            messages.push(test_stream_payload::event::AdvanceWatermark::generated_message_descriptor_data());
            messages.push(test_stream_payload::event::AdvanceProcessingTime::generated_message_descriptor_data());
            messages.push(test_stream_payload::event::AddElements::generated_message_descriptor_data());
            messages.push(trigger::AfterAll::generated_message_descriptor_data());
            messages.push(trigger::AfterAny::generated_message_descriptor_data());
            messages.push(trigger::AfterEach::generated_message_descriptor_data());
            messages.push(trigger::AfterEndOfWindow::generated_message_descriptor_data());
            messages.push(trigger::AfterProcessingTime::generated_message_descriptor_data());
            messages.push(trigger::AfterSynchronizedProcessingTime::generated_message_descriptor_data());
            messages.push(trigger::Default::generated_message_descriptor_data());
            messages.push(trigger::ElementCount::generated_message_descriptor_data());
            messages.push(trigger::Never::generated_message_descriptor_data());
            messages.push(trigger::Always::generated_message_descriptor_data());
            messages.push(trigger::OrFinally::generated_message_descriptor_data());
            messages.push(trigger::Repeat::generated_message_descriptor_data());
            messages.push(timestamp_transform::Delay::generated_message_descriptor_data());
            messages.push(timestamp_transform::AlignTo::generated_message_descriptor_data());
            messages.push(executable_stage_payload::SideInputId::generated_message_descriptor_data());
            messages.push(executable_stage_payload::UserStateId::generated_message_descriptor_data());
            messages.push(executable_stage_payload::TimerId::generated_message_descriptor_data());
            messages.push(executable_stage_payload::TimerFamilyId::generated_message_descriptor_data());
            messages.push(executable_stage_payload::WireCoderSetting::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(25);
            enums.push(beam_constants::Constants::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::Primitives::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::DeprecatedPrimitives::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::Composites::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::CombineComponents::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::SplittableParDoComponents::generated_enum_descriptor_data());
            enums.push(standard_ptransforms::GroupIntoBatchesComponents::generated_enum_descriptor_data());
            enums.push(standard_side_input_types::Enum::generated_enum_descriptor_data());
            enums.push(standard_user_state_types::Enum::generated_enum_descriptor_data());
            enums.push(is_bounded::Enum::generated_enum_descriptor_data());
            enums.push(standard_coders::Enum::generated_enum_descriptor_data());
            enums.push(merge_status::Enum::generated_enum_descriptor_data());
            enums.push(accumulation_mode::Enum::generated_enum_descriptor_data());
            enums.push(closing_behavior::Enum::generated_enum_descriptor_data());
            enums.push(on_time_behavior::Enum::generated_enum_descriptor_data());
            enums.push(output_time::Enum::generated_enum_descriptor_data());
            enums.push(time_domain::Enum::generated_enum_descriptor_data());
            enums.push(standard_artifacts::Types::generated_enum_descriptor_data());
            enums.push(standard_artifacts::Roles::generated_enum_descriptor_data());
            enums.push(standard_environments::Environments::generated_enum_descriptor_data());
            enums.push(standard_protocols::Enum::generated_enum_descriptor_data());
            enums.push(standard_runner_protocols::Enum::generated_enum_descriptor_data());
            enums.push(standard_requirements::Enum::generated_enum_descriptor_data());
            enums.push(standard_display_data::DisplayData::generated_enum_descriptor_data());
            enums.push(standard_resource_hints::Enum::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
