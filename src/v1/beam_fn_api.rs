// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.21.5
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `org/apache/beam/model/fn_execution/v1/beam_fn_api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.RemoteGrpcPort)
pub struct RemoteGrpcPort {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.RemoteGrpcPort.api_service_descriptor)
    pub api_service_descriptor: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.RemoteGrpcPort.coder_id)
    pub coder_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.RemoteGrpcPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoteGrpcPort {
    fn default() -> &'a RemoteGrpcPort {
        <RemoteGrpcPort as ::protobuf::Message>::default_instance()
    }
}

impl RemoteGrpcPort {
    pub fn new() -> RemoteGrpcPort {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "api_service_descriptor",
            |m: &RemoteGrpcPort| { &m.api_service_descriptor },
            |m: &mut RemoteGrpcPort| { &mut m.api_service_descriptor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coder_id",
            |m: &RemoteGrpcPort| { &m.coder_id },
            |m: &mut RemoteGrpcPort| { &mut m.coder_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoteGrpcPort>(
            "RemoteGrpcPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoteGrpcPort {
    const NAME: &'static str = "RemoteGrpcPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.api_service_descriptor)?;
                },
                18 => {
                    self.coder_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.api_service_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.coder_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.coder_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.api_service_descriptor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.coder_id.is_empty() {
            os.write_string(2, &self.coder_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoteGrpcPort {
        RemoteGrpcPort::new()
    }

    fn clear(&mut self) {
        self.api_service_descriptor.clear();
        self.coder_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoteGrpcPort {
        static instance: RemoteGrpcPort = RemoteGrpcPort {
            api_service_descriptor: ::protobuf::MessageField::none(),
            coder_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoteGrpcPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoteGrpcPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoteGrpcPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteGrpcPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.GetProcessBundleDescriptorRequest)
pub struct GetProcessBundleDescriptorRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.GetProcessBundleDescriptorRequest.process_bundle_descriptor_id)
    pub process_bundle_descriptor_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.GetProcessBundleDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetProcessBundleDescriptorRequest {
    fn default() -> &'a GetProcessBundleDescriptorRequest {
        <GetProcessBundleDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProcessBundleDescriptorRequest {
    pub fn new() -> GetProcessBundleDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_bundle_descriptor_id",
            |m: &GetProcessBundleDescriptorRequest| { &m.process_bundle_descriptor_id },
            |m: &mut GetProcessBundleDescriptorRequest| { &mut m.process_bundle_descriptor_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProcessBundleDescriptorRequest>(
            "GetProcessBundleDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetProcessBundleDescriptorRequest {
    const NAME: &'static str = "GetProcessBundleDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.process_bundle_descriptor_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.process_bundle_descriptor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.process_bundle_descriptor_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.process_bundle_descriptor_id.is_empty() {
            os.write_string(1, &self.process_bundle_descriptor_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetProcessBundleDescriptorRequest {
        GetProcessBundleDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.process_bundle_descriptor_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetProcessBundleDescriptorRequest {
        static instance: GetProcessBundleDescriptorRequest = GetProcessBundleDescriptorRequest {
            process_bundle_descriptor_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetProcessBundleDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetProcessBundleDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetProcessBundleDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProcessBundleDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.InstructionRequest)
pub struct InstructionRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.InstructionRequest.instruction_id)
    pub instruction_id: ::std::string::String,
    // message oneof groups
    pub request: ::std::option::Option<instruction_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstructionRequest {
    fn default() -> &'a InstructionRequest {
        <InstructionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstructionRequest {
    pub fn new() -> InstructionRequest {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleRequest process_bundle = 1001;

    pub fn process_bundle(&self) -> &ProcessBundleRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundle(ref v)) => v,
            _ => <ProcessBundleRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_process_bundle(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle(&mut self, v: ProcessBundleRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle(&mut self) -> &mut ProcessBundleRequest {
        if let ::std::option::Option::Some(instruction_request::Request::ProcessBundle(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundle(ProcessBundleRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle(&mut self) -> ProcessBundleRequest {
        if self.has_process_bundle() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::ProcessBundle(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleProgressRequest process_bundle_progress = 1002;

    pub fn process_bundle_progress(&self) -> &ProcessBundleProgressRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(ref v)) => v,
            _ => <ProcessBundleProgressRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle_progress(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_process_bundle_progress(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle_progress(&mut self, v: ProcessBundleProgressRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle_progress(&mut self) -> &mut ProcessBundleProgressRequest {
        if let ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(ProcessBundleProgressRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle_progress(&mut self) -> ProcessBundleProgressRequest {
        if self.has_process_bundle_progress() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleProgressRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest process_bundle_split = 1003;

    pub fn process_bundle_split(&self) -> &ProcessBundleSplitRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(ref v)) => v,
            _ => <ProcessBundleSplitRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle_split(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_process_bundle_split(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle_split(&mut self, v: ProcessBundleSplitRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle_split(&mut self) -> &mut ProcessBundleSplitRequest {
        if let ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(ProcessBundleSplitRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle_split(&mut self) -> ProcessBundleSplitRequest {
        if self.has_process_bundle_split() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleSplitRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.FinalizeBundleRequest finalize_bundle = 1004;

    pub fn finalize_bundle(&self) -> &FinalizeBundleRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(ref v)) => v,
            _ => <FinalizeBundleRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finalize_bundle(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_finalize_bundle(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finalize_bundle(&mut self, v: FinalizeBundleRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finalize_bundle(&mut self) -> &mut FinalizeBundleRequest {
        if let ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(FinalizeBundleRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finalize_bundle(&mut self) -> FinalizeBundleRequest {
        if self.has_finalize_bundle() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(v)) => v,
                _ => panic!(),
            }
        } else {
            FinalizeBundleRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataRequest monitoring_infos = 1005;

    pub fn monitoring_infos(&self) -> &MonitoringInfosMetadataRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(ref v)) => v,
            _ => <MonitoringInfosMetadataRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_monitoring_infos(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_monitoring_infos(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_monitoring_infos(&mut self, v: MonitoringInfosMetadataRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_monitoring_infos(&mut self) -> &mut MonitoringInfosMetadataRequest {
        if let ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(MonitoringInfosMetadataRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_monitoring_infos(&mut self) -> MonitoringInfosMetadataRequest {
        if self.has_monitoring_infos() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitoringInfosMetadataRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosRequest harness_monitoring_infos = 1006;

    pub fn harness_monitoring_infos(&self) -> &HarnessMonitoringInfosRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(ref v)) => v,
            _ => <HarnessMonitoringInfosRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_harness_monitoring_infos(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_harness_monitoring_infos(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_harness_monitoring_infos(&mut self, v: HarnessMonitoringInfosRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_harness_monitoring_infos(&mut self) -> &mut HarnessMonitoringInfosRequest {
        if let ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(HarnessMonitoringInfosRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_harness_monitoring_infos(&mut self) -> HarnessMonitoringInfosRequest {
        if self.has_harness_monitoring_infos() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(v)) => v,
                _ => panic!(),
            }
        } else {
            HarnessMonitoringInfosRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.RegisterRequest register = 1000;

    pub fn register(&self) -> &RegisterRequest {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::Register(ref v)) => v,
            _ => <RegisterRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_register(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::Register(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register(&mut self, v: RegisterRequest) {
        self.request = ::std::option::Option::Some(instruction_request::Request::Register(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register(&mut self) -> &mut RegisterRequest {
        if let ::std::option::Option::Some(instruction_request::Request::Register(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(instruction_request::Request::Register(RegisterRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(instruction_request::Request::Register(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register(&mut self) -> RegisterRequest {
        if self.has_register() {
            match self.request.take() {
                ::std::option::Option::Some(instruction_request::Request::Register(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &InstructionRequest| { &m.instruction_id },
            |m: &mut InstructionRequest| { &mut m.instruction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleRequest>(
            "process_bundle",
            InstructionRequest::has_process_bundle,
            InstructionRequest::process_bundle,
            InstructionRequest::mut_process_bundle,
            InstructionRequest::set_process_bundle,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleProgressRequest>(
            "process_bundle_progress",
            InstructionRequest::has_process_bundle_progress,
            InstructionRequest::process_bundle_progress,
            InstructionRequest::mut_process_bundle_progress,
            InstructionRequest::set_process_bundle_progress,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleSplitRequest>(
            "process_bundle_split",
            InstructionRequest::has_process_bundle_split,
            InstructionRequest::process_bundle_split,
            InstructionRequest::mut_process_bundle_split,
            InstructionRequest::set_process_bundle_split,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FinalizeBundleRequest>(
            "finalize_bundle",
            InstructionRequest::has_finalize_bundle,
            InstructionRequest::finalize_bundle,
            InstructionRequest::mut_finalize_bundle,
            InstructionRequest::set_finalize_bundle,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MonitoringInfosMetadataRequest>(
            "monitoring_infos",
            InstructionRequest::has_monitoring_infos,
            InstructionRequest::monitoring_infos,
            InstructionRequest::mut_monitoring_infos,
            InstructionRequest::set_monitoring_infos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HarnessMonitoringInfosRequest>(
            "harness_monitoring_infos",
            InstructionRequest::has_harness_monitoring_infos,
            InstructionRequest::harness_monitoring_infos,
            InstructionRequest::mut_harness_monitoring_infos,
            InstructionRequest::set_harness_monitoring_infos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterRequest>(
            "register",
            InstructionRequest::has_register,
            InstructionRequest::register,
            InstructionRequest::mut_register,
            InstructionRequest::set_register,
        ));
        oneofs.push(instruction_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstructionRequest>(
            "InstructionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstructionRequest {
    const NAME: &'static str = "InstructionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instruction_id = is.read_string()?;
                },
                8010 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundle(is.read_message()?));
                },
                8018 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleProgress(is.read_message()?));
                },
                8026 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::ProcessBundleSplit(is.read_message()?));
                },
                8034 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::FinalizeBundle(is.read_message()?));
                },
                8042 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::MonitoringInfos(is.read_message()?));
                },
                8050 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::HarnessMonitoringInfos(is.read_message()?));
                },
                8002 => {
                    self.request = ::std::option::Option::Some(instruction_request::Request::Register(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &instruction_request::Request::ProcessBundle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::ProcessBundleProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::ProcessBundleSplit(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::FinalizeBundle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::MonitoringInfos(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::HarnessMonitoringInfos(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_request::Request::Register(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.instruction_id.is_empty() {
            os.write_string(1, &self.instruction_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &instruction_request::Request::ProcessBundle(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
                &instruction_request::Request::ProcessBundleProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
                },
                &instruction_request::Request::ProcessBundleSplit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1003, v, os)?;
                },
                &instruction_request::Request::FinalizeBundle(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1004, v, os)?;
                },
                &instruction_request::Request::MonitoringInfos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1005, v, os)?;
                },
                &instruction_request::Request::HarnessMonitoringInfos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1006, v, os)?;
                },
                &instruction_request::Request::Register(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstructionRequest {
        InstructionRequest::new()
    }

    fn clear(&mut self) {
        self.instruction_id.clear();
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstructionRequest {
        static instance: InstructionRequest = InstructionRequest {
            instruction_id: ::std::string::String::new(),
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstructionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstructionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstructionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstructionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InstructionRequest`
pub mod instruction_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.InstructionRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.process_bundle)
        ProcessBundle(super::ProcessBundleRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.process_bundle_progress)
        ProcessBundleProgress(super::ProcessBundleProgressRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.process_bundle_split)
        ProcessBundleSplit(super::ProcessBundleSplitRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.finalize_bundle)
        FinalizeBundle(super::FinalizeBundleRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.monitoring_infos)
        MonitoringInfos(super::MonitoringInfosMetadataRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.harness_monitoring_infos)
        HarnessMonitoringInfos(super::HarnessMonitoringInfosRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionRequest.register)
        Register(super::RegisterRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InstructionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.InstructionResponse)
pub struct InstructionResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.InstructionResponse.instruction_id)
    pub instruction_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.InstructionResponse.error)
    pub error: ::std::string::String,
    // message oneof groups
    pub response: ::std::option::Option<instruction_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstructionResponse {
    fn default() -> &'a InstructionResponse {
        <InstructionResponse as ::protobuf::Message>::default_instance()
    }
}

impl InstructionResponse {
    pub fn new() -> InstructionResponse {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleResponse process_bundle = 1001;

    pub fn process_bundle(&self) -> &ProcessBundleResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundle(ref v)) => v,
            _ => <ProcessBundleResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_process_bundle(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle(&mut self, v: ProcessBundleResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle(&mut self) -> &mut ProcessBundleResponse {
        if let ::std::option::Option::Some(instruction_response::Response::ProcessBundle(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundle(ProcessBundleResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle(&mut self) -> ProcessBundleResponse {
        if self.has_process_bundle() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::ProcessBundle(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleProgressResponse process_bundle_progress = 1002;

    pub fn process_bundle_progress(&self) -> &ProcessBundleProgressResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(ref v)) => v,
            _ => <ProcessBundleProgressResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle_progress(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_process_bundle_progress(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle_progress(&mut self, v: ProcessBundleProgressResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle_progress(&mut self) -> &mut ProcessBundleProgressResponse {
        if let ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(ProcessBundleProgressResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle_progress(&mut self) -> ProcessBundleProgressResponse {
        if self.has_process_bundle_progress() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleProgressResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse process_bundle_split = 1003;

    pub fn process_bundle_split(&self) -> &ProcessBundleSplitResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(ref v)) => v,
            _ => <ProcessBundleSplitResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_process_bundle_split(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_process_bundle_split(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_bundle_split(&mut self, v: ProcessBundleSplitResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_bundle_split(&mut self) -> &mut ProcessBundleSplitResponse {
        if let ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(ProcessBundleSplitResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_bundle_split(&mut self) -> ProcessBundleSplitResponse {
        if self.has_process_bundle_split() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(v)) => v,
                _ => panic!(),
            }
        } else {
            ProcessBundleSplitResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.FinalizeBundleResponse finalize_bundle = 1004;

    pub fn finalize_bundle(&self) -> &FinalizeBundleResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(ref v)) => v,
            _ => <FinalizeBundleResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finalize_bundle(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_finalize_bundle(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finalize_bundle(&mut self, v: FinalizeBundleResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finalize_bundle(&mut self) -> &mut FinalizeBundleResponse {
        if let ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(FinalizeBundleResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finalize_bundle(&mut self) -> FinalizeBundleResponse {
        if self.has_finalize_bundle() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(v)) => v,
                _ => panic!(),
            }
        } else {
            FinalizeBundleResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataResponse monitoring_infos = 1005;

    pub fn monitoring_infos(&self) -> &MonitoringInfosMetadataResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(ref v)) => v,
            _ => <MonitoringInfosMetadataResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_monitoring_infos(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_monitoring_infos(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_monitoring_infos(&mut self, v: MonitoringInfosMetadataResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_monitoring_infos(&mut self) -> &mut MonitoringInfosMetadataResponse {
        if let ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(MonitoringInfosMetadataResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_monitoring_infos(&mut self) -> MonitoringInfosMetadataResponse {
        if self.has_monitoring_infos() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(v)) => v,
                _ => panic!(),
            }
        } else {
            MonitoringInfosMetadataResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosResponse harness_monitoring_infos = 1006;

    pub fn harness_monitoring_infos(&self) -> &HarnessMonitoringInfosResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(ref v)) => v,
            _ => <HarnessMonitoringInfosResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_harness_monitoring_infos(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_harness_monitoring_infos(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_harness_monitoring_infos(&mut self, v: HarnessMonitoringInfosResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_harness_monitoring_infos(&mut self) -> &mut HarnessMonitoringInfosResponse {
        if let ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(HarnessMonitoringInfosResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_harness_monitoring_infos(&mut self) -> HarnessMonitoringInfosResponse {
        if self.has_harness_monitoring_infos() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(v)) => v,
                _ => panic!(),
            }
        } else {
            HarnessMonitoringInfosResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.RegisterResponse register = 1000;

    pub fn register(&self) -> &RegisterResponse {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::Register(ref v)) => v,
            _ => <RegisterResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_register(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::Register(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register(&mut self, v: RegisterResponse) {
        self.response = ::std::option::Option::Some(instruction_response::Response::Register(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register(&mut self) -> &mut RegisterResponse {
        if let ::std::option::Option::Some(instruction_response::Response::Register(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(instruction_response::Response::Register(RegisterResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(instruction_response::Response::Register(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register(&mut self) -> RegisterResponse {
        if self.has_register() {
            match self.response.take() {
                ::std::option::Option::Some(instruction_response::Response::Register(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &InstructionResponse| { &m.instruction_id },
            |m: &mut InstructionResponse| { &mut m.instruction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &InstructionResponse| { &m.error },
            |m: &mut InstructionResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleResponse>(
            "process_bundle",
            InstructionResponse::has_process_bundle,
            InstructionResponse::process_bundle,
            InstructionResponse::mut_process_bundle,
            InstructionResponse::set_process_bundle,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleProgressResponse>(
            "process_bundle_progress",
            InstructionResponse::has_process_bundle_progress,
            InstructionResponse::process_bundle_progress,
            InstructionResponse::mut_process_bundle_progress,
            InstructionResponse::set_process_bundle_progress,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProcessBundleSplitResponse>(
            "process_bundle_split",
            InstructionResponse::has_process_bundle_split,
            InstructionResponse::process_bundle_split,
            InstructionResponse::mut_process_bundle_split,
            InstructionResponse::set_process_bundle_split,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FinalizeBundleResponse>(
            "finalize_bundle",
            InstructionResponse::has_finalize_bundle,
            InstructionResponse::finalize_bundle,
            InstructionResponse::mut_finalize_bundle,
            InstructionResponse::set_finalize_bundle,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MonitoringInfosMetadataResponse>(
            "monitoring_infos",
            InstructionResponse::has_monitoring_infos,
            InstructionResponse::monitoring_infos,
            InstructionResponse::mut_monitoring_infos,
            InstructionResponse::set_monitoring_infos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HarnessMonitoringInfosResponse>(
            "harness_monitoring_infos",
            InstructionResponse::has_harness_monitoring_infos,
            InstructionResponse::harness_monitoring_infos,
            InstructionResponse::mut_harness_monitoring_infos,
            InstructionResponse::set_harness_monitoring_infos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterResponse>(
            "register",
            InstructionResponse::has_register,
            InstructionResponse::register,
            InstructionResponse::mut_register,
            InstructionResponse::set_register,
        ));
        oneofs.push(instruction_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstructionResponse>(
            "InstructionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstructionResponse {
    const NAME: &'static str = "InstructionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instruction_id = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                8010 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundle(is.read_message()?));
                },
                8018 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleProgress(is.read_message()?));
                },
                8026 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::ProcessBundleSplit(is.read_message()?));
                },
                8034 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::FinalizeBundle(is.read_message()?));
                },
                8042 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::MonitoringInfos(is.read_message()?));
                },
                8050 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::HarnessMonitoringInfos(is.read_message()?));
                },
                8002 => {
                    self.response = ::std::option::Option::Some(instruction_response::Response::Register(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &instruction_response::Response::ProcessBundle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::ProcessBundleProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::ProcessBundleSplit(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::FinalizeBundle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::MonitoringInfos(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::HarnessMonitoringInfos(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &instruction_response::Response::Register(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.instruction_id.is_empty() {
            os.write_string(1, &self.instruction_id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &instruction_response::Response::ProcessBundle(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
                &instruction_response::Response::ProcessBundleProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
                },
                &instruction_response::Response::ProcessBundleSplit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1003, v, os)?;
                },
                &instruction_response::Response::FinalizeBundle(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1004, v, os)?;
                },
                &instruction_response::Response::MonitoringInfos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1005, v, os)?;
                },
                &instruction_response::Response::HarnessMonitoringInfos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1006, v, os)?;
                },
                &instruction_response::Response::Register(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstructionResponse {
        InstructionResponse::new()
    }

    fn clear(&mut self) {
        self.instruction_id.clear();
        self.error.clear();
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstructionResponse {
        static instance: InstructionResponse = InstructionResponse {
            instruction_id: ::std::string::String::new(),
            error: ::std::string::String::new(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstructionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstructionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstructionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstructionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InstructionResponse`
pub mod instruction_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.InstructionResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.process_bundle)
        ProcessBundle(super::ProcessBundleResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.process_bundle_progress)
        ProcessBundleProgress(super::ProcessBundleProgressResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.process_bundle_split)
        ProcessBundleSplit(super::ProcessBundleSplitResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.finalize_bundle)
        FinalizeBundle(super::FinalizeBundleResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.monitoring_infos)
        MonitoringInfos(super::MonitoringInfosMetadataResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.harness_monitoring_infos)
        HarnessMonitoringInfos(super::HarnessMonitoringInfosResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.InstructionResponse.register)
        Register(super::RegisterResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InstructionResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosRequest)
pub struct HarnessMonitoringInfosRequest {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HarnessMonitoringInfosRequest {
    fn default() -> &'a HarnessMonitoringInfosRequest {
        <HarnessMonitoringInfosRequest as ::protobuf::Message>::default_instance()
    }
}

impl HarnessMonitoringInfosRequest {
    pub fn new() -> HarnessMonitoringInfosRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HarnessMonitoringInfosRequest>(
            "HarnessMonitoringInfosRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HarnessMonitoringInfosRequest {
    const NAME: &'static str = "HarnessMonitoringInfosRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HarnessMonitoringInfosRequest {
        HarnessMonitoringInfosRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HarnessMonitoringInfosRequest {
        static instance: HarnessMonitoringInfosRequest = HarnessMonitoringInfosRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HarnessMonitoringInfosRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HarnessMonitoringInfosRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HarnessMonitoringInfosRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HarnessMonitoringInfosRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosResponse)
pub struct HarnessMonitoringInfosResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosResponse.monitoring_data)
    pub monitoring_data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HarnessMonitoringInfosResponse {
    fn default() -> &'a HarnessMonitoringInfosResponse {
        <HarnessMonitoringInfosResponse as ::protobuf::Message>::default_instance()
    }
}

impl HarnessMonitoringInfosResponse {
    pub fn new() -> HarnessMonitoringInfosResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "monitoring_data",
            |m: &HarnessMonitoringInfosResponse| { &m.monitoring_data },
            |m: &mut HarnessMonitoringInfosResponse| { &mut m.monitoring_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HarnessMonitoringInfosResponse>(
            "HarnessMonitoringInfosResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HarnessMonitoringInfosResponse {
    const NAME: &'static str = "HarnessMonitoringInfosResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.monitoring_data.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HarnessMonitoringInfosResponse {
        HarnessMonitoringInfosResponse::new()
    }

    fn clear(&mut self) {
        self.monitoring_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HarnessMonitoringInfosResponse {
        static instance: ::protobuf::rt::Lazy<HarnessMonitoringInfosResponse> = ::protobuf::rt::Lazy::new();
        instance.get(HarnessMonitoringInfosResponse::new)
    }
}

impl ::protobuf::MessageFull for HarnessMonitoringInfosResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HarnessMonitoringInfosResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HarnessMonitoringInfosResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HarnessMonitoringInfosResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.RegisterRequest)
pub struct RegisterRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.RegisterRequest.process_bundle_descriptor)
    pub process_bundle_descriptor: ::std::vec::Vec<ProcessBundleDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.RegisterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterRequest {
    fn default() -> &'a RegisterRequest {
        <RegisterRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterRequest {
    pub fn new() -> RegisterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "process_bundle_descriptor",
            |m: &RegisterRequest| { &m.process_bundle_descriptor },
            |m: &mut RegisterRequest| { &mut m.process_bundle_descriptor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterRequest>(
            "RegisterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterRequest {
    const NAME: &'static str = "RegisterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.process_bundle_descriptor.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.process_bundle_descriptor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.process_bundle_descriptor {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterRequest {
        RegisterRequest::new()
    }

    fn clear(&mut self) {
        self.process_bundle_descriptor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterRequest {
        static instance: RegisterRequest = RegisterRequest {
            process_bundle_descriptor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.RegisterResponse)
pub struct RegisterResponse {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.RegisterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterResponse {
    fn default() -> &'a RegisterResponse {
        <RegisterResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterResponse {
    pub fn new() -> RegisterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterResponse>(
            "RegisterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterResponse {
    const NAME: &'static str = "RegisterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterResponse {
        RegisterResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterResponse {
        static instance: RegisterResponse = RegisterResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor)
pub struct ProcessBundleDescriptor {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.transforms)
    pub transforms: ::std::collections::HashMap<::std::string::String, super::beam_runner_api::PTransform>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.pcollections)
    pub pcollections: ::std::collections::HashMap<::std::string::String, super::beam_runner_api::PCollection>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.windowing_strategies)
    pub windowing_strategies: ::std::collections::HashMap<::std::string::String, super::beam_runner_api::WindowingStrategy>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.coders)
    pub coders: ::std::collections::HashMap<::std::string::String, super::beam_runner_api::Coder>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.environments)
    pub environments: ::std::collections::HashMap<::std::string::String, super::beam_runner_api::Environment>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.state_api_service_descriptor)
    pub state_api_service_descriptor: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.timer_api_service_descriptor)
    pub timer_api_service_descriptor: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleDescriptor {
    fn default() -> &'a ProcessBundleDescriptor {
        <ProcessBundleDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleDescriptor {
    pub fn new() -> ProcessBundleDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ProcessBundleDescriptor| { &m.id },
            |m: &mut ProcessBundleDescriptor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "transforms",
            |m: &ProcessBundleDescriptor| { &m.transforms },
            |m: &mut ProcessBundleDescriptor| { &mut m.transforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "pcollections",
            |m: &ProcessBundleDescriptor| { &m.pcollections },
            |m: &mut ProcessBundleDescriptor| { &mut m.pcollections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "windowing_strategies",
            |m: &ProcessBundleDescriptor| { &m.windowing_strategies },
            |m: &mut ProcessBundleDescriptor| { &mut m.windowing_strategies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "coders",
            |m: &ProcessBundleDescriptor| { &m.coders },
            |m: &mut ProcessBundleDescriptor| { &mut m.coders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "environments",
            |m: &ProcessBundleDescriptor| { &m.environments },
            |m: &mut ProcessBundleDescriptor| { &mut m.environments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "state_api_service_descriptor",
            |m: &ProcessBundleDescriptor| { &m.state_api_service_descriptor },
            |m: &mut ProcessBundleDescriptor| { &mut m.state_api_service_descriptor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "timer_api_service_descriptor",
            |m: &ProcessBundleDescriptor| { &m.timer_api_service_descriptor },
            |m: &mut ProcessBundleDescriptor| { &mut m.timer_api_service_descriptor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleDescriptor>(
            "ProcessBundleDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleDescriptor {
    const NAME: &'static str = "ProcessBundleDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.transforms.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.pcollections.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.windowing_strategies.insert(key, value);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.coders.insert(key, value);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.environments.insert(key, value);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_api_service_descriptor)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timer_api_service_descriptor)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for (k, v) in &self.transforms {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.pcollections {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.windowing_strategies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.coders {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.environments {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.state_api_service_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timer_api_service_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for (k, v) in &self.transforms {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.pcollections {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.windowing_strategies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.coders {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.environments {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.state_api_service_descriptor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.timer_api_service_descriptor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleDescriptor {
        ProcessBundleDescriptor::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.transforms.clear();
        self.pcollections.clear();
        self.windowing_strategies.clear();
        self.coders.clear();
        self.environments.clear();
        self.state_api_service_descriptor.clear();
        self.timer_api_service_descriptor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleDescriptor {
        static instance: ::protobuf::rt::Lazy<ProcessBundleDescriptor> = ::protobuf::rt::Lazy::new();
        instance.get(ProcessBundleDescriptor::new)
    }
}

impl ::protobuf::MessageFull for ProcessBundleDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.BundleApplication)
pub struct BundleApplication {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.BundleApplication.transform_id)
    pub transform_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.BundleApplication.input_id)
    pub input_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.BundleApplication.element)
    pub element: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.BundleApplication.output_watermarks)
    pub output_watermarks: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.BundleApplication.is_bounded)
    pub is_bounded: ::protobuf::EnumOrUnknown<super::beam_runner_api::is_bounded::Enum>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.BundleApplication.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BundleApplication {
    fn default() -> &'a BundleApplication {
        <BundleApplication as ::protobuf::Message>::default_instance()
    }
}

impl BundleApplication {
    pub fn new() -> BundleApplication {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transform_id",
            |m: &BundleApplication| { &m.transform_id },
            |m: &mut BundleApplication| { &mut m.transform_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &BundleApplication| { &m.input_id },
            |m: &mut BundleApplication| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "element",
            |m: &BundleApplication| { &m.element },
            |m: &mut BundleApplication| { &mut m.element },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "output_watermarks",
            |m: &BundleApplication| { &m.output_watermarks },
            |m: &mut BundleApplication| { &mut m.output_watermarks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bounded",
            |m: &BundleApplication| { &m.is_bounded },
            |m: &mut BundleApplication| { &mut m.is_bounded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BundleApplication>(
            "BundleApplication",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BundleApplication {
    const NAME: &'static str = "BundleApplication";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transform_id = is.read_string()?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                26 => {
                    self.element = is.read_bytes()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.output_watermarks.insert(key, value);
                },
                40 => {
                    self.is_bounded = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.transform_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transform_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.element.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.element);
        }
        for (k, v) in &self.output_watermarks {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(super::beam_runner_api::is_bounded::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.is_bounded.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.transform_id.is_empty() {
            os.write_string(1, &self.transform_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.element.is_empty() {
            os.write_bytes(3, &self.element)?;
        }
        for (k, v) in &self.output_watermarks {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.is_bounded != ::protobuf::EnumOrUnknown::new(super::beam_runner_api::is_bounded::Enum::UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.is_bounded))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BundleApplication {
        BundleApplication::new()
    }

    fn clear(&mut self) {
        self.transform_id.clear();
        self.input_id.clear();
        self.element.clear();
        self.output_watermarks.clear();
        self.is_bounded = ::protobuf::EnumOrUnknown::new(super::beam_runner_api::is_bounded::Enum::UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BundleApplication {
        static instance: ::protobuf::rt::Lazy<BundleApplication> = ::protobuf::rt::Lazy::new();
        instance.get(BundleApplication::new)
    }
}

impl ::protobuf::MessageFull for BundleApplication {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BundleApplication").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BundleApplication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BundleApplication {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.DelayedBundleApplication)
pub struct DelayedBundleApplication {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.DelayedBundleApplication.application)
    pub application: ::protobuf::MessageField<BundleApplication>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.DelayedBundleApplication.requested_time_delay)
    pub requested_time_delay: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.DelayedBundleApplication.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelayedBundleApplication {
    fn default() -> &'a DelayedBundleApplication {
        <DelayedBundleApplication as ::protobuf::Message>::default_instance()
    }
}

impl DelayedBundleApplication {
    pub fn new() -> DelayedBundleApplication {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BundleApplication>(
            "application",
            |m: &DelayedBundleApplication| { &m.application },
            |m: &mut DelayedBundleApplication| { &mut m.application },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "requested_time_delay",
            |m: &DelayedBundleApplication| { &m.requested_time_delay },
            |m: &mut DelayedBundleApplication| { &mut m.requested_time_delay },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelayedBundleApplication>(
            "DelayedBundleApplication",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelayedBundleApplication {
    const NAME: &'static str = "DelayedBundleApplication";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.application)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requested_time_delay)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.application.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requested_time_delay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.application.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.requested_time_delay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelayedBundleApplication {
        DelayedBundleApplication::new()
    }

    fn clear(&mut self) {
        self.application.clear();
        self.requested_time_delay.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelayedBundleApplication {
        static instance: DelayedBundleApplication = DelayedBundleApplication {
            application: ::protobuf::MessageField::none(),
            requested_time_delay: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelayedBundleApplication {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelayedBundleApplication").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelayedBundleApplication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayedBundleApplication {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest)
pub struct ProcessBundleRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.process_bundle_descriptor_id)
    pub process_bundle_descriptor_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.cache_tokens)
    pub cache_tokens: ::std::vec::Vec<process_bundle_request::CacheToken>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.elements)
    pub elements: ::protobuf::MessageField<Elements>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleRequest {
    fn default() -> &'a ProcessBundleRequest {
        <ProcessBundleRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleRequest {
    pub fn new() -> ProcessBundleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_bundle_descriptor_id",
            |m: &ProcessBundleRequest| { &m.process_bundle_descriptor_id },
            |m: &mut ProcessBundleRequest| { &mut m.process_bundle_descriptor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cache_tokens",
            |m: &ProcessBundleRequest| { &m.cache_tokens },
            |m: &mut ProcessBundleRequest| { &mut m.cache_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Elements>(
            "elements",
            |m: &ProcessBundleRequest| { &m.elements },
            |m: &mut ProcessBundleRequest| { &mut m.elements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleRequest>(
            "ProcessBundleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleRequest {
    const NAME: &'static str = "ProcessBundleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.process_bundle_descriptor_id = is.read_string()?;
                },
                18 => {
                    self.cache_tokens.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.elements)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.process_bundle_descriptor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.process_bundle_descriptor_id);
        }
        for value in &self.cache_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.elements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.process_bundle_descriptor_id.is_empty() {
            os.write_string(1, &self.process_bundle_descriptor_id)?;
        }
        for v in &self.cache_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.elements.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleRequest {
        ProcessBundleRequest::new()
    }

    fn clear(&mut self) {
        self.process_bundle_descriptor_id.clear();
        self.cache_tokens.clear();
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleRequest {
        static instance: ProcessBundleRequest = ProcessBundleRequest {
            process_bundle_descriptor_id: ::std::string::String::new(),
            cache_tokens: ::std::vec::Vec::new(),
            elements: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProcessBundleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProcessBundleRequest`
pub mod process_bundle_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken)
    pub struct CacheToken {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.token)
        pub token: ::std::vec::Vec<u8>,
        // message oneof groups
        pub type_: ::std::option::Option<cache_token::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CacheToken {
        fn default() -> &'a CacheToken {
            <CacheToken as ::protobuf::Message>::default_instance()
        }
    }

    impl CacheToken {
        pub fn new() -> CacheToken {
            ::std::default::Default::default()
        }

        // .org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.UserState user_state = 1;

        pub fn user_state(&self) -> &cache_token::UserState {
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::UserState(ref v)) => v,
                _ => <cache_token::UserState as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_user_state(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_user_state(&self) -> bool {
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::UserState(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_user_state(&mut self, v: cache_token::UserState) {
            self.type_ = ::std::option::Option::Some(cache_token::Type::UserState(v))
        }

        // Mutable pointer to the field.
        pub fn mut_user_state(&mut self) -> &mut cache_token::UserState {
            if let ::std::option::Option::Some(cache_token::Type::UserState(_)) = self.type_ {
            } else {
                self.type_ = ::std::option::Option::Some(cache_token::Type::UserState(cache_token::UserState::new()));
            }
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::UserState(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_user_state(&mut self) -> cache_token::UserState {
            if self.has_user_state() {
                match self.type_.take() {
                    ::std::option::Option::Some(cache_token::Type::UserState(v)) => v,
                    _ => panic!(),
                }
            } else {
                cache_token::UserState::new()
            }
        }

        // .org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.SideInput side_input = 2;

        pub fn side_input(&self) -> &cache_token::SideInput {
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::SideInput(ref v)) => v,
                _ => <cache_token::SideInput as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_side_input(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_side_input(&self) -> bool {
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::SideInput(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_side_input(&mut self, v: cache_token::SideInput) {
            self.type_ = ::std::option::Option::Some(cache_token::Type::SideInput(v))
        }

        // Mutable pointer to the field.
        pub fn mut_side_input(&mut self) -> &mut cache_token::SideInput {
            if let ::std::option::Option::Some(cache_token::Type::SideInput(_)) = self.type_ {
            } else {
                self.type_ = ::std::option::Option::Some(cache_token::Type::SideInput(cache_token::SideInput::new()));
            }
            match self.type_ {
                ::std::option::Option::Some(cache_token::Type::SideInput(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_side_input(&mut self) -> cache_token::SideInput {
            if self.has_side_input() {
                match self.type_.take() {
                    ::std::option::Option::Some(cache_token::Type::SideInput(v)) => v,
                    _ => panic!(),
                }
            } else {
                cache_token::SideInput::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, cache_token::UserState>(
                "user_state",
                CacheToken::has_user_state,
                CacheToken::user_state,
                CacheToken::mut_user_state,
                CacheToken::set_user_state,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, cache_token::SideInput>(
                "side_input",
                CacheToken::has_side_input,
                CacheToken::side_input,
                CacheToken::mut_side_input,
                CacheToken::set_side_input,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "token",
                |m: &CacheToken| { &m.token },
                |m: &mut CacheToken| { &mut m.token },
            ));
            oneofs.push(cache_token::Type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheToken>(
                "ProcessBundleRequest.CacheToken",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CacheToken {
        const NAME: &'static str = "CacheToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_ = ::std::option::Option::Some(cache_token::Type::UserState(is.read_message()?));
                    },
                    18 => {
                        self.type_ = ::std::option::Option::Some(cache_token::Type::SideInput(is.read_message()?));
                    },
                    82 => {
                        self.token = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.token.is_empty() {
                my_size += ::protobuf::rt::bytes_size(10, &self.token);
            }
            if let ::std::option::Option::Some(ref v) = self.type_ {
                match v {
                    &cache_token::Type::UserState(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &cache_token::Type::SideInput(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.token.is_empty() {
                os.write_bytes(10, &self.token)?;
            }
            if let ::std::option::Option::Some(ref v) = self.type_ {
                match v {
                    &cache_token::Type::UserState(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &cache_token::Type::SideInput(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CacheToken {
            CacheToken::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.token.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CacheToken {
            static instance: CacheToken = CacheToken {
                token: ::std::vec::Vec::new(),
                type_: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CacheToken {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProcessBundleRequest.CacheToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CacheToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CacheToken {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CacheToken`
    pub mod cache_token {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.type)
        pub enum Type {
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.user_state)
            UserState(UserState),
            // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.side_input)
            SideInput(SideInput),
        }

        impl ::protobuf::Oneof for Type {
        }

        impl ::protobuf::OneofFull for Type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::CacheToken as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
            }
        }

        impl Type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.UserState)
        pub struct UserState {
            // special fields
            // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.UserState.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a UserState {
            fn default() -> &'a UserState {
                <UserState as ::protobuf::Message>::default_instance()
            }
        }

        impl UserState {
            pub fn new() -> UserState {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserState>(
                    "ProcessBundleRequest.CacheToken.UserState",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for UserState {
            const NAME: &'static str = "UserState";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> UserState {
                UserState::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static UserState {
                static instance: UserState = UserState {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for UserState {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ProcessBundleRequest.CacheToken.UserState").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for UserState {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for UserState {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.SideInput)
        pub struct SideInput {
            // message fields
            // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.SideInput.transform_id)
            pub transform_id: ::std::string::String,
            // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.SideInput.side_input_id)
            pub side_input_id: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.SideInput.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SideInput {
            fn default() -> &'a SideInput {
                <SideInput as ::protobuf::Message>::default_instance()
            }
        }

        impl SideInput {
            pub fn new() -> SideInput {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "transform_id",
                    |m: &SideInput| { &m.transform_id },
                    |m: &mut SideInput| { &mut m.transform_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "side_input_id",
                    |m: &SideInput| { &m.side_input_id },
                    |m: &mut SideInput| { &mut m.side_input_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SideInput>(
                    "ProcessBundleRequest.CacheToken.SideInput",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SideInput {
            const NAME: &'static str = "SideInput";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.transform_id = is.read_string()?;
                        },
                        18 => {
                            self.side_input_id = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.transform_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.transform_id);
                }
                if !self.side_input_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.side_input_id);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.transform_id.is_empty() {
                    os.write_string(1, &self.transform_id)?;
                }
                if !self.side_input_id.is_empty() {
                    os.write_string(2, &self.side_input_id)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SideInput {
                SideInput::new()
            }

            fn clear(&mut self) {
                self.transform_id.clear();
                self.side_input_id.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SideInput {
                static instance: SideInput = SideInput {
                    transform_id: ::std::string::String::new(),
                    side_input_id: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SideInput {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ProcessBundleRequest.CacheToken.SideInput").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SideInput {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SideInput {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse)
pub struct ProcessBundleResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.residual_roots)
    pub residual_roots: ::std::vec::Vec<DelayedBundleApplication>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.monitoring_infos)
    pub monitoring_infos: ::std::vec::Vec<super::metrics::MonitoringInfo>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.requires_finalization)
    pub requires_finalization: bool,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.monitoring_data)
    pub monitoring_data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.elements)
    pub elements: ::protobuf::MessageField<Elements>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleResponse {
    fn default() -> &'a ProcessBundleResponse {
        <ProcessBundleResponse as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleResponse {
    pub fn new() -> ProcessBundleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "residual_roots",
            |m: &ProcessBundleResponse| { &m.residual_roots },
            |m: &mut ProcessBundleResponse| { &mut m.residual_roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitoring_infos",
            |m: &ProcessBundleResponse| { &m.monitoring_infos },
            |m: &mut ProcessBundleResponse| { &mut m.monitoring_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_finalization",
            |m: &ProcessBundleResponse| { &m.requires_finalization },
            |m: &mut ProcessBundleResponse| { &mut m.requires_finalization },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "monitoring_data",
            |m: &ProcessBundleResponse| { &m.monitoring_data },
            |m: &mut ProcessBundleResponse| { &mut m.monitoring_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Elements>(
            "elements",
            |m: &ProcessBundleResponse| { &m.elements },
            |m: &mut ProcessBundleResponse| { &mut m.elements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleResponse>(
            "ProcessBundleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleResponse {
    const NAME: &'static str = "ProcessBundleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.residual_roots.push(is.read_message()?);
                },
                26 => {
                    self.monitoring_infos.push(is.read_message()?);
                },
                32 => {
                    self.requires_finalization = is.read_bool()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.monitoring_data.insert(key, value);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.elements)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.residual_roots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.monitoring_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.requires_finalization != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.elements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.residual_roots {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.monitoring_infos {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.requires_finalization != false {
            os.write_bool(4, self.requires_finalization)?;
        }
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        if let Some(v) = self.elements.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleResponse {
        ProcessBundleResponse::new()
    }

    fn clear(&mut self) {
        self.residual_roots.clear();
        self.monitoring_infos.clear();
        self.requires_finalization = false;
        self.monitoring_data.clear();
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleResponse {
        static instance: ::protobuf::rt::Lazy<ProcessBundleResponse> = ::protobuf::rt::Lazy::new();
        instance.get(ProcessBundleResponse::new)
    }
}

impl ::protobuf::MessageFull for ProcessBundleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressRequest)
pub struct ProcessBundleProgressRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressRequest.instruction_id)
    pub instruction_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleProgressRequest {
    fn default() -> &'a ProcessBundleProgressRequest {
        <ProcessBundleProgressRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleProgressRequest {
    pub fn new() -> ProcessBundleProgressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &ProcessBundleProgressRequest| { &m.instruction_id },
            |m: &mut ProcessBundleProgressRequest| { &mut m.instruction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleProgressRequest>(
            "ProcessBundleProgressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleProgressRequest {
    const NAME: &'static str = "ProcessBundleProgressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instruction_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.instruction_id.is_empty() {
            os.write_string(1, &self.instruction_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleProgressRequest {
        ProcessBundleProgressRequest::new()
    }

    fn clear(&mut self) {
        self.instruction_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleProgressRequest {
        static instance: ProcessBundleProgressRequest = ProcessBundleProgressRequest {
            instruction_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProcessBundleProgressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleProgressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleProgressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleProgressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataRequest)
pub struct MonitoringInfosMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataRequest.monitoring_info_id)
    pub monitoring_info_id: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfosMetadataRequest {
    fn default() -> &'a MonitoringInfosMetadataRequest {
        <MonitoringInfosMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfosMetadataRequest {
    pub fn new() -> MonitoringInfosMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitoring_info_id",
            |m: &MonitoringInfosMetadataRequest| { &m.monitoring_info_id },
            |m: &mut MonitoringInfosMetadataRequest| { &mut m.monitoring_info_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfosMetadataRequest>(
            "MonitoringInfosMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfosMetadataRequest {
    const NAME: &'static str = "MonitoringInfosMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.monitoring_info_id.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitoring_info_id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitoring_info_id {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfosMetadataRequest {
        MonitoringInfosMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.monitoring_info_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfosMetadataRequest {
        static instance: MonitoringInfosMetadataRequest = MonitoringInfosMetadataRequest {
            monitoring_info_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitoringInfosMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfosMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfosMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfosMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressResponse)
pub struct ProcessBundleProgressResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressResponse.monitoring_infos)
    pub monitoring_infos: ::std::vec::Vec<super::metrics::MonitoringInfo>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressResponse.monitoring_data)
    pub monitoring_data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleProgressResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleProgressResponse {
    fn default() -> &'a ProcessBundleProgressResponse {
        <ProcessBundleProgressResponse as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleProgressResponse {
    pub fn new() -> ProcessBundleProgressResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitoring_infos",
            |m: &ProcessBundleProgressResponse| { &m.monitoring_infos },
            |m: &mut ProcessBundleProgressResponse| { &mut m.monitoring_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "monitoring_data",
            |m: &ProcessBundleProgressResponse| { &m.monitoring_data },
            |m: &mut ProcessBundleProgressResponse| { &mut m.monitoring_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleProgressResponse>(
            "ProcessBundleProgressResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleProgressResponse {
    const NAME: &'static str = "ProcessBundleProgressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.monitoring_infos.push(is.read_message()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.monitoring_data.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitoring_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitoring_infos {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for (k, v) in &self.monitoring_data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleProgressResponse {
        ProcessBundleProgressResponse::new()
    }

    fn clear(&mut self) {
        self.monitoring_infos.clear();
        self.monitoring_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleProgressResponse {
        static instance: ::protobuf::rt::Lazy<ProcessBundleProgressResponse> = ::protobuf::rt::Lazy::new();
        instance.get(ProcessBundleProgressResponse::new)
    }
}

impl ::protobuf::MessageFull for ProcessBundleProgressResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleProgressResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleProgressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleProgressResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataResponse)
pub struct MonitoringInfosMetadataResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataResponse.monitoring_info)
    pub monitoring_info: ::std::collections::HashMap<::std::string::String, super::metrics::MonitoringInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.MonitoringInfosMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitoringInfosMetadataResponse {
    fn default() -> &'a MonitoringInfosMetadataResponse {
        <MonitoringInfosMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitoringInfosMetadataResponse {
    pub fn new() -> MonitoringInfosMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "monitoring_info",
            |m: &MonitoringInfosMetadataResponse| { &m.monitoring_info },
            |m: &mut MonitoringInfosMetadataResponse| { &mut m.monitoring_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitoringInfosMetadataResponse>(
            "MonitoringInfosMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitoringInfosMetadataResponse {
    const NAME: &'static str = "MonitoringInfosMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.monitoring_info.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.monitoring_info {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.monitoring_info {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitoringInfosMetadataResponse {
        MonitoringInfosMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.monitoring_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitoringInfosMetadataResponse {
        static instance: ::protobuf::rt::Lazy<MonitoringInfosMetadataResponse> = ::protobuf::rt::Lazy::new();
        instance.get(MonitoringInfosMetadataResponse::new)
    }
}

impl ::protobuf::MessageFull for MonitoringInfosMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitoringInfosMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitoringInfosMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitoringInfosMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest)
pub struct ProcessBundleSplitRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.instruction_id)
    pub instruction_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.desired_splits)
    pub desired_splits: ::std::collections::HashMap<::std::string::String, process_bundle_split_request::DesiredSplit>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleSplitRequest {
    fn default() -> &'a ProcessBundleSplitRequest {
        <ProcessBundleSplitRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleSplitRequest {
    pub fn new() -> ProcessBundleSplitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &ProcessBundleSplitRequest| { &m.instruction_id },
            |m: &mut ProcessBundleSplitRequest| { &mut m.instruction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "desired_splits",
            |m: &ProcessBundleSplitRequest| { &m.desired_splits },
            |m: &mut ProcessBundleSplitRequest| { &mut m.desired_splits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleSplitRequest>(
            "ProcessBundleSplitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleSplitRequest {
    const NAME: &'static str = "ProcessBundleSplitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instruction_id = is.read_string()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.desired_splits.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
        }
        for (k, v) in &self.desired_splits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.instruction_id.is_empty() {
            os.write_string(1, &self.instruction_id)?;
        }
        for (k, v) in &self.desired_splits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleSplitRequest {
        ProcessBundleSplitRequest::new()
    }

    fn clear(&mut self) {
        self.instruction_id.clear();
        self.desired_splits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleSplitRequest {
        static instance: ::protobuf::rt::Lazy<ProcessBundleSplitRequest> = ::protobuf::rt::Lazy::new();
        instance.get(ProcessBundleSplitRequest::new)
    }
}

impl ::protobuf::MessageFull for ProcessBundleSplitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleSplitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleSplitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleSplitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProcessBundleSplitRequest`
pub mod process_bundle_split_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplit)
    pub struct DesiredSplit {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplit.fraction_of_remainder)
        pub fraction_of_remainder: f64,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplit.allowed_split_points)
        pub allowed_split_points: ::std::vec::Vec<i64>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplit.estimated_input_elements)
        pub estimated_input_elements: i64,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplit.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DesiredSplit {
        fn default() -> &'a DesiredSplit {
            <DesiredSplit as ::protobuf::Message>::default_instance()
        }
    }

    impl DesiredSplit {
        pub fn new() -> DesiredSplit {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fraction_of_remainder",
                |m: &DesiredSplit| { &m.fraction_of_remainder },
                |m: &mut DesiredSplit| { &mut m.fraction_of_remainder },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "allowed_split_points",
                |m: &DesiredSplit| { &m.allowed_split_points },
                |m: &mut DesiredSplit| { &mut m.allowed_split_points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "estimated_input_elements",
                |m: &DesiredSplit| { &m.estimated_input_elements },
                |m: &mut DesiredSplit| { &mut m.estimated_input_elements },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DesiredSplit>(
                "ProcessBundleSplitRequest.DesiredSplit",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DesiredSplit {
        const NAME: &'static str = "DesiredSplit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.fraction_of_remainder = is.read_double()?;
                    },
                    26 => {
                        is.read_repeated_packed_int64_into(&mut self.allowed_split_points)?;
                    },
                    24 => {
                        self.allowed_split_points.push(is.read_int64()?);
                    },
                    16 => {
                        self.estimated_input_elements = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.fraction_of_remainder != 0. {
                my_size += 1 + 8;
            }
            for value in &self.allowed_split_points {
                my_size += ::protobuf::rt::int64_size(3, *value);
            };
            if self.estimated_input_elements != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.estimated_input_elements);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.fraction_of_remainder != 0. {
                os.write_double(1, self.fraction_of_remainder)?;
            }
            for v in &self.allowed_split_points {
                os.write_int64(3, *v)?;
            };
            if self.estimated_input_elements != 0 {
                os.write_int64(2, self.estimated_input_elements)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DesiredSplit {
            DesiredSplit::new()
        }

        fn clear(&mut self) {
            self.fraction_of_remainder = 0.;
            self.allowed_split_points.clear();
            self.estimated_input_elements = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DesiredSplit {
            static instance: DesiredSplit = DesiredSplit {
                fraction_of_remainder: 0.,
                allowed_split_points: ::std::vec::Vec::new(),
                estimated_input_elements: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DesiredSplit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProcessBundleSplitRequest.DesiredSplit").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DesiredSplit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DesiredSplit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse)
pub struct ProcessBundleSplitResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.primary_roots)
    pub primary_roots: ::std::vec::Vec<BundleApplication>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.residual_roots)
    pub residual_roots: ::std::vec::Vec<DelayedBundleApplication>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.channel_splits)
    pub channel_splits: ::std::vec::Vec<process_bundle_split_response::ChannelSplit>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessBundleSplitResponse {
    fn default() -> &'a ProcessBundleSplitResponse {
        <ProcessBundleSplitResponse as ::protobuf::Message>::default_instance()
    }
}

impl ProcessBundleSplitResponse {
    pub fn new() -> ProcessBundleSplitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "primary_roots",
            |m: &ProcessBundleSplitResponse| { &m.primary_roots },
            |m: &mut ProcessBundleSplitResponse| { &mut m.primary_roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "residual_roots",
            |m: &ProcessBundleSplitResponse| { &m.residual_roots },
            |m: &mut ProcessBundleSplitResponse| { &mut m.residual_roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_splits",
            |m: &ProcessBundleSplitResponse| { &m.channel_splits },
            |m: &mut ProcessBundleSplitResponse| { &mut m.channel_splits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessBundleSplitResponse>(
            "ProcessBundleSplitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessBundleSplitResponse {
    const NAME: &'static str = "ProcessBundleSplitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.primary_roots.push(is.read_message()?);
                },
                18 => {
                    self.residual_roots.push(is.read_message()?);
                },
                26 => {
                    self.channel_splits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.primary_roots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.residual_roots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.channel_splits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.primary_roots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.residual_roots {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.channel_splits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessBundleSplitResponse {
        ProcessBundleSplitResponse::new()
    }

    fn clear(&mut self) {
        self.primary_roots.clear();
        self.residual_roots.clear();
        self.channel_splits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessBundleSplitResponse {
        static instance: ProcessBundleSplitResponse = ProcessBundleSplitResponse {
            primary_roots: ::std::vec::Vec::new(),
            residual_roots: ::std::vec::Vec::new(),
            channel_splits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProcessBundleSplitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessBundleSplitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessBundleSplitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessBundleSplitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProcessBundleSplitResponse`
pub mod process_bundle_split_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.ChannelSplit)
    pub struct ChannelSplit {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.ChannelSplit.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.ChannelSplit.last_primary_element)
        pub last_primary_element: i64,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.ChannelSplit.first_residual_element)
        pub first_residual_element: i64,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.ProcessBundleSplitResponse.ChannelSplit.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChannelSplit {
        fn default() -> &'a ChannelSplit {
            <ChannelSplit as ::protobuf::Message>::default_instance()
        }
    }

    impl ChannelSplit {
        pub fn new() -> ChannelSplit {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &ChannelSplit| { &m.transform_id },
                |m: &mut ChannelSplit| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "last_primary_element",
                |m: &ChannelSplit| { &m.last_primary_element },
                |m: &mut ChannelSplit| { &mut m.last_primary_element },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "first_residual_element",
                |m: &ChannelSplit| { &m.first_residual_element },
                |m: &mut ChannelSplit| { &mut m.first_residual_element },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelSplit>(
                "ProcessBundleSplitResponse.ChannelSplit",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChannelSplit {
        const NAME: &'static str = "ChannelSplit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    16 => {
                        self.last_primary_element = is.read_int64()?;
                    },
                    24 => {
                        self.first_residual_element = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if self.last_primary_element != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.last_primary_element);
            }
            if self.first_residual_element != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.first_residual_element);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if self.last_primary_element != 0 {
                os.write_int64(2, self.last_primary_element)?;
            }
            if self.first_residual_element != 0 {
                os.write_int64(3, self.first_residual_element)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChannelSplit {
            ChannelSplit::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.last_primary_element = 0;
            self.first_residual_element = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChannelSplit {
            static instance: ChannelSplit = ChannelSplit {
                transform_id: ::std::string::String::new(),
                last_primary_element: 0,
                first_residual_element: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChannelSplit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProcessBundleSplitResponse.ChannelSplit").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChannelSplit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChannelSplit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.FinalizeBundleRequest)
pub struct FinalizeBundleRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.FinalizeBundleRequest.instruction_id)
    pub instruction_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.FinalizeBundleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FinalizeBundleRequest {
    fn default() -> &'a FinalizeBundleRequest {
        <FinalizeBundleRequest as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeBundleRequest {
    pub fn new() -> FinalizeBundleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &FinalizeBundleRequest| { &m.instruction_id },
            |m: &mut FinalizeBundleRequest| { &mut m.instruction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FinalizeBundleRequest>(
            "FinalizeBundleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FinalizeBundleRequest {
    const NAME: &'static str = "FinalizeBundleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instruction_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.instruction_id.is_empty() {
            os.write_string(1, &self.instruction_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FinalizeBundleRequest {
        FinalizeBundleRequest::new()
    }

    fn clear(&mut self) {
        self.instruction_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FinalizeBundleRequest {
        static instance: FinalizeBundleRequest = FinalizeBundleRequest {
            instruction_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FinalizeBundleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FinalizeBundleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FinalizeBundleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeBundleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.FinalizeBundleResponse)
pub struct FinalizeBundleResponse {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.FinalizeBundleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FinalizeBundleResponse {
    fn default() -> &'a FinalizeBundleResponse {
        <FinalizeBundleResponse as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeBundleResponse {
    pub fn new() -> FinalizeBundleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FinalizeBundleResponse>(
            "FinalizeBundleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FinalizeBundleResponse {
    const NAME: &'static str = "FinalizeBundleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FinalizeBundleResponse {
        FinalizeBundleResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FinalizeBundleResponse {
        static instance: FinalizeBundleResponse = FinalizeBundleResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FinalizeBundleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FinalizeBundleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FinalizeBundleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeBundleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.Elements)
pub struct Elements {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.data)
    pub data: ::std::vec::Vec<elements::Data>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.timers)
    pub timers: ::std::vec::Vec<elements::Timers>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.Elements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Elements {
    fn default() -> &'a Elements {
        <Elements as ::protobuf::Message>::default_instance()
    }
}

impl Elements {
    pub fn new() -> Elements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &Elements| { &m.data },
            |m: &mut Elements| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timers",
            |m: &Elements| { &m.timers },
            |m: &mut Elements| { &mut m.timers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Elements>(
            "Elements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Elements {
    const NAME: &'static str = "Elements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data.push(is.read_message()?);
                },
                18 => {
                    self.timers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.timers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.timers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Elements {
        Elements::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.timers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Elements {
        static instance: Elements = Elements {
            data: ::std::vec::Vec::new(),
            timers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Elements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Elements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Elements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Elements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Elements`
pub mod elements {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.Elements.Data)
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Data.instruction_id)
        pub instruction_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Data.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Data.data)
        pub data: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Data.is_last)
        pub is_last: bool,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.Elements.Data.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "instruction_id",
                |m: &Data| { &m.instruction_id },
                |m: &mut Data| { &mut m.instruction_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &Data| { &m.transform_id },
                |m: &mut Data| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data",
                |m: &Data| { &m.data },
                |m: &mut Data| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_last",
                |m: &Data| { &m.is_last },
                |m: &mut Data| { &mut m.is_last },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Data>(
                "Elements.Data",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.instruction_id = is.read_string()?;
                    },
                    18 => {
                        self.transform_id = is.read_string()?;
                    },
                    26 => {
                        self.data = is.read_bytes()?;
                    },
                    32 => {
                        self.is_last = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.instruction_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
            }
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.transform_id);
            }
            if !self.data.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.data);
            }
            if self.is_last != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.instruction_id.is_empty() {
                os.write_string(1, &self.instruction_id)?;
            }
            if !self.transform_id.is_empty() {
                os.write_string(2, &self.transform_id)?;
            }
            if !self.data.is_empty() {
                os.write_bytes(3, &self.data)?;
            }
            if self.is_last != false {
                os.write_bool(4, self.is_last)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.instruction_id.clear();
            self.transform_id.clear();
            self.data.clear();
            self.is_last = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                instruction_id: ::std::string::String::new(),
                transform_id: ::std::string::String::new(),
                data: ::std::vec::Vec::new(),
                is_last: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Data {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Elements.Data").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Data {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Data {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.Elements.Timers)
    pub struct Timers {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Timers.instruction_id)
        pub instruction_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Timers.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Timers.timer_family_id)
        pub timer_family_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Timers.timers)
        pub timers: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.Elements.Timers.is_last)
        pub is_last: bool,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.Elements.Timers.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Timers {
        fn default() -> &'a Timers {
            <Timers as ::protobuf::Message>::default_instance()
        }
    }

    impl Timers {
        pub fn new() -> Timers {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "instruction_id",
                |m: &Timers| { &m.instruction_id },
                |m: &mut Timers| { &mut m.instruction_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &Timers| { &m.transform_id },
                |m: &mut Timers| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timer_family_id",
                |m: &Timers| { &m.timer_family_id },
                |m: &mut Timers| { &mut m.timer_family_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timers",
                |m: &Timers| { &m.timers },
                |m: &mut Timers| { &mut m.timers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_last",
                |m: &Timers| { &m.is_last },
                |m: &mut Timers| { &mut m.is_last },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Timers>(
                "Elements.Timers",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Timers {
        const NAME: &'static str = "Timers";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.instruction_id = is.read_string()?;
                    },
                    18 => {
                        self.transform_id = is.read_string()?;
                    },
                    26 => {
                        self.timer_family_id = is.read_string()?;
                    },
                    34 => {
                        self.timers = is.read_bytes()?;
                    },
                    40 => {
                        self.is_last = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.instruction_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.instruction_id);
            }
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.transform_id);
            }
            if !self.timer_family_id.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.timer_family_id);
            }
            if !self.timers.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.timers);
            }
            if self.is_last != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.instruction_id.is_empty() {
                os.write_string(1, &self.instruction_id)?;
            }
            if !self.transform_id.is_empty() {
                os.write_string(2, &self.transform_id)?;
            }
            if !self.timer_family_id.is_empty() {
                os.write_string(3, &self.timer_family_id)?;
            }
            if !self.timers.is_empty() {
                os.write_bytes(4, &self.timers)?;
            }
            if self.is_last != false {
                os.write_bool(5, self.is_last)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Timers {
            Timers::new()
        }

        fn clear(&mut self) {
            self.instruction_id.clear();
            self.transform_id.clear();
            self.timer_family_id.clear();
            self.timers.clear();
            self.is_last = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Timers {
            static instance: Timers = Timers {
                instruction_id: ::std::string::String::new(),
                transform_id: ::std::string::String::new(),
                timer_family_id: ::std::string::String::new(),
                timers: ::std::vec::Vec::new(),
                is_last: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Timers {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Elements.Timers").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Timers {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Timers {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateRequest)
pub struct StateRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateRequest.instruction_id)
    pub instruction_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateRequest.state_key)
    pub state_key: ::protobuf::MessageField<StateKey>,
    // message oneof groups
    pub request: ::std::option::Option<state_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateRequest {
    fn default() -> &'a StateRequest {
        <StateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StateRequest {
    pub fn new() -> StateRequest {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.fn_execution.v1.StateGetRequest get = 1000;

    pub fn get(&self) -> &StateGetRequest {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Get(ref v)) => v,
            _ => <StateGetRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Get(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get(&mut self, v: StateGetRequest) {
        self.request = ::std::option::Option::Some(state_request::Request::Get(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get(&mut self) -> &mut StateGetRequest {
        if let ::std::option::Option::Some(state_request::Request::Get(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(state_request::Request::Get(StateGetRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(state_request::Request::Get(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get(&mut self) -> StateGetRequest {
        if self.has_get() {
            match self.request.take() {
                ::std::option::Option::Some(state_request::Request::Get(v)) => v,
                _ => panic!(),
            }
        } else {
            StateGetRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateAppendRequest append = 1001;

    pub fn append(&self) -> &StateAppendRequest {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Append(ref v)) => v,
            _ => <StateAppendRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_append(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_append(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Append(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_append(&mut self, v: StateAppendRequest) {
        self.request = ::std::option::Option::Some(state_request::Request::Append(v))
    }

    // Mutable pointer to the field.
    pub fn mut_append(&mut self) -> &mut StateAppendRequest {
        if let ::std::option::Option::Some(state_request::Request::Append(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(state_request::Request::Append(StateAppendRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(state_request::Request::Append(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_append(&mut self) -> StateAppendRequest {
        if self.has_append() {
            match self.request.take() {
                ::std::option::Option::Some(state_request::Request::Append(v)) => v,
                _ => panic!(),
            }
        } else {
            StateAppendRequest::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateClearRequest clear = 1002;

    pub fn clear(&self) -> &StateClearRequest {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Clear(ref v)) => v,
            _ => <StateClearRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clear(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_clear(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(state_request::Request::Clear(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clear(&mut self, v: StateClearRequest) {
        self.request = ::std::option::Option::Some(state_request::Request::Clear(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clear(&mut self) -> &mut StateClearRequest {
        if let ::std::option::Option::Some(state_request::Request::Clear(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(state_request::Request::Clear(StateClearRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(state_request::Request::Clear(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clear(&mut self) -> StateClearRequest {
        if self.has_clear() {
            match self.request.take() {
                ::std::option::Option::Some(state_request::Request::Clear(v)) => v,
                _ => panic!(),
            }
        } else {
            StateClearRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StateRequest| { &m.id },
            |m: &mut StateRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &StateRequest| { &m.instruction_id },
            |m: &mut StateRequest| { &mut m.instruction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StateKey>(
            "state_key",
            |m: &StateRequest| { &m.state_key },
            |m: &mut StateRequest| { &mut m.state_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateGetRequest>(
            "get",
            StateRequest::has_get,
            StateRequest::get,
            StateRequest::mut_get,
            StateRequest::set_get,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateAppendRequest>(
            "append",
            StateRequest::has_append,
            StateRequest::append,
            StateRequest::mut_append,
            StateRequest::set_append,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateClearRequest>(
            "clear",
            StateRequest::has_clear,
            StateRequest::clear,
            StateRequest::mut_clear,
            StateRequest::set_clear,
        ));
        oneofs.push(state_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateRequest>(
            "StateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateRequest {
    const NAME: &'static str = "StateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.instruction_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_key)?;
                },
                8002 => {
                    self.request = ::std::option::Option::Some(state_request::Request::Get(is.read_message()?));
                },
                8010 => {
                    self.request = ::std::option::Option::Some(state_request::Request::Append(is.read_message()?));
                },
                8018 => {
                    self.request = ::std::option::Option::Some(state_request::Request::Clear(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.instruction_id);
        }
        if let Some(v) = self.state_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &state_request::Request::Get(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_request::Request::Append(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_request::Request::Clear(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.instruction_id.is_empty() {
            os.write_string(2, &self.instruction_id)?;
        }
        if let Some(v) = self.state_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &state_request::Request::Get(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
                &state_request::Request::Append(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
                &state_request::Request::Clear(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateRequest {
        StateRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.instruction_id.clear();
        self.state_key.clear();
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateRequest {
        static instance: StateRequest = StateRequest {
            id: ::std::string::String::new(),
            instruction_id: ::std::string::String::new(),
            state_key: ::protobuf::MessageField::none(),
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StateRequest`
pub mod state_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.StateRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateRequest.get)
        Get(super::StateGetRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateRequest.append)
        Append(super::StateAppendRequest),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateRequest.clear)
        Clear(super::StateClearRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StateRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateResponse)
pub struct StateResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateResponse.error)
    pub error: ::std::string::String,
    // message oneof groups
    pub response: ::std::option::Option<state_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateResponse {
    fn default() -> &'a StateResponse {
        <StateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StateResponse {
    pub fn new() -> StateResponse {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.fn_execution.v1.StateGetResponse get = 1000;

    pub fn get(&self) -> &StateGetResponse {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Get(ref v)) => v,
            _ => <StateGetResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Get(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get(&mut self, v: StateGetResponse) {
        self.response = ::std::option::Option::Some(state_response::Response::Get(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get(&mut self) -> &mut StateGetResponse {
        if let ::std::option::Option::Some(state_response::Response::Get(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(state_response::Response::Get(StateGetResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(state_response::Response::Get(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get(&mut self) -> StateGetResponse {
        if self.has_get() {
            match self.response.take() {
                ::std::option::Option::Some(state_response::Response::Get(v)) => v,
                _ => panic!(),
            }
        } else {
            StateGetResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateAppendResponse append = 1001;

    pub fn append(&self) -> &StateAppendResponse {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Append(ref v)) => v,
            _ => <StateAppendResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_append(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_append(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Append(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_append(&mut self, v: StateAppendResponse) {
        self.response = ::std::option::Option::Some(state_response::Response::Append(v))
    }

    // Mutable pointer to the field.
    pub fn mut_append(&mut self) -> &mut StateAppendResponse {
        if let ::std::option::Option::Some(state_response::Response::Append(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(state_response::Response::Append(StateAppendResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(state_response::Response::Append(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_append(&mut self) -> StateAppendResponse {
        if self.has_append() {
            match self.response.take() {
                ::std::option::Option::Some(state_response::Response::Append(v)) => v,
                _ => panic!(),
            }
        } else {
            StateAppendResponse::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateClearResponse clear = 1002;

    pub fn clear(&self) -> &StateClearResponse {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Clear(ref v)) => v,
            _ => <StateClearResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clear(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_clear(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(state_response::Response::Clear(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clear(&mut self, v: StateClearResponse) {
        self.response = ::std::option::Option::Some(state_response::Response::Clear(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clear(&mut self) -> &mut StateClearResponse {
        if let ::std::option::Option::Some(state_response::Response::Clear(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(state_response::Response::Clear(StateClearResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(state_response::Response::Clear(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clear(&mut self) -> StateClearResponse {
        if self.has_clear() {
            match self.response.take() {
                ::std::option::Option::Some(state_response::Response::Clear(v)) => v,
                _ => panic!(),
            }
        } else {
            StateClearResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StateResponse| { &m.id },
            |m: &mut StateResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &StateResponse| { &m.error },
            |m: &mut StateResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateGetResponse>(
            "get",
            StateResponse::has_get,
            StateResponse::get,
            StateResponse::mut_get,
            StateResponse::set_get,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateAppendResponse>(
            "append",
            StateResponse::has_append,
            StateResponse::append,
            StateResponse::mut_append,
            StateResponse::set_append,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateClearResponse>(
            "clear",
            StateResponse::has_clear,
            StateResponse::clear,
            StateResponse::mut_clear,
            StateResponse::set_clear,
        ));
        oneofs.push(state_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateResponse>(
            "StateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateResponse {
    const NAME: &'static str = "StateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                8002 => {
                    self.response = ::std::option::Option::Some(state_response::Response::Get(is.read_message()?));
                },
                8010 => {
                    self.response = ::std::option::Option::Some(state_response::Response::Append(is.read_message()?));
                },
                8018 => {
                    self.response = ::std::option::Option::Some(state_response::Response::Clear(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &state_response::Response::Get(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_response::Response::Append(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_response::Response::Clear(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &state_response::Response::Get(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
                &state_response::Response::Append(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1001, v, os)?;
                },
                &state_response::Response::Clear(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateResponse {
        StateResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.error.clear();
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateResponse {
        static instance: StateResponse = StateResponse {
            id: ::std::string::String::new(),
            error: ::std::string::String::new(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StateResponse`
pub mod state_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.StateResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateResponse.get)
        Get(super::StateGetResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateResponse.append)
        Append(super::StateAppendResponse),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateResponse.clear)
        Clear(super::StateClearResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StateResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey)
pub struct StateKey {
    // message oneof groups
    pub type_: ::std::option::Option<state_key::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateKey {
    fn default() -> &'a StateKey {
        <StateKey as ::protobuf::Message>::default_instance()
    }
}

impl StateKey {
    pub fn new() -> StateKey {
        ::std::default::Default::default()
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.Runner runner = 1;

    pub fn runner(&self) -> &state_key::Runner {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::Runner(ref v)) => v,
            _ => <state_key::Runner as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_runner(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_runner(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::Runner(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runner(&mut self, v: state_key::Runner) {
        self.type_ = ::std::option::Option::Some(state_key::Type::Runner(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runner(&mut self) -> &mut state_key::Runner {
        if let ::std::option::Option::Some(state_key::Type::Runner(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::Runner(state_key::Runner::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::Runner(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runner(&mut self) -> state_key::Runner {
        if self.has_runner() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::Runner(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::Runner::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput multimap_side_input = 2;

    pub fn multimap_side_input(&self) -> &state_key::MultimapSideInput {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapSideInput(ref v)) => v,
            _ => <state_key::MultimapSideInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multimap_side_input(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_multimap_side_input(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapSideInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multimap_side_input(&mut self, v: state_key::MultimapSideInput) {
        self.type_ = ::std::option::Option::Some(state_key::Type::MultimapSideInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multimap_side_input(&mut self) -> &mut state_key::MultimapSideInput {
        if let ::std::option::Option::Some(state_key::Type::MultimapSideInput(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::MultimapSideInput(state_key::MultimapSideInput::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapSideInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multimap_side_input(&mut self) -> state_key::MultimapSideInput {
        if self.has_multimap_side_input() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::MultimapSideInput(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::MultimapSideInput::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.BagUserState bag_user_state = 3;

    pub fn bag_user_state(&self) -> &state_key::BagUserState {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::BagUserState(ref v)) => v,
            _ => <state_key::BagUserState as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bag_user_state(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_bag_user_state(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::BagUserState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bag_user_state(&mut self, v: state_key::BagUserState) {
        self.type_ = ::std::option::Option::Some(state_key::Type::BagUserState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bag_user_state(&mut self) -> &mut state_key::BagUserState {
        if let ::std::option::Option::Some(state_key::Type::BagUserState(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::BagUserState(state_key::BagUserState::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::BagUserState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bag_user_state(&mut self) -> state_key::BagUserState {
        if self.has_bag_user_state() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::BagUserState(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::BagUserState::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput iterable_side_input = 4;

    pub fn iterable_side_input(&self) -> &state_key::IterableSideInput {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::IterableSideInput(ref v)) => v,
            _ => <state_key::IterableSideInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_iterable_side_input(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_iterable_side_input(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::IterableSideInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_iterable_side_input(&mut self, v: state_key::IterableSideInput) {
        self.type_ = ::std::option::Option::Some(state_key::Type::IterableSideInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_iterable_side_input(&mut self) -> &mut state_key::IterableSideInput {
        if let ::std::option::Option::Some(state_key::Type::IterableSideInput(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::IterableSideInput(state_key::IterableSideInput::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::IterableSideInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_iterable_side_input(&mut self) -> state_key::IterableSideInput {
        if self.has_iterable_side_input() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::IterableSideInput(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::IterableSideInput::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput multimap_keys_side_input = 5;

    pub fn multimap_keys_side_input(&self) -> &state_key::MultimapKeysSideInput {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(ref v)) => v,
            _ => <state_key::MultimapKeysSideInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multimap_keys_side_input(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_multimap_keys_side_input(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multimap_keys_side_input(&mut self, v: state_key::MultimapKeysSideInput) {
        self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multimap_keys_side_input(&mut self) -> &mut state_key::MultimapKeysSideInput {
        if let ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(state_key::MultimapKeysSideInput::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multimap_keys_side_input(&mut self) -> state_key::MultimapKeysSideInput {
        if self.has_multimap_keys_side_input() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::MultimapKeysSideInput::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState multimap_keys_user_state = 6;

    pub fn multimap_keys_user_state(&self) -> &state_key::MultimapKeysUserState {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(ref v)) => v,
            _ => <state_key::MultimapKeysUserState as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multimap_keys_user_state(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_multimap_keys_user_state(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multimap_keys_user_state(&mut self, v: state_key::MultimapKeysUserState) {
        self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multimap_keys_user_state(&mut self) -> &mut state_key::MultimapKeysUserState {
        if let ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(state_key::MultimapKeysUserState::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multimap_keys_user_state(&mut self) -> state_key::MultimapKeysUserState {
        if self.has_multimap_keys_user_state() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::MultimapKeysUserState::new()
        }
    }

    // .org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState multimap_user_state = 7;

    pub fn multimap_user_state(&self) -> &state_key::MultimapUserState {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapUserState(ref v)) => v,
            _ => <state_key::MultimapUserState as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multimap_user_state(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_multimap_user_state(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapUserState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multimap_user_state(&mut self, v: state_key::MultimapUserState) {
        self.type_ = ::std::option::Option::Some(state_key::Type::MultimapUserState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multimap_user_state(&mut self) -> &mut state_key::MultimapUserState {
        if let ::std::option::Option::Some(state_key::Type::MultimapUserState(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(state_key::Type::MultimapUserState(state_key::MultimapUserState::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(state_key::Type::MultimapUserState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multimap_user_state(&mut self) -> state_key::MultimapUserState {
        if self.has_multimap_user_state() {
            match self.type_.take() {
                ::std::option::Option::Some(state_key::Type::MultimapUserState(v)) => v,
                _ => panic!(),
            }
        } else {
            state_key::MultimapUserState::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::Runner>(
            "runner",
            StateKey::has_runner,
            StateKey::runner,
            StateKey::mut_runner,
            StateKey::set_runner,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::MultimapSideInput>(
            "multimap_side_input",
            StateKey::has_multimap_side_input,
            StateKey::multimap_side_input,
            StateKey::mut_multimap_side_input,
            StateKey::set_multimap_side_input,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::BagUserState>(
            "bag_user_state",
            StateKey::has_bag_user_state,
            StateKey::bag_user_state,
            StateKey::mut_bag_user_state,
            StateKey::set_bag_user_state,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::IterableSideInput>(
            "iterable_side_input",
            StateKey::has_iterable_side_input,
            StateKey::iterable_side_input,
            StateKey::mut_iterable_side_input,
            StateKey::set_iterable_side_input,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::MultimapKeysSideInput>(
            "multimap_keys_side_input",
            StateKey::has_multimap_keys_side_input,
            StateKey::multimap_keys_side_input,
            StateKey::mut_multimap_keys_side_input,
            StateKey::set_multimap_keys_side_input,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::MultimapKeysUserState>(
            "multimap_keys_user_state",
            StateKey::has_multimap_keys_user_state,
            StateKey::multimap_keys_user_state,
            StateKey::mut_multimap_keys_user_state,
            StateKey::set_multimap_keys_user_state,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, state_key::MultimapUserState>(
            "multimap_user_state",
            StateKey::has_multimap_user_state,
            StateKey::multimap_user_state,
            StateKey::mut_multimap_user_state,
            StateKey::set_multimap_user_state,
        ));
        oneofs.push(state_key::Type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateKey>(
            "StateKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateKey {
    const NAME: &'static str = "StateKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::Runner(is.read_message()?));
                },
                18 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::MultimapSideInput(is.read_message()?));
                },
                26 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::BagUserState(is.read_message()?));
                },
                34 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::IterableSideInput(is.read_message()?));
                },
                42 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysSideInput(is.read_message()?));
                },
                50 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::MultimapKeysUserState(is.read_message()?));
                },
                58 => {
                    self.type_ = ::std::option::Option::Some(state_key::Type::MultimapUserState(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &state_key::Type::Runner(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::MultimapSideInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::BagUserState(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::IterableSideInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::MultimapKeysSideInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::MultimapKeysUserState(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &state_key::Type::MultimapUserState(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &state_key::Type::Runner(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &state_key::Type::MultimapSideInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &state_key::Type::BagUserState(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &state_key::Type::IterableSideInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &state_key::Type::MultimapKeysSideInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &state_key::Type::MultimapKeysUserState(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &state_key::Type::MultimapUserState(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateKey {
        StateKey::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateKey {
        static instance: StateKey = StateKey {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StateKey`
pub mod state_key {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.apache.beam.model.fn_execution.v1.StateKey.type)
    pub enum Type {
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.runner)
        Runner(Runner),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.multimap_side_input)
        MultimapSideInput(MultimapSideInput),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.bag_user_state)
        BagUserState(BagUserState),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.iterable_side_input)
        IterableSideInput(IterableSideInput),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.multimap_keys_side_input)
        MultimapKeysSideInput(MultimapKeysSideInput),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.multimap_keys_user_state)
        MultimapKeysUserState(MultimapKeysUserState),
        // @@protoc_insertion_point(oneof_field:org.apache.beam.model.fn_execution.v1.StateKey.multimap_user_state)
        MultimapUserState(MultimapUserState),
    }

    impl ::protobuf::Oneof for Type {
    }

    impl ::protobuf::OneofFull for Type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StateKey as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
        }
    }

    impl Type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.Runner)
    pub struct Runner {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.Runner.key)
        pub key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.Runner.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Runner {
        fn default() -> &'a Runner {
            <Runner as ::protobuf::Message>::default_instance()
        }
    }

    impl Runner {
        pub fn new() -> Runner {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &Runner| { &m.key },
                |m: &mut Runner| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Runner>(
                "StateKey.Runner",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Runner {
        const NAME: &'static str = "Runner";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_bytes(1, &self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Runner {
            Runner::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Runner {
            static instance: Runner = Runner {
                key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Runner {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.Runner").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Runner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Runner {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput)
    pub struct IterableSideInput {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput.side_input_id)
        pub side_input_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput.window)
        pub window: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IterableSideInput {
        fn default() -> &'a IterableSideInput {
            <IterableSideInput as ::protobuf::Message>::default_instance()
        }
    }

    impl IterableSideInput {
        pub fn new() -> IterableSideInput {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &IterableSideInput| { &m.transform_id },
                |m: &mut IterableSideInput| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "side_input_id",
                |m: &IterableSideInput| { &m.side_input_id },
                |m: &mut IterableSideInput| { &mut m.side_input_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &IterableSideInput| { &m.window },
                |m: &mut IterableSideInput| { &mut m.window },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IterableSideInput>(
                "StateKey.IterableSideInput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IterableSideInput {
        const NAME: &'static str = "IterableSideInput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.side_input_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.side_input_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.side_input_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.side_input_id.is_empty() {
                os.write_string(2, &self.side_input_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IterableSideInput {
            IterableSideInput::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.side_input_id.clear();
            self.window.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IterableSideInput {
            static instance: IterableSideInput = IterableSideInput {
                transform_id: ::std::string::String::new(),
                side_input_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IterableSideInput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.IterableSideInput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IterableSideInput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IterableSideInput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput)
    pub struct MultimapSideInput {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput.side_input_id)
        pub side_input_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput.window)
        pub window: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput.key)
        pub key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapSideInput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MultimapSideInput {
        fn default() -> &'a MultimapSideInput {
            <MultimapSideInput as ::protobuf::Message>::default_instance()
        }
    }

    impl MultimapSideInput {
        pub fn new() -> MultimapSideInput {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &MultimapSideInput| { &m.transform_id },
                |m: &mut MultimapSideInput| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "side_input_id",
                |m: &MultimapSideInput| { &m.side_input_id },
                |m: &mut MultimapSideInput| { &mut m.side_input_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &MultimapSideInput| { &m.window },
                |m: &mut MultimapSideInput| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &MultimapSideInput| { &m.key },
                |m: &mut MultimapSideInput| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultimapSideInput>(
                "StateKey.MultimapSideInput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MultimapSideInput {
        const NAME: &'static str = "MultimapSideInput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.side_input_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    34 => {
                        self.key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.side_input_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.side_input_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.side_input_id.is_empty() {
                os.write_string(2, &self.side_input_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            if !self.key.is_empty() {
                os.write_bytes(4, &self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MultimapSideInput {
            MultimapSideInput::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.side_input_id.clear();
            self.window.clear();
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MultimapSideInput {
            static instance: MultimapSideInput = MultimapSideInput {
                transform_id: ::std::string::String::new(),
                side_input_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MultimapSideInput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.MultimapSideInput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MultimapSideInput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MultimapSideInput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput)
    pub struct MultimapKeysSideInput {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput.side_input_id)
        pub side_input_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput.window)
        pub window: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysSideInput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MultimapKeysSideInput {
        fn default() -> &'a MultimapKeysSideInput {
            <MultimapKeysSideInput as ::protobuf::Message>::default_instance()
        }
    }

    impl MultimapKeysSideInput {
        pub fn new() -> MultimapKeysSideInput {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &MultimapKeysSideInput| { &m.transform_id },
                |m: &mut MultimapKeysSideInput| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "side_input_id",
                |m: &MultimapKeysSideInput| { &m.side_input_id },
                |m: &mut MultimapKeysSideInput| { &mut m.side_input_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &MultimapKeysSideInput| { &m.window },
                |m: &mut MultimapKeysSideInput| { &mut m.window },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultimapKeysSideInput>(
                "StateKey.MultimapKeysSideInput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MultimapKeysSideInput {
        const NAME: &'static str = "MultimapKeysSideInput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.side_input_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.side_input_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.side_input_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.side_input_id.is_empty() {
                os.write_string(2, &self.side_input_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MultimapKeysSideInput {
            MultimapKeysSideInput::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.side_input_id.clear();
            self.window.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MultimapKeysSideInput {
            static instance: MultimapKeysSideInput = MultimapKeysSideInput {
                transform_id: ::std::string::String::new(),
                side_input_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MultimapKeysSideInput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.MultimapKeysSideInput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MultimapKeysSideInput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MultimapKeysSideInput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState)
    pub struct BagUserState {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState.user_state_id)
        pub user_state_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState.window)
        pub window: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState.key)
        pub key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.BagUserState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BagUserState {
        fn default() -> &'a BagUserState {
            <BagUserState as ::protobuf::Message>::default_instance()
        }
    }

    impl BagUserState {
        pub fn new() -> BagUserState {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &BagUserState| { &m.transform_id },
                |m: &mut BagUserState| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "user_state_id",
                |m: &BagUserState| { &m.user_state_id },
                |m: &mut BagUserState| { &mut m.user_state_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &BagUserState| { &m.window },
                |m: &mut BagUserState| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &BagUserState| { &m.key },
                |m: &mut BagUserState| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BagUserState>(
                "StateKey.BagUserState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BagUserState {
        const NAME: &'static str = "BagUserState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.user_state_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    34 => {
                        self.key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.user_state_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.user_state_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.user_state_id.is_empty() {
                os.write_string(2, &self.user_state_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            if !self.key.is_empty() {
                os.write_bytes(4, &self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BagUserState {
            BagUserState::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.user_state_id.clear();
            self.window.clear();
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BagUserState {
            static instance: BagUserState = BagUserState {
                transform_id: ::std::string::String::new(),
                user_state_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BagUserState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.BagUserState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BagUserState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BagUserState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState)
    pub struct MultimapKeysUserState {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState.user_state_id)
        pub user_state_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState.window)
        pub window: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState.key)
        pub key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapKeysUserState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MultimapKeysUserState {
        fn default() -> &'a MultimapKeysUserState {
            <MultimapKeysUserState as ::protobuf::Message>::default_instance()
        }
    }

    impl MultimapKeysUserState {
        pub fn new() -> MultimapKeysUserState {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &MultimapKeysUserState| { &m.transform_id },
                |m: &mut MultimapKeysUserState| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "user_state_id",
                |m: &MultimapKeysUserState| { &m.user_state_id },
                |m: &mut MultimapKeysUserState| { &mut m.user_state_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &MultimapKeysUserState| { &m.window },
                |m: &mut MultimapKeysUserState| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &MultimapKeysUserState| { &m.key },
                |m: &mut MultimapKeysUserState| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultimapKeysUserState>(
                "StateKey.MultimapKeysUserState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MultimapKeysUserState {
        const NAME: &'static str = "MultimapKeysUserState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.user_state_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    34 => {
                        self.key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.user_state_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.user_state_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.user_state_id.is_empty() {
                os.write_string(2, &self.user_state_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            if !self.key.is_empty() {
                os.write_bytes(4, &self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MultimapKeysUserState {
            MultimapKeysUserState::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.user_state_id.clear();
            self.window.clear();
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MultimapKeysUserState {
            static instance: MultimapKeysUserState = MultimapKeysUserState {
                transform_id: ::std::string::String::new(),
                user_state_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MultimapKeysUserState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.MultimapKeysUserState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MultimapKeysUserState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MultimapKeysUserState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState)
    pub struct MultimapUserState {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.transform_id)
        pub transform_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.user_state_id)
        pub user_state_id: ::std::string::String,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.window)
        pub window: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.key)
        pub key: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.map_key)
        pub map_key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateKey.MultimapUserState.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MultimapUserState {
        fn default() -> &'a MultimapUserState {
            <MultimapUserState as ::protobuf::Message>::default_instance()
        }
    }

    impl MultimapUserState {
        pub fn new() -> MultimapUserState {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "transform_id",
                |m: &MultimapUserState| { &m.transform_id },
                |m: &mut MultimapUserState| { &mut m.transform_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "user_state_id",
                |m: &MultimapUserState| { &m.user_state_id },
                |m: &mut MultimapUserState| { &mut m.user_state_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "window",
                |m: &MultimapUserState| { &m.window },
                |m: &mut MultimapUserState| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &MultimapUserState| { &m.key },
                |m: &mut MultimapUserState| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "map_key",
                |m: &MultimapUserState| { &m.map_key },
                |m: &mut MultimapUserState| { &mut m.map_key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultimapUserState>(
                "StateKey.MultimapUserState",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MultimapUserState {
        const NAME: &'static str = "MultimapUserState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.transform_id = is.read_string()?;
                    },
                    18 => {
                        self.user_state_id = is.read_string()?;
                    },
                    26 => {
                        self.window = is.read_bytes()?;
                    },
                    34 => {
                        self.key = is.read_bytes()?;
                    },
                    42 => {
                        self.map_key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.transform_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.transform_id);
            }
            if !self.user_state_id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.user_state_id);
            }
            if !self.window.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.window);
            }
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.key);
            }
            if !self.map_key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(5, &self.map_key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.transform_id.is_empty() {
                os.write_string(1, &self.transform_id)?;
            }
            if !self.user_state_id.is_empty() {
                os.write_string(2, &self.user_state_id)?;
            }
            if !self.window.is_empty() {
                os.write_bytes(3, &self.window)?;
            }
            if !self.key.is_empty() {
                os.write_bytes(4, &self.key)?;
            }
            if !self.map_key.is_empty() {
                os.write_bytes(5, &self.map_key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MultimapUserState {
            MultimapUserState::new()
        }

        fn clear(&mut self) {
            self.transform_id.clear();
            self.user_state_id.clear();
            self.window.clear();
            self.key.clear();
            self.map_key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MultimapUserState {
            static instance: MultimapUserState = MultimapUserState {
                transform_id: ::std::string::String::new(),
                user_state_id: ::std::string::String::new(),
                window: ::std::vec::Vec::new(),
                key: ::std::vec::Vec::new(),
                map_key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MultimapUserState {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StateKey.MultimapUserState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MultimapUserState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MultimapUserState {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateGetRequest)
pub struct StateGetRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateGetRequest.continuation_token)
    pub continuation_token: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateGetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateGetRequest {
    fn default() -> &'a StateGetRequest {
        <StateGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl StateGetRequest {
    pub fn new() -> StateGetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "continuation_token",
            |m: &StateGetRequest| { &m.continuation_token },
            |m: &mut StateGetRequest| { &mut m.continuation_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateGetRequest>(
            "StateGetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateGetRequest {
    const NAME: &'static str = "StateGetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.continuation_token = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.continuation_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.continuation_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.continuation_token.is_empty() {
            os.write_bytes(1, &self.continuation_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateGetRequest {
        StateGetRequest::new()
    }

    fn clear(&mut self) {
        self.continuation_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateGetRequest {
        static instance: StateGetRequest = StateGetRequest {
            continuation_token: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateGetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateGetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateGetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateGetResponse)
pub struct StateGetResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateGetResponse.continuation_token)
    pub continuation_token: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateGetResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateGetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateGetResponse {
    fn default() -> &'a StateGetResponse {
        <StateGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl StateGetResponse {
    pub fn new() -> StateGetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "continuation_token",
            |m: &StateGetResponse| { &m.continuation_token },
            |m: &mut StateGetResponse| { &mut m.continuation_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &StateGetResponse| { &m.data },
            |m: &mut StateGetResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateGetResponse>(
            "StateGetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateGetResponse {
    const NAME: &'static str = "StateGetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.continuation_token = is.read_bytes()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.continuation_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.continuation_token);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.continuation_token.is_empty() {
            os.write_bytes(1, &self.continuation_token)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateGetResponse {
        StateGetResponse::new()
    }

    fn clear(&mut self) {
        self.continuation_token.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateGetResponse {
        static instance: StateGetResponse = StateGetResponse {
            continuation_token: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateGetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateGetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateGetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateAppendRequest)
pub struct StateAppendRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StateAppendRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateAppendRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateAppendRequest {
    fn default() -> &'a StateAppendRequest {
        <StateAppendRequest as ::protobuf::Message>::default_instance()
    }
}

impl StateAppendRequest {
    pub fn new() -> StateAppendRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &StateAppendRequest| { &m.data },
            |m: &mut StateAppendRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateAppendRequest>(
            "StateAppendRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateAppendRequest {
    const NAME: &'static str = "StateAppendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateAppendRequest {
        StateAppendRequest::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateAppendRequest {
        static instance: StateAppendRequest = StateAppendRequest {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateAppendRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateAppendRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateAppendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateAppendRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateAppendResponse)
pub struct StateAppendResponse {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateAppendResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateAppendResponse {
    fn default() -> &'a StateAppendResponse {
        <StateAppendResponse as ::protobuf::Message>::default_instance()
    }
}

impl StateAppendResponse {
    pub fn new() -> StateAppendResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateAppendResponse>(
            "StateAppendResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateAppendResponse {
    const NAME: &'static str = "StateAppendResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateAppendResponse {
        StateAppendResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateAppendResponse {
        static instance: StateAppendResponse = StateAppendResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateAppendResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateAppendResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateAppendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateAppendResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateClearRequest)
pub struct StateClearRequest {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateClearRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateClearRequest {
    fn default() -> &'a StateClearRequest {
        <StateClearRequest as ::protobuf::Message>::default_instance()
    }
}

impl StateClearRequest {
    pub fn new() -> StateClearRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateClearRequest>(
            "StateClearRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateClearRequest {
    const NAME: &'static str = "StateClearRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateClearRequest {
        StateClearRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateClearRequest {
        static instance: StateClearRequest = StateClearRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateClearRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateClearRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateClearRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateClearRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StateClearResponse)
pub struct StateClearResponse {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StateClearResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateClearResponse {
    fn default() -> &'a StateClearResponse {
        <StateClearResponse as ::protobuf::Message>::default_instance()
    }
}

impl StateClearResponse {
    pub fn new() -> StateClearResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateClearResponse>(
            "StateClearResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateClearResponse {
    const NAME: &'static str = "StateClearResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateClearResponse {
        StateClearResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateClearResponse {
        static instance: StateClearResponse = StateClearResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateClearResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateClearResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateClearResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateClearResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.LogEntry)
pub struct LogEntry {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.severity)
    pub severity: ::protobuf::EnumOrUnknown<log_entry::severity::Enum>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.trace)
    pub trace: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.instruction_id)
    pub instruction_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.transform_id)
    pub transform_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.log_location)
    pub log_location: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.thread)
    pub thread: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.LogEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogEntry {
    fn default() -> &'a LogEntry {
        <LogEntry as ::protobuf::Message>::default_instance()
    }
}

impl LogEntry {
    pub fn new() -> LogEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "severity",
            |m: &LogEntry| { &m.severity },
            |m: &mut LogEntry| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &LogEntry| { &m.timestamp },
            |m: &mut LogEntry| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &LogEntry| { &m.message },
            |m: &mut LogEntry| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace",
            |m: &LogEntry| { &m.trace },
            |m: &mut LogEntry| { &mut m.trace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "instruction_id",
            |m: &LogEntry| { &m.instruction_id },
            |m: &mut LogEntry| { &mut m.instruction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transform_id",
            |m: &LogEntry| { &m.transform_id },
            |m: &mut LogEntry| { &mut m.transform_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log_location",
            |m: &LogEntry| { &m.log_location },
            |m: &mut LogEntry| { &mut m.log_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "thread",
            |m: &LogEntry| { &m.thread },
            |m: &mut LogEntry| { &mut m.thread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogEntry>(
            "LogEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogEntry {
    const NAME: &'static str = "LogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.severity = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                34 => {
                    self.trace = is.read_string()?;
                },
                42 => {
                    self.instruction_id = is.read_string()?;
                },
                50 => {
                    self.transform_id = is.read_string()?;
                },
                58 => {
                    self.log_location = is.read_string()?;
                },
                66 => {
                    self.thread = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.severity != ::protobuf::EnumOrUnknown::new(log_entry::severity::Enum::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.severity.value());
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if !self.trace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trace);
        }
        if !self.instruction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.instruction_id);
        }
        if !self.transform_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.transform_id);
        }
        if !self.log_location.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.log_location);
        }
        if !self.thread.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.thread);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.severity != ::protobuf::EnumOrUnknown::new(log_entry::severity::Enum::UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.severity))?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if !self.trace.is_empty() {
            os.write_string(4, &self.trace)?;
        }
        if !self.instruction_id.is_empty() {
            os.write_string(5, &self.instruction_id)?;
        }
        if !self.transform_id.is_empty() {
            os.write_string(6, &self.transform_id)?;
        }
        if !self.log_location.is_empty() {
            os.write_string(7, &self.log_location)?;
        }
        if !self.thread.is_empty() {
            os.write_string(8, &self.thread)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogEntry {
        LogEntry::new()
    }

    fn clear(&mut self) {
        self.severity = ::protobuf::EnumOrUnknown::new(log_entry::severity::Enum::UNSPECIFIED);
        self.timestamp.clear();
        self.message.clear();
        self.trace.clear();
        self.instruction_id.clear();
        self.transform_id.clear();
        self.log_location.clear();
        self.thread.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogEntry {
        static instance: LogEntry = LogEntry {
            severity: ::protobuf::EnumOrUnknown::from_i32(0),
            timestamp: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            trace: ::std::string::String::new(),
            instruction_id: ::std::string::String::new(),
            transform_id: ::std::string::String::new(),
            log_location: ::std::string::String::new(),
            thread: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogEntry`
pub mod log_entry {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.LogEntry.List)
    pub struct List {
        // message fields
        // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.LogEntry.List.log_entries)
        pub log_entries: ::std::vec::Vec<super::LogEntry>,
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.LogEntry.List.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a List {
        fn default() -> &'a List {
            <List as ::protobuf::Message>::default_instance()
        }
    }

    impl List {
        pub fn new() -> List {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "log_entries",
                |m: &List| { &m.log_entries },
                |m: &mut List| { &mut m.log_entries },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<List>(
                "LogEntry.List",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for List {
        const NAME: &'static str = "List";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.log_entries.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.log_entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.log_entries {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> List {
            List::new()
        }

        fn clear(&mut self) {
            self.log_entries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static List {
            static instance: List = List {
                log_entries: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for List {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogEntry.List").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for List {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for List {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.LogEntry.Severity)
    pub struct Severity {
        // special fields
        // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Severity {
        fn default() -> &'a Severity {
            <Severity as ::protobuf::Message>::default_instance()
        }
    }

    impl Severity {
        pub fn new() -> Severity {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Severity>(
                "LogEntry.Severity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Severity {
        const NAME: &'static str = "Severity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Severity {
            Severity::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Severity {
            static instance: Severity = Severity {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Severity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogEntry.Severity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Severity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Severity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Severity`
    pub mod severity {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum)
        pub enum Enum {
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.UNSPECIFIED)
            UNSPECIFIED = 0,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.TRACE)
            TRACE = 1,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.DEBUG)
            DEBUG = 2,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.INFO)
            INFO = 3,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.NOTICE)
            NOTICE = 4,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.WARN)
            WARN = 5,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.ERROR)
            ERROR = 6,
            // @@protoc_insertion_point(enum_value:org.apache.beam.model.fn_execution.v1.LogEntry.Severity.Enum.CRITICAL)
            CRITICAL = 7,
        }

        impl ::protobuf::Enum for Enum {
            const NAME: &'static str = "Enum";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Enum> {
                match value {
                    0 => ::std::option::Option::Some(Enum::UNSPECIFIED),
                    1 => ::std::option::Option::Some(Enum::TRACE),
                    2 => ::std::option::Option::Some(Enum::DEBUG),
                    3 => ::std::option::Option::Some(Enum::INFO),
                    4 => ::std::option::Option::Some(Enum::NOTICE),
                    5 => ::std::option::Option::Some(Enum::WARN),
                    6 => ::std::option::Option::Some(Enum::ERROR),
                    7 => ::std::option::Option::Some(Enum::CRITICAL),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Enum] = &[
                Enum::UNSPECIFIED,
                Enum::TRACE,
                Enum::DEBUG,
                Enum::INFO,
                Enum::NOTICE,
                Enum::WARN,
                Enum::ERROR,
                Enum::CRITICAL,
            ];
        }

        impl ::protobuf::EnumFull for Enum {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("LogEntry.Severity.Enum").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Enum {
            fn default() -> Self {
                Enum::UNSPECIFIED
            }
        }

        impl Enum {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("LogEntry.Severity.Enum")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.LogControl)
pub struct LogControl {
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.LogControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogControl {
    fn default() -> &'a LogControl {
        <LogControl as ::protobuf::Message>::default_instance()
    }
}

impl LogControl {
    pub fn new() -> LogControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogControl>(
            "LogControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogControl {
    const NAME: &'static str = "LogControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogControl {
        LogControl::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogControl {
        static instance: LogControl = LogControl {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StartWorkerRequest)
pub struct StartWorkerRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.worker_id)
    pub worker_id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.control_endpoint)
    pub control_endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.logging_endpoint)
    pub logging_endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.artifact_endpoint)
    pub artifact_endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.provision_endpoint)
    pub provision_endpoint: ::protobuf::MessageField<super::endpoints::ApiServiceDescriptor>,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.params)
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StartWorkerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartWorkerRequest {
    fn default() -> &'a StartWorkerRequest {
        <StartWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartWorkerRequest {
    pub fn new() -> StartWorkerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "worker_id",
            |m: &StartWorkerRequest| { &m.worker_id },
            |m: &mut StartWorkerRequest| { &mut m.worker_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "control_endpoint",
            |m: &StartWorkerRequest| { &m.control_endpoint },
            |m: &mut StartWorkerRequest| { &mut m.control_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "logging_endpoint",
            |m: &StartWorkerRequest| { &m.logging_endpoint },
            |m: &mut StartWorkerRequest| { &mut m.logging_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "artifact_endpoint",
            |m: &StartWorkerRequest| { &m.artifact_endpoint },
            |m: &mut StartWorkerRequest| { &mut m.artifact_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::endpoints::ApiServiceDescriptor>(
            "provision_endpoint",
            |m: &StartWorkerRequest| { &m.provision_endpoint },
            |m: &mut StartWorkerRequest| { &mut m.provision_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "params",
            |m: &StartWorkerRequest| { &m.params },
            |m: &mut StartWorkerRequest| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartWorkerRequest>(
            "StartWorkerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartWorkerRequest {
    const NAME: &'static str = "StartWorkerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.worker_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.control_endpoint)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.logging_endpoint)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.artifact_endpoint)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.provision_endpoint)?;
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.params.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        if let Some(v) = self.control_endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.logging_endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.artifact_endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.provision_endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        if let Some(v) = self.control_endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.logging_endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.artifact_endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.provision_endpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for (k, v) in &self.params {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartWorkerRequest {
        StartWorkerRequest::new()
    }

    fn clear(&mut self) {
        self.worker_id.clear();
        self.control_endpoint.clear();
        self.logging_endpoint.clear();
        self.artifact_endpoint.clear();
        self.provision_endpoint.clear();
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartWorkerRequest {
        static instance: ::protobuf::rt::Lazy<StartWorkerRequest> = ::protobuf::rt::Lazy::new();
        instance.get(StartWorkerRequest::new)
    }
}

impl ::protobuf::MessageFull for StartWorkerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartWorkerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartWorkerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StartWorkerResponse)
pub struct StartWorkerResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StartWorkerResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StartWorkerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartWorkerResponse {
    fn default() -> &'a StartWorkerResponse {
        <StartWorkerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartWorkerResponse {
    pub fn new() -> StartWorkerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &StartWorkerResponse| { &m.error },
            |m: &mut StartWorkerResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartWorkerResponse>(
            "StartWorkerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartWorkerResponse {
    const NAME: &'static str = "StartWorkerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartWorkerResponse {
        StartWorkerResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartWorkerResponse {
        static instance: StartWorkerResponse = StartWorkerResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartWorkerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartWorkerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartWorkerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartWorkerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StopWorkerRequest)
pub struct StopWorkerRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StopWorkerRequest.worker_id)
    pub worker_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StopWorkerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StopWorkerRequest {
    fn default() -> &'a StopWorkerRequest {
        <StopWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopWorkerRequest {
    pub fn new() -> StopWorkerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "worker_id",
            |m: &StopWorkerRequest| { &m.worker_id },
            |m: &mut StopWorkerRequest| { &mut m.worker_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopWorkerRequest>(
            "StopWorkerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StopWorkerRequest {
    const NAME: &'static str = "StopWorkerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.worker_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StopWorkerRequest {
        StopWorkerRequest::new()
    }

    fn clear(&mut self) {
        self.worker_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StopWorkerRequest {
        static instance: StopWorkerRequest = StopWorkerRequest {
            worker_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StopWorkerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StopWorkerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StopWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopWorkerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.StopWorkerResponse)
pub struct StopWorkerResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.StopWorkerResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.StopWorkerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StopWorkerResponse {
    fn default() -> &'a StopWorkerResponse {
        <StopWorkerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopWorkerResponse {
    pub fn new() -> StopWorkerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &StopWorkerResponse| { &m.error },
            |m: &mut StopWorkerResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopWorkerResponse>(
            "StopWorkerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StopWorkerResponse {
    const NAME: &'static str = "StopWorkerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StopWorkerResponse {
        StopWorkerResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StopWorkerResponse {
        static instance: StopWorkerResponse = StopWorkerResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StopWorkerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StopWorkerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StopWorkerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopWorkerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.WorkerStatusRequest)
pub struct WorkerStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.WorkerStatusRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.WorkerStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkerStatusRequest {
    fn default() -> &'a WorkerStatusRequest {
        <WorkerStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkerStatusRequest {
    pub fn new() -> WorkerStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkerStatusRequest| { &m.id },
            |m: &mut WorkerStatusRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkerStatusRequest>(
            "WorkerStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkerStatusRequest {
    const NAME: &'static str = "WorkerStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkerStatusRequest {
        WorkerStatusRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkerStatusRequest {
        static instance: WorkerStatusRequest = WorkerStatusRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkerStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkerStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkerStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.apache.beam.model.fn_execution.v1.WorkerStatusResponse)
pub struct WorkerStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.WorkerStatusResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.WorkerStatusResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:org.apache.beam.model.fn_execution.v1.WorkerStatusResponse.status_info)
    pub status_info: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.apache.beam.model.fn_execution.v1.WorkerStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkerStatusResponse {
    fn default() -> &'a WorkerStatusResponse {
        <WorkerStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl WorkerStatusResponse {
    pub fn new() -> WorkerStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkerStatusResponse| { &m.id },
            |m: &mut WorkerStatusResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &WorkerStatusResponse| { &m.error },
            |m: &mut WorkerStatusResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_info",
            |m: &WorkerStatusResponse| { &m.status_info },
            |m: &mut WorkerStatusResponse| { &mut m.status_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkerStatusResponse>(
            "WorkerStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkerStatusResponse {
    const NAME: &'static str = "WorkerStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                26 => {
                    self.status_info = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.status_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.status_info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.status_info.is_empty() {
            os.write_string(3, &self.status_info)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkerStatusResponse {
        WorkerStatusResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.error.clear();
        self.status_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkerStatusResponse {
        static instance: WorkerStatusResponse = WorkerStatusResponse {
            id: ::std::string::String::new(),
            error: ::std::string::String::new(),
            status_info: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkerStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkerStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkerStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n7org/apache/beam/model/fn_execution/v1/beam_fn_api.proto\x12%org.apach\
    e.beam.model.fn_execution.v1\x1a7org/apache/beam/model/pipeline/v1/beam_\
    runner_api.proto\x1a1org/apache/beam/model/pipeline/v1/endpoints.proto\
    \x1a/org/apache/beam/model/pipeline/v1/metrics.proto\x1a\x20google/proto\
    buf/descriptor.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogl\
    e/protobuf/duration.proto\"\x9a\x01\n\x0eRemoteGrpcPort\x12m\n\x16api_se\
    rvice_descriptor\x18\x01\x20\x01(\x0b27.org.apache.beam.model.pipeline.v\
    1.ApiServiceDescriptorR\x14apiServiceDescriptor\x12\x19\n\x08coder_id\
    \x18\x02\x20\x01(\tR\x07coderId\"d\n!GetProcessBundleDescriptorRequest\
    \x12?\n\x1cprocess_bundle_descriptor_id\x18\x01\x20\x01(\tR\x19processBu\
    ndleDescriptorId\"\xde\x06\n\x12InstructionRequest\x12%\n\x0einstruction\
    _id\x18\x01\x20\x01(\tR\rinstructionId\x12e\n\x0eprocess_bundle\x18\xe9\
    \x07\x20\x01(\x0b2;.org.apache.beam.model.fn_execution.v1.ProcessBundleR\
    equestH\0R\rprocessBundle\x12~\n\x17process_bundle_progress\x18\xea\x07\
    \x20\x01(\x0b2C.org.apache.beam.model.fn_execution.v1.ProcessBundleProgr\
    essRequestH\0R\x15processBundleProgress\x12u\n\x14process_bundle_split\
    \x18\xeb\x07\x20\x01(\x0b2@.org.apache.beam.model.fn_execution.v1.Proces\
    sBundleSplitRequestH\0R\x12processBundleSplit\x12h\n\x0ffinalize_bundle\
    \x18\xec\x07\x20\x01(\x0b2<.org.apache.beam.model.fn_execution.v1.Finali\
    zeBundleRequestH\0R\x0efinalizeBundle\x12s\n\x10monitoring_infos\x18\xed\
    \x07\x20\x01(\x0b2E.org.apache.beam.model.fn_execution.v1.MonitoringInfo\
    sMetadataRequestH\0R\x0fmonitoringInfos\x12\x81\x01\n\x18harness_monitor\
    ing_infos\x18\xee\x07\x20\x01(\x0b2D.org.apache.beam.model.fn_execution.\
    v1.HarnessMonitoringInfosRequestH\0R\x16harnessMonitoringInfos\x12U\n\
    \x08register\x18\xe8\x07\x20\x01(\x0b26.org.apache.beam.model.fn_executi\
    on.v1.RegisterRequestH\0R\x08registerB\t\n\x07request\"\xfd\x06\n\x13Ins\
    tructionResponse\x12%\n\x0einstruction_id\x18\x01\x20\x01(\tR\rinstructi\
    onId\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x12f\n\x0eprocess_b\
    undle\x18\xe9\x07\x20\x01(\x0b2<.org.apache.beam.model.fn_execution.v1.P\
    rocessBundleResponseH\0R\rprocessBundle\x12\x7f\n\x17process_bundle_prog\
    ress\x18\xea\x07\x20\x01(\x0b2D.org.apache.beam.model.fn_execution.v1.Pr\
    ocessBundleProgressResponseH\0R\x15processBundleProgress\x12v\n\x14proce\
    ss_bundle_split\x18\xeb\x07\x20\x01(\x0b2A.org.apache.beam.model.fn_exec\
    ution.v1.ProcessBundleSplitResponseH\0R\x12processBundleSplit\x12i\n\x0f\
    finalize_bundle\x18\xec\x07\x20\x01(\x0b2=.org.apache.beam.model.fn_exec\
    ution.v1.FinalizeBundleResponseH\0R\x0efinalizeBundle\x12t\n\x10monitori\
    ng_infos\x18\xed\x07\x20\x01(\x0b2F.org.apache.beam.model.fn_execution.v\
    1.MonitoringInfosMetadataResponseH\0R\x0fmonitoringInfos\x12\x82\x01\n\
    \x18harness_monitoring_infos\x18\xee\x07\x20\x01(\x0b2E.org.apache.beam.\
    model.fn_execution.v1.HarnessMonitoringInfosResponseH\0R\x16harnessMonit\
    oringInfos\x12V\n\x08register\x18\xe8\x07\x20\x01(\x0b27.org.apache.beam\
    .model.fn_execution.v1.RegisterResponseH\0R\x08registerB\n\n\x08response\
    \"\x1f\n\x1dHarnessMonitoringInfosRequest\"\xe8\x01\n\x1eHarnessMonitori\
    ngInfosResponse\x12\x82\x01\n\x0fmonitoring_data\x18\x01\x20\x03(\x0b2Y.\
    org.apache.beam.model.fn_execution.v1.HarnessMonitoringInfosResponse.Mon\
    itoringDataEntryR\x0emonitoringData\x1aA\n\x13MonitoringDataEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x0cR\x05value:\x028\x01\"\x8d\x01\n\x0fRegisterRequest\x12z\n\x19p\
    rocess_bundle_descriptor\x18\x01\x20\x03(\x0b2>.org.apache.beam.model.fn\
    _execution.v1.ProcessBundleDescriptorR\x17processBundleDescriptor\"\x12\
    \n\x10RegisterResponse\"\x9d\x0b\n\x17ProcessBundleDescriptor\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12n\n\ntransforms\x18\x02\x20\x03(\x0b\
    2N.org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.Transfo\
    rmsEntryR\ntransforms\x12t\n\x0cpcollections\x18\x03\x20\x03(\x0b2P.org.\
    apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.PcollectionsEn\
    tryR\x0cpcollections\x12\x8a\x01\n\x14windowing_strategies\x18\x04\x20\
    \x03(\x0b2W.org.apache.beam.model.fn_execution.v1.ProcessBundleDescripto\
    r.WindowingStrategiesEntryR\x13windowingStrategies\x12b\n\x06coders\x18\
    \x05\x20\x03(\x0b2J.org.apache.beam.model.fn_execution.v1.ProcessBundleD\
    escriptor.CodersEntryR\x06coders\x12t\n\x0cenvironments\x18\x06\x20\x03(\
    \x0b2P.org.apache.beam.model.fn_execution.v1.ProcessBundleDescriptor.Env\
    ironmentsEntryR\x0cenvironments\x12x\n\x1cstate_api_service_descriptor\
    \x18\x07\x20\x01(\x0b27.org.apache.beam.model.pipeline.v1.ApiServiceDesc\
    riptorR\x19stateApiServiceDescriptor\x12x\n\x1ctimer_api_service_descrip\
    tor\x18\x08\x20\x01(\x0b27.org.apache.beam.model.pipeline.v1.ApiServiceD\
    escriptorR\x19timerApiServiceDescriptor\x1al\n\x0fTransformsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12C\n\x05value\x18\x02\x20\x01\
    (\x0b2-.org.apache.beam.model.pipeline.v1.PTransformR\x05value:\x028\x01\
    \x1ao\n\x11PcollectionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..org.apache.beam.model.pipeline.v\
    1.PCollectionR\x05value:\x028\x01\x1a|\n\x18WindowingStrategiesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12J\n\x05value\x18\x02\x20\x01\
    (\x0b24.org.apache.beam.model.pipeline.v1.WindowingStrategyR\x05value:\
    \x028\x01\x1ac\n\x0bCodersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12>\n\x05value\x18\x02\x20\x01(\x0b2(.org.apache.beam.model.pipelin\
    e.v1.CoderR\x05value:\x028\x01\x1ao\n\x11EnvironmentsEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..or\
    g.apache.beam.model.pipeline.v1.EnvironmentR\x05value:\x028\x01\"\x9b\
    \x03\n\x11BundleApplication\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\
    \x0btransformId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\x12\
    \x18\n\x07element\x18\x03\x20\x01(\x0cR\x07element\x12{\n\x11output_wate\
    rmarks\x18\x04\x20\x03(\x0b2N.org.apache.beam.model.fn_execution.v1.Bund\
    leApplication.OutputWatermarksEntryR\x10outputWatermarks\x12P\n\nis_boun\
    ded\x18\x05\x20\x01(\x0e21.org.apache.beam.model.pipeline.v1.IsBounded.E\
    numR\tisBounded\x1a_\n\x15OutputWatermarksEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x120\n\x05value\x18\x02\x20\x01(\x0b2\x1a.google.pro\
    tobuf.TimestampR\x05value:\x028\x01\"\xc3\x01\n\x18DelayedBundleApplicat\
    ion\x12Z\n\x0bapplication\x18\x01\x20\x01(\x0b28.org.apache.beam.model.f\
    n_execution.v1.BundleApplicationR\x0bapplication\x12K\n\x14requested_tim\
    e_delay\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x12requested\
    TimeDelay\"\x83\x05\n\x14ProcessBundleRequest\x12?\n\x1cprocess_bundle_d\
    escriptor_id\x18\x01\x20\x01(\tR\x19processBundleDescriptorId\x12i\n\x0c\
    cache_tokens\x18\x02\x20\x03(\x0b2F.org.apache.beam.model.fn_execution.v\
    1.ProcessBundleRequest.CacheTokenR\x0bcacheTokens\x12K\n\x08elements\x18\
    \x03\x20\x01(\x0b2/.org.apache.beam.model.fn_execution.v1.ElementsR\x08e\
    lements\x1a\xf1\x02\n\nCacheToken\x12q\n\nuser_state\x18\x01\x20\x01(\
    \x0b2P.org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheT\
    oken.UserStateH\0R\tuserState\x12q\n\nside_input\x18\x02\x20\x01(\x0b2P.\
    org.apache.beam.model.fn_execution.v1.ProcessBundleRequest.CacheToken.Si\
    deInputH\0R\tsideInput\x12\x14\n\x05token\x18\n\x20\x01(\x0cR\x05token\
    \x1a\x0b\n\tUserState\x1aR\n\tSideInput\x12!\n\x0ctransform_id\x18\x01\
    \x20\x01(\tR\x0btransformId\x12\"\n\rside_input_id\x18\x02\x20\x01(\tR\
    \x0bsideInputIdB\x06\n\x04type\"\xa3\x04\n\x15ProcessBundleResponse\x12f\
    \n\x0eresidual_roots\x18\x02\x20\x03(\x0b2?.org.apache.beam.model.fn_exe\
    cution.v1.DelayedBundleApplicationR\rresidualRoots\x12\\\n\x10monitoring\
    _infos\x18\x03\x20\x03(\x0b21.org.apache.beam.model.pipeline.v1.Monitori\
    ngInfoR\x0fmonitoringInfos\x123\n\x15requires_finalization\x18\x04\x20\
    \x01(\x08R\x14requiresFinalization\x12y\n\x0fmonitoring_data\x18\x05\x20\
    \x03(\x0b2P.org.apache.beam.model.fn_execution.v1.ProcessBundleResponse.\
    MonitoringDataEntryR\x0emonitoringData\x12K\n\x08elements\x18\x06\x20\
    \x01(\x0b2/.org.apache.beam.model.fn_execution.v1.ElementsR\x08elements\
    \x1aA\n\x13MonitoringDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01J\x04\x08\
    \x01\x10\x02\"E\n\x1cProcessBundleProgressRequest\x12%\n\x0einstruction_\
    id\x18\x01\x20\x01(\tR\rinstructionId\"N\n\x1eMonitoringInfosMetadataReq\
    uest\x12,\n\x12monitoring_info_id\x18\x01\x20\x03(\tR\x10monitoringInfoI\
    d\"\xd6\x02\n\x1dProcessBundleProgressResponse\x12\\\n\x10monitoring_inf\
    os\x18\x03\x20\x03(\x0b21.org.apache.beam.model.pipeline.v1.MonitoringIn\
    foR\x0fmonitoringInfos\x12\x81\x01\n\x0fmonitoring_data\x18\x05\x20\x03(\
    \x0b2X.org.apache.beam.model.fn_execution.v1.ProcessBundleProgressRespon\
    se.MonitoringDataEntryR\x0emonitoringData\x1aA\n\x13MonitoringDataEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x0cR\x05value:\x028\x01J\x04\x08\x01\x10\x02J\x04\x08\x02\x10\
    \x03J\x04\x08\x04\x10\x05\"\x9d\x02\n\x1fMonitoringInfosMetadataResponse\
    \x12\x83\x01\n\x0fmonitoring_info\x18\x01\x20\x03(\x0b2Z.org.apache.beam\
    .model.fn_execution.v1.MonitoringInfosMetadataResponse.MonitoringInfoEnt\
    ryR\x0emonitoringInfo\x1at\n\x13MonitoringInfoEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12G\n\x05value\x18\x02\x20\x01(\x0b21.org.apach\
    e.beam.model.pipeline.v1.MonitoringInfoR\x05value:\x028\x01\"\x81\x04\n\
    \x19ProcessBundleSplitRequest\x12%\n\x0einstruction_id\x18\x01\x20\x01(\
    \tR\rinstructionId\x12z\n\x0edesired_splits\x18\x03\x20\x03(\x0b2S.org.a\
    pache.beam.model.fn_execution.v1.ProcessBundleSplitRequest.DesiredSplits\
    EntryR\rdesiredSplits\x1a\xae\x01\n\x0cDesiredSplit\x122\n\x15fraction_o\
    f_remainder\x18\x01\x20\x01(\x01R\x13fractionOfRemainder\x120\n\x14allow\
    ed_split_points\x18\x03\x20\x03(\x03R\x12allowedSplitPoints\x128\n\x18es\
    timated_input_elements\x18\x02\x20\x01(\x03R\x16estimatedInputElements\
    \x1a\x8f\x01\n\x12DesiredSplitsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\t\
    R\x03key\x12c\n\x05value\x18\x02\x20\x01(\x0b2M.org.apache.beam.model.fn\
    _execution.v1.ProcessBundleSplitRequest.DesiredSplitR\x05value:\x028\x01\
    \"\xf6\x03\n\x1aProcessBundleSplitResponse\x12]\n\rprimary_roots\x18\x01\
    \x20\x03(\x0b28.org.apache.beam.model.fn_execution.v1.BundleApplicationR\
    \x0cprimaryRoots\x12f\n\x0eresidual_roots\x18\x02\x20\x03(\x0b2?.org.apa\
    che.beam.model.fn_execution.v1.DelayedBundleApplicationR\rresidualRoots\
    \x12u\n\x0echannel_splits\x18\x03\x20\x03(\x0b2N.org.apache.beam.model.f\
    n_execution.v1.ProcessBundleSplitResponse.ChannelSplitR\rchannelSplits\
    \x1a\x99\x01\n\x0cChannelSplit\x12!\n\x0ctransform_id\x18\x01\x20\x01(\t\
    R\x0btransformId\x120\n\x14last_primary_element\x18\x02\x20\x01(\x03R\
    \x12lastPrimaryElement\x124\n\x16first_residual_element\x18\x03\x20\x01(\
    \x03R\x14firstResidualElement\">\n\x15FinalizeBundleRequest\x12%\n\x0ein\
    struction_id\x18\x01\x20\x01(\tR\rinstructionId\"\x18\n\x16FinalizeBundl\
    eResponse\"\xd1\x03\n\x08Elements\x12H\n\x04data\x18\x01\x20\x03(\x0b24.\
    org.apache.beam.model.fn_execution.v1.Elements.DataR\x04data\x12N\n\x06t\
    imers\x18\x02\x20\x03(\x0b26.org.apache.beam.model.fn_execution.v1.Eleme\
    nts.TimersR\x06timers\x1a}\n\x04Data\x12%\n\x0einstruction_id\x18\x01\
    \x20\x01(\tR\rinstructionId\x12!\n\x0ctransform_id\x18\x02\x20\x01(\tR\
    \x0btransformId\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\x12\x17\
    \n\x07is_last\x18\x04\x20\x01(\x08R\x06isLast\x1a\xab\x01\n\x06Timers\
    \x12%\n\x0einstruction_id\x18\x01\x20\x01(\tR\rinstructionId\x12!\n\x0ct\
    ransform_id\x18\x02\x20\x01(\tR\x0btransformId\x12&\n\x0ftimer_family_id\
    \x18\x03\x20\x01(\tR\rtimerFamilyId\x12\x16\n\x06timers\x18\x04\x20\x01(\
    \x0cR\x06timers\x12\x17\n\x07is_last\x18\x05\x20\x01(\x08R\x06isLast\"\
    \x94\x03\n\x0cStateRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    %\n\x0einstruction_id\x18\x02\x20\x01(\tR\rinstructionId\x12L\n\tstate_k\
    ey\x18\x03\x20\x01(\x0b2/.org.apache.beam.model.fn_execution.v1.StateKey\
    R\x08stateKey\x12K\n\x03get\x18\xe8\x07\x20\x01(\x0b26.org.apache.beam.m\
    odel.fn_execution.v1.StateGetRequestH\0R\x03get\x12T\n\x06append\x18\xe9\
    \x07\x20\x01(\x0b29.org.apache.beam.model.fn_execution.v1.StateAppendReq\
    uestH\0R\x06append\x12Q\n\x05clear\x18\xea\x07\x20\x01(\x0b28.org.apache\
    .beam.model.fn_execution.v1.StateClearRequestH\0R\x05clearB\t\n\x07reque\
    st\"\xba\x02\n\rStateResponse\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x12L\n\x03get\x18\xe8\
    \x07\x20\x01(\x0b27.org.apache.beam.model.fn_execution.v1.StateGetRespon\
    seH\0R\x03get\x12U\n\x06append\x18\xe9\x07\x20\x01(\x0b2:.org.apache.bea\
    m.model.fn_execution.v1.StateAppendResponseH\0R\x06append\x12R\n\x05clea\
    r\x18\xea\x07\x20\x01(\x0b29.org.apache.beam.model.fn_execution.v1.State\
    ClearResponseH\0R\x05clearB\n\n\x08response\"\xea\x0c\n\x08StateKey\x12P\
    \n\x06runner\x18\x01\x20\x01(\x0b26.org.apache.beam.model.fn_execution.v\
    1.StateKey.RunnerH\0R\x06runner\x12s\n\x13multimap_side_input\x18\x02\
    \x20\x01(\x0b2A.org.apache.beam.model.fn_execution.v1.StateKey.MultimapS\
    ideInputH\0R\x11multimapSideInput\x12d\n\x0ebag_user_state\x18\x03\x20\
    \x01(\x0b2<.org.apache.beam.model.fn_execution.v1.StateKey.BagUserStateH\
    \0R\x0cbagUserState\x12s\n\x13iterable_side_input\x18\x04\x20\x01(\x0b2A\
    .org.apache.beam.model.fn_execution.v1.StateKey.IterableSideInputH\0R\
    \x11iterableSideInput\x12\x80\x01\n\x18multimap_keys_side_input\x18\x05\
    \x20\x01(\x0b2E.org.apache.beam.model.fn_execution.v1.StateKey.MultimapK\
    eysSideInputH\0R\x15multimapKeysSideInput\x12\x80\x01\n\x18multimap_keys\
    _user_state\x18\x06\x20\x01(\x0b2E.org.apache.beam.model.fn_execution.v1\
    .StateKey.MultimapKeysUserStateH\0R\x15multimapKeysUserState\x12s\n\x13m\
    ultimap_user_state\x18\x07\x20\x01(\x0b2A.org.apache.beam.model.fn_execu\
    tion.v1.StateKey.MultimapUserStateH\0R\x11multimapUserState\x1a\x1a\n\
    \x06Runner\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x1ar\n\x11Itera\
    bleSideInput\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btransformId\
    \x12\"\n\rside_input_id\x18\x02\x20\x01(\tR\x0bsideInputId\x12\x16\n\x06\
    window\x18\x03\x20\x01(\x0cR\x06window\x1a\x84\x01\n\x11MultimapSideInpu\
    t\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btransformId\x12\"\n\rsid\
    e_input_id\x18\x02\x20\x01(\tR\x0bsideInputId\x12\x16\n\x06window\x18\
    \x03\x20\x01(\x0cR\x06window\x12\x10\n\x03key\x18\x04\x20\x01(\x0cR\x03k\
    ey\x1av\n\x15MultimapKeysSideInput\x12!\n\x0ctransform_id\x18\x01\x20\
    \x01(\tR\x0btransformId\x12\"\n\rside_input_id\x18\x02\x20\x01(\tR\x0bsi\
    deInputId\x12\x16\n\x06window\x18\x03\x20\x01(\x0cR\x06window\x1a\x7f\n\
    \x0cBagUserState\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btransform\
    Id\x12\"\n\ruser_state_id\x18\x02\x20\x01(\tR\x0buserStateId\x12\x16\n\
    \x06window\x18\x03\x20\x01(\x0cR\x06window\x12\x10\n\x03key\x18\x04\x20\
    \x01(\x0cR\x03key\x1a\x88\x01\n\x15MultimapKeysUserState\x12!\n\x0ctrans\
    form_id\x18\x01\x20\x01(\tR\x0btransformId\x12\"\n\ruser_state_id\x18\
    \x02\x20\x01(\tR\x0buserStateId\x12\x16\n\x06window\x18\x03\x20\x01(\x0c\
    R\x06window\x12\x10\n\x03key\x18\x04\x20\x01(\x0cR\x03key\x1a\x9d\x01\n\
    \x11MultimapUserState\x12!\n\x0ctransform_id\x18\x01\x20\x01(\tR\x0btran\
    sformId\x12\"\n\ruser_state_id\x18\x02\x20\x01(\tR\x0buserStateId\x12\
    \x16\n\x06window\x18\x03\x20\x01(\x0cR\x06window\x12\x10\n\x03key\x18\
    \x04\x20\x01(\x0cR\x03key\x12\x17\n\x07map_key\x18\x05\x20\x01(\x0cR\x06\
    mapKeyB\x06\n\x04type\"@\n\x0fStateGetRequest\x12-\n\x12continuation_tok\
    en\x18\x01\x20\x01(\x0cR\x11continuationToken\"U\n\x10StateGetResponse\
    \x12-\n\x12continuation_token\x18\x01\x20\x01(\x0cR\x11continuationToken\
    \x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"(\n\x12StateAppendRequ\
    est\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"\x15\n\x13StateAppe\
    ndResponse\"\x13\n\x11StateClearRequest\"\x14\n\x12StateClearResponse\"\
    \xa2\x04\n\x08LogEntry\x12Y\n\x08severity\x18\x01\x20\x01(\x0e2=.org.apa\
    che.beam.model.fn_execution.v1.LogEntry.Severity.EnumR\x08severity\x128\
    \n\ttimestamp\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttime\
    stamp\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x14\n\x05t\
    race\x18\x04\x20\x01(\tR\x05trace\x12%\n\x0einstruction_id\x18\x05\x20\
    \x01(\tR\rinstructionId\x12!\n\x0ctransform_id\x18\x06\x20\x01(\tR\x0btr\
    ansformId\x12!\n\x0clog_location\x18\x07\x20\x01(\tR\x0blogLocation\x12\
    \x16\n\x06thread\x18\x08\x20\x01(\tR\x06thread\x1aX\n\x04List\x12P\n\x0b\
    log_entries\x18\x01\x20\x03(\x0b2/.org.apache.beam.model.fn_execution.v1\
    .LogEntryR\nlogEntries\x1ar\n\x08Severity\"f\n\x04Enum\x12\x0f\n\x0bUNSP\
    ECIFIED\x10\0\x12\t\n\x05TRACE\x10\x01\x12\t\n\x05DEBUG\x10\x02\x12\x08\
    \n\x04INFO\x10\x03\x12\n\n\x06NOTICE\x10\x04\x12\x08\n\x04WARN\x10\x05\
    \x12\t\n\x05ERROR\x10\x06\x12\x0c\n\x08CRITICAL\x10\x07\"\x0c\n\nLogCont\
    rol\"\xe1\x04\n\x12StartWorkerRequest\x12\x1b\n\tworker_id\x18\x01\x20\
    \x01(\tR\x08workerId\x12b\n\x10control_endpoint\x18\x02\x20\x01(\x0b27.o\
    rg.apache.beam.model.pipeline.v1.ApiServiceDescriptorR\x0fcontrolEndpoin\
    t\x12b\n\x10logging_endpoint\x18\x03\x20\x01(\x0b27.org.apache.beam.mode\
    l.pipeline.v1.ApiServiceDescriptorR\x0floggingEndpoint\x12d\n\x11artifac\
    t_endpoint\x18\x04\x20\x01(\x0b27.org.apache.beam.model.pipeline.v1.ApiS\
    erviceDescriptorR\x10artifactEndpoint\x12f\n\x12provision_endpoint\x18\
    \x05\x20\x01(\x0b27.org.apache.beam.model.pipeline.v1.ApiServiceDescript\
    orR\x11provisionEndpoint\x12]\n\x06params\x18\n\x20\x03(\x0b2E.org.apach\
    e.beam.model.fn_execution.v1.StartWorkerRequest.ParamsEntryR\x06params\
    \x1a9\n\x0bParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"+\n\x13StartWork\
    erResponse\x12\x14\n\x05error\x18\x01\x20\x01(\tR\x05error\"0\n\x11StopW\
    orkerRequest\x12\x1b\n\tworker_id\x18\x01\x20\x01(\tR\x08workerId\"*\n\
    \x12StopWorkerResponse\x12\x14\n\x05error\x18\x01\x20\x01(\tR\x05error\"\
    %\n\x13WorkerStatusRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"]\
    \n\x14WorkerStatusResponse\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x12\x1f\n\x0bstatus_info\
    \x18\x03\x20\x01(\tR\nstatusInfo2\xc3\x02\n\rBeamFnControl\x12\x86\x01\n\
    \x07Control\x12:.org.apache.beam.model.fn_execution.v1.InstructionRespon\
    se\x1a9.org.apache.beam.model.fn_execution.v1.InstructionRequest\"\0(\
    \x010\x01\x12\xa8\x01\n\x1aGetProcessBundleDescriptor\x12H.org.apache.be\
    am.model.fn_execution.v1.GetProcessBundleDescriptorRequest\x1a>.org.apac\
    he.beam.model.fn_execution.v1.ProcessBundleDescriptor\"\02|\n\nBeamFnDat\
    a\x12n\n\x04Data\x12/.org.apache.beam.model.fn_execution.v1.Elements\x1a\
    /.org.apache.beam.model.fn_execution.v1.Elements\"\0(\x010\x012\x87\x01\
    \n\x0bBeamFnState\x12x\n\x05State\x123.org.apache.beam.model.fn_executio\
    n.v1.StateRequest\x1a4.org.apache.beam.model.fn_execution.v1.StateRespon\
    se\"\0(\x010\x012\x89\x01\n\rBeamFnLogging\x12x\n\x07Logging\x124.org.ap\
    ache.beam.model.fn_execution.v1.LogEntry.List\x1a1.org.apache.beam.model\
    .fn_execution.v1.LogControl\"\0(\x010\x012\xa9\x02\n\x18BeamFnExternalWo\
    rkerPool\x12\x86\x01\n\x0bStartWorker\x129.org.apache.beam.model.fn_exec\
    ution.v1.StartWorkerRequest\x1a:.org.apache.beam.model.fn_execution.v1.S\
    tartWorkerResponse\"\0\x12\x83\x01\n\nStopWorker\x128.org.apache.beam.mo\
    del.fn_execution.v1.StopWorkerRequest\x1a9.org.apache.beam.model.fn_exec\
    ution.v1.StopWorkerResponse\"\02\xa4\x01\n\x12BeamFnWorkerStatus\x12\x8d\
    \x01\n\x0cWorkerStatus\x12;.org.apache.beam.model.fn_execution.v1.Worker\
    StatusResponse\x1a:.org.apache.beam.model.fn_execution.v1.WorkerStatusRe\
    quest\"\0(\x010\x01B\x81\x01\n$org.apache.beam.model.fnexecution.v1B\tBe\
    amFnApiZNgithub.com/apache/beam/sdks/v2/go/pkg/beam/model/fnexecution_v1\
    ;fnexecution_v1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::beam_runner_api::file_descriptor().clone());
            deps.push(super::endpoints::file_descriptor().clone());
            deps.push(super::metrics::file_descriptor().clone());
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(55);
            messages.push(RemoteGrpcPort::generated_message_descriptor_data());
            messages.push(GetProcessBundleDescriptorRequest::generated_message_descriptor_data());
            messages.push(InstructionRequest::generated_message_descriptor_data());
            messages.push(InstructionResponse::generated_message_descriptor_data());
            messages.push(HarnessMonitoringInfosRequest::generated_message_descriptor_data());
            messages.push(HarnessMonitoringInfosResponse::generated_message_descriptor_data());
            messages.push(RegisterRequest::generated_message_descriptor_data());
            messages.push(RegisterResponse::generated_message_descriptor_data());
            messages.push(ProcessBundleDescriptor::generated_message_descriptor_data());
            messages.push(BundleApplication::generated_message_descriptor_data());
            messages.push(DelayedBundleApplication::generated_message_descriptor_data());
            messages.push(ProcessBundleRequest::generated_message_descriptor_data());
            messages.push(ProcessBundleResponse::generated_message_descriptor_data());
            messages.push(ProcessBundleProgressRequest::generated_message_descriptor_data());
            messages.push(MonitoringInfosMetadataRequest::generated_message_descriptor_data());
            messages.push(ProcessBundleProgressResponse::generated_message_descriptor_data());
            messages.push(MonitoringInfosMetadataResponse::generated_message_descriptor_data());
            messages.push(ProcessBundleSplitRequest::generated_message_descriptor_data());
            messages.push(ProcessBundleSplitResponse::generated_message_descriptor_data());
            messages.push(FinalizeBundleRequest::generated_message_descriptor_data());
            messages.push(FinalizeBundleResponse::generated_message_descriptor_data());
            messages.push(Elements::generated_message_descriptor_data());
            messages.push(StateRequest::generated_message_descriptor_data());
            messages.push(StateResponse::generated_message_descriptor_data());
            messages.push(StateKey::generated_message_descriptor_data());
            messages.push(StateGetRequest::generated_message_descriptor_data());
            messages.push(StateGetResponse::generated_message_descriptor_data());
            messages.push(StateAppendRequest::generated_message_descriptor_data());
            messages.push(StateAppendResponse::generated_message_descriptor_data());
            messages.push(StateClearRequest::generated_message_descriptor_data());
            messages.push(StateClearResponse::generated_message_descriptor_data());
            messages.push(LogEntry::generated_message_descriptor_data());
            messages.push(LogControl::generated_message_descriptor_data());
            messages.push(StartWorkerRequest::generated_message_descriptor_data());
            messages.push(StartWorkerResponse::generated_message_descriptor_data());
            messages.push(StopWorkerRequest::generated_message_descriptor_data());
            messages.push(StopWorkerResponse::generated_message_descriptor_data());
            messages.push(WorkerStatusRequest::generated_message_descriptor_data());
            messages.push(WorkerStatusResponse::generated_message_descriptor_data());
            messages.push(process_bundle_request::CacheToken::generated_message_descriptor_data());
            messages.push(process_bundle_request::cache_token::UserState::generated_message_descriptor_data());
            messages.push(process_bundle_request::cache_token::SideInput::generated_message_descriptor_data());
            messages.push(process_bundle_split_request::DesiredSplit::generated_message_descriptor_data());
            messages.push(process_bundle_split_response::ChannelSplit::generated_message_descriptor_data());
            messages.push(elements::Data::generated_message_descriptor_data());
            messages.push(elements::Timers::generated_message_descriptor_data());
            messages.push(state_key::Runner::generated_message_descriptor_data());
            messages.push(state_key::IterableSideInput::generated_message_descriptor_data());
            messages.push(state_key::MultimapSideInput::generated_message_descriptor_data());
            messages.push(state_key::MultimapKeysSideInput::generated_message_descriptor_data());
            messages.push(state_key::BagUserState::generated_message_descriptor_data());
            messages.push(state_key::MultimapKeysUserState::generated_message_descriptor_data());
            messages.push(state_key::MultimapUserState::generated_message_descriptor_data());
            messages.push(log_entry::List::generated_message_descriptor_data());
            messages.push(log_entry::Severity::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(log_entry::severity::Enum::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
